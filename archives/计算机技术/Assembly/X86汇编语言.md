# X86汇编语言

[annotation]: <id> (c4d0635c-fcc9-410d-aedb-c481fb5dd5c7)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-02-04 14:31:43)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/c4d0635c-fcc9-410d-aedb-c481fb5dd5c7)


## 编写主引导扇区代码

```s
    base equ 0x7c00;
    video equ 0xb800;

    mov ax, 0x0003; clear screen
    int 0x10;

    mov ax,video  ;指向文本模式的显示缓冲区
    mov es,ax

    ;以下显示字符串"Label offset:"
    mov byte [es:0x00],'L'
    mov byte [es:0x01],0x07
    mov byte [es:0x02],'a'
    mov byte [es:0x03],0x07
    mov byte [es:0x04],'b'
    mov byte [es:0x05],0x07
    mov byte [es:0x06],'e'
    mov byte [es:0x07],0x07
    mov byte [es:0x08],'l'
    mov byte [es:0x09],0x07
    mov byte [es:0x0a],' '
    mov byte [es:0x0b],0x07
    mov byte [es:0x0c],"o"
    mov byte [es:0x0d],0x07
    mov byte [es:0x0e],'f'
    mov byte [es:0x0f],0x07
    mov byte [es:0x10],'f'
    mov byte [es:0x11],0x07
    mov byte [es:0x12],'s'
    mov byte [es:0x13],0x07
    mov byte [es:0x14],'e'
    mov byte [es:0x15],0x07
    mov byte [es:0x16],'t'
    mov byte [es:0x17],0x07
    mov byte [es:0x18],':'
    mov byte [es:0x19],0x07

    mov ax,number                 ;取得标号number的偏移地址
    mov bx,10


    ;设置数据段的基地址
    mov cx,cs
    mov ds,cx

    ;求个位上的数字
    mov dx,0
    div bx
    mov [0x7c00+number+0x00],dl   ;保存个位上的数字

    ;求十位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x01],dl   ;保存十位上的数字

    ;求百位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x02],dl   ;保存百位上的数字

    ;求千位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x03],dl   ;保存千位上的数字

    ;求万位上的数字 
    xor dx,dx
    div bx
    mov [0x7c00+number+0x04],dl   ;保存万位上的数字

    ;以下用十进制显示标号的偏移地址
    mov al,[0x7c00+number+0x04]
    add al,0x30
    mov [es:0x1a],al
    mov byte [es:0x1b],0x04
    
    mov al,[0x7c00+number+0x03]
    add al,0x30
    mov [es:0x1c],al
    mov byte [es:0x1d],0x04
    
    mov al,[0x7c00+number+0x02]
    add al,0x30
    mov [es:0x1e],al
    mov byte [es:0x1f],0x04

    mov al,[0x7c00+number+0x01]
    add al,0x30
    mov [es:0x20],al
    mov byte [es:0x21],0x04

    mov al,[0x7c00+number+0x00]
    add al,0x30
    mov [es:0x22],al
    mov byte [es:0x23],0x04
    
    mov byte [es:0x24],'D'
    mov byte [es:0x25],0x07
    
infi: jmp near infi                 ;无限循环

number db 0,0,0,0,0

times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

- 注释：必须以英文字母 ; 开始。

---

主引导扇区 (MBR Main Boot Sector) 数据有 512 字节，ROM-BIOS 程序将它加载到逻辑地址 0x0000:0x7c00 处，然后判断它是否有效。

一个有效的主引导扇区，最后两个字节应该是 0x55 和 0xAA，如果主引导扇区有效，则以一个段间转移指令 jmp 0x0000:0x7c00 跳到那里继续执行。

---

8086 可以访问 1MB 内存，其中：

- 0x00000-0x9ffff 属于常规内存，由内存条提供；
- 0xa0000-0xeffff 由特定的外围设备提供；
- 0xf0000-0xfffff 由主板上的一个芯片提供，ROM-BIOS；

其中 0xa0000-0xeffff 就包括显卡，由于历史原因，所有在个人计算机上使用的显卡，在加电自检后都会把自己初始化到 80x25 的文本模式，在这种模式下可以显示 25 行，每行 80 个字符，每屏总共 2000 个字符。

0xb8000 - 0xbffff 是留给显卡的，由显卡来提供。

---

字符串显示的格式：

- 高四位背景色：| K | R | G | B |
- 底四位前景色：| I | R | G | B |
- K=0：背景不闪烁
- K=1：背景闪烁
- I=1：浅色
- K=0：深色

---

- 不允许 `mov` 立即数到 段寄存器
- 关键字 `byte` 用来修饰目的操作数，指出本次传送是以字节的方式进行的。
- `mov` 指令的目的操作数不允许为立即数

```s
    mov byte [es:0xf9e],0x48
    mov byte [es:0xf9f],0x27

    ; mov al, 0x55aa ; warning 数据溢出 warning: byte data exceeds bounds
    ; mov ds, 0x6000; invalid combination of opcode and operands
    ; mov ds, al; invalid combination of opcode and operands
    ; mov [0x06], 0x55aa; error: operation size not specified
    mov ds, bx;
    mov ax, 0x02;
    mov word [0x0a], ax;
    mov es, cx;
    ; mov ax, bl; invalid combination of opcode and operands
    mov byte [0x00], 'C';
    ; mov [0x02], [0xf000]; invalid combination of opcode and operands
    mov ds, [0x03];
```

检测点 5.2 

```s
data1 db 0x55, 0xf000, 0x0f; warning: byte data exceeds bounds [-w+number-overflow]
data2 dw 0x38, 0x20, 0x55aa
```

---



下面改良一下字符串显示：

```s
[org 0x7c00]

    base equ 0x7c00;
    video equ 0xb800;
    jmp _start

print:
    cld
print_loop:
    lodsb
    or al, al
    jz print_done
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    jmp print_loop
print_done:
    ret

_start:
    mov ax, cs;
    mov ds, ax;
    mov ss, ax;
    mov sp, base;

    mov ax, 0x0003; clear screen
    int 0x10;

    mov ax,video  ;指向文本模式的显示缓冲区
    mov es,ax

    ; xchg bx, bx; magic break point

    ;以下显示字符串"Label offset:"
    mov si, message
    call print

    mov ax,number  ;取得标号number的偏移地址
    mov cx, 5;
number_loop:

    mov bx,10
    mov dx,0
    div bx ; (dx ax) / bx = 商(ax) 余数(dx)

    mov bx, dx;
    mov dl, [bx + string]

    mov bx, cx;
    mov [bx + number - 1], dl

    loop number_loop

    mov si, number
    call print
    
infi: jmp near infi                 ;无限循环

string: db '0123456789ABCDEF', 0

number db 0,0,0,0,0, 'D', 0
message db "Label offset:", 0; 字符串以 0 结尾
times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

---

- cld / std：用来操作方向标志位 DF(Direction Flag) DF = 0 / 1
- lodsb / lodsw 块装入指令，其具体操作是把 SI 指向的存储单元读入累加器，
  - LODSB就读入AL, SI += 1
  - LODSW就读入AX, SI += 2
- movsb：字符串传送指令，这条指令按字节传送数据。将 [DS:SI] 的一个字节移到 [ES:DI]。
- xchg 指令用于交换，后面两个寄存器，或内存中的值

---

Effective Address Mod R/M Value of ModR/M Byte (in Hexadecimal)


- [BX+SI]
- [BX+DI]
- [BP+SI]
- [BP+DI]
- [SI]
- [DI]
- [BX]
- [BX+SI]+disp8
- [BX+DI]+disp8
- [BP+SI]+disp8
- [BP+DI]+disp8
- [SI]+disp8
- [DI]+disp8
- [BP]+disp8
- [BX]+disp8
- [BX+SI]+disp16
- [BX+DI]+disp16
- [BP+SI]+disp16
- [BP+DI]+disp16
- [SI]+disp16
- [DI]+disp16
- [BP]+disp16
- [BX]+disp16

---

二进制数可以以如下方式输入，用下划线方便确定位数，最后以B结尾。

```s
mov ax, 0000_0001_0111_1111b
```

十六进制数可以以 0x 开始，或者以 H 结束，二者只能存在一种。

---

```s
xchg bx, bx
```

该指令无意义，在 bochs 中调试时表示断点 Magic Breakpoint，可以方便在 bochs 中调试，需要在 bochs 配置文件中，配置 magic breakpoint

    magic_break: enabled=1

另外，也可以打开 gui 调试功能，方便调试：

    display_library: x, options="gui_debug"

---

## 相同的功能，不同的代码

在NASM 里，`\` 是续行符， 当一行写不下时，可以在行尾使用这个符号，以表明下一行与当前行应该合并为一行。


---

- div 除法指令：
    - ax / bl = 商(al) 余数(ah) | 除数为 8 位
    - (dx ax) / bx = 商(ax) 余数(dx) | 除数为 16 位
- idiv 有符号除法指令
- cbw：字节到字的扩展指令
- cwd：字到双字符的扩展指令，可将AX内容扩展到DX
    - 若AX最高位=1，则执行后DX=FFFFH；
    - 若AX最高位=0，则执行后DX=0000H
- neg：求补指令

---

- 奇偶标志位 PF(Parity Flag)
- 进位标志位 CF(Carry Flag)
- 溢出标志位 OF(Overflow Flag)


### 条件转移指令

| 比较结果   | 英文                 | 指令 | 标志                |
| ---------- | -------------------- | ---- | ------------------- |
| 等于       | Equal                | je   | ZF = 1              |
| 不等于     | Not Equal            | jne  | ZF = 0              |
| 大于       | Greater              | jg   | ZF = 0 and SF = OF  |
| 大于等于   | Greater or Equal     | jge  | SF = 0F             |
| 不大于     | Not Greater          | jng  | ZF = 1 or SF != OF  |
| 不大于等于 | Not Greater or Equal | jnge | SF != OF            |
| 小于       | Less                 | jl   | SF != OF            |
| 小于等于   | Less or Equal        | jle  | ZF = 1 and SF != OF |
| 不小于     | Not Less             | jnl  | SF = OF             |
| 不小于等于 | Not Less or Equal    | jnle | ZF = 0 and SF = 0f  |
| 高于       | Above                | ja   | CF = 0 and ZF = 0   |
| 高于等于   | Above or Equal       | jae  | CF = 0              |
| 不高于     | Not Above            | jna  | CF = 1 or ZF = 1    |
| 不高于等于 | Not Above or Equal   | jnae | CF = 1              |
| 低于       | Below                | jb   | CF = 1              |
| 低于等于   | Below or Equal       | jbe  | CF = 1 or ZF = 1    |
| 不低于     | Not Below            | jnb  | CF = 0              |
| 不低于等于 | Not Below or Equal   | jnbe | CF = 0 and ZF = 0   |
| 偶         | Parity Even          | jpe  | PF = 1              |
| 奇         | Parity Odd           | jpo  | PF = 0              |

---

- \$ 代表当前行的汇编地址；
- \$\$ 代表当前汇编节（段）的起始汇编地址

---

## 参考资料

- [李忠 - X86汇编语言](https://book.douban.com/subject/20492528/)
