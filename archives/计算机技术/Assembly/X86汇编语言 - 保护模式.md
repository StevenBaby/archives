# X86汇编语言 - 保护模式

[annotation]: <id> (b1139606-b12b-48a8-aa7a-8508fb627498)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-02-09 21:41:55)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/b1139606-b12b-48a8-aa7a-8508fb627498)


## 32位 x86 处理器变成架构


Intel 32 位处理器架构简称 IA-32 (Intel Architecture, 32-bit ) ，是以1978 年的 8086 处理器为基础发展起来的。

8086 有 20 根地址线，可以寻址 1MB 内存。但是，它内部的寄存器是 16 位的， 无法在程序中访问整个 1MB 内存。所以，它也是第一款支持内存分段模型的处理器。还有， 8086 处理器只有一种工作模式，即 **实模式**。当然，在那时，还没有实模式这一说。

32 位的处理器有 32 根地址线，数据线的数量是 32 根或者 64 根。特别是最近最新的处理器，都是 64 根。因此，它可以访问 $2^{32}$ 即 4GB 的内存，而且每次可以读写连续的 4字节 或者 8字节， 这称为双字(Double Word) 或者 4 字(Quad Word) 访问。当然，如果你要按字节或者字来访问内存，也是允许的。

在 16 位处理器内， 有 8 个通用寄存器 AX 、BX 、EX 、DX、SI 、DI 、BP 和 SP, 其中，前 4 个还可以拆分成两个独立的 8 位寄存器来用，即 AH 、AL 、BH 、BL 、CH 、CL 、DH 和 DL。

32 位处理器在 16 位处理器的基础上，扩展了这 8 个通用寄存器的长度，使之达到 32 位。

为了在汇编语言程序中使用经过扩展 (Extend) 的寄存器，需要给它们命名，它们的名字分别是EAX 、EBX 、ECX 、EDX 、ESI 、EDI 、ESP 和 EBP。

---

在 32 位模式下， 对内存的访问从理论上来说不再需要分段，因为它有32 根地址线， 可以自由访问任何一个内存位置。 但是， IA-32 架构的处理器是基于分段模型的，因此， 32 位处理器依然需要以段为单位访问内存，即使它工作在 32 位模式下。不过，它也提供了一种变通的方案，即， 只分一个段，段的基地址是 `0x00000000`, 段的长度（大小）是 4GB 。在这种情况下，可以视为不分段，即**平坦模型**(Flat Mode)。

----

在 32 位模式下，传统的段寄存器，如CS 、SS 、DS 、ES，保存的不再是 16 位段基地址，而是段的 **选择子**，即用于选择所要访问的段，因此，严格地说，它的新名字叫做**段选择器**。除了段选择器之外，每个段寄存器还包括一个不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。

---

1982 年的时候， Intel 公司推出了 `80286` 处理器。这也是一款 16 位的处理器，大部分的寄存器都和8086 处理器一样。因此， 80286 和8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段：尽管它有 24 根地址线，理论上可以访问 $2^{24}$ 即 16MB 的内存，但依然只能分成多个段来进行。

但是， 80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位千段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。

1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品。

---

IA-32 处理器支持多任务。在多任务环境下，任务的创建需要分配内存空间；当任务终止后，还要回收它所占用的内存空间。在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了， 内存空间就会碎片化，就有可能出现一种情况：内存空间是有的， 但都是小块，无法分配给某个任务。为了解决这个问题， IA-32 处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的， 一般为 4KB , 通过使页，可以简化内存管理。

当页功能开启时，段部件产生的地址就**不再是物理地址**了，而是 **线性地址**(Linear Address) ，线性地址还要经页部件转换后，才是物理地址。

线性地址的概念用来描述任务的地址空间， IA-32 处理器上的每个任务都拥有 4GB 的虚拟内存空间，这是一段长 4GB 的平坦空间，就像一段平直的线段，因此叫线性地址空间。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是线性地址。

---

高速缓存的用处源于程序在运行时所具有的 **局部性原理**。首先，程序常常访问最近刚刚访问过的指令和数据，或者与它们相邻的指令和数据。比如，程序往往是序列化地从内存中取指令执行的，循环操作往往是执行一段固定的指令。当访问数据时，要访问的数据通常都被安排在一起；其次， 一旦访问了某个数据， 那么，不久之后，它可能会被再次访问。

利用程序运行时的局部性原理，可以把处理器正在访问和即将访问的指令和数据块从内存调入高速缓存中。于是，每当处理器要访问内存时，首先检索高速缓存。如果要访问的内容已经在高速缓存中，那么，很好，可以用极快的速度直接从高速缓存中取得，这称为命中(Hit) ；否则，称为不中(miss)。在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为 **不中惩罚**( miss penalty ）。

高速缓存的复杂性在于，每一款处理器可能都有不同的实现。在一些复杂的处理器内部，会存在多级 Cache, 分别应用于各个独立的执行部件。

----

- 流水线
- 高速缓存
- 乱序执行
- 寄存器重命名
- 分支目标预测


在1996 年的Pentium Pro 处理器上，引入了分支预测技术(Branch Prediction)

---

## 进入保护模式

在32 位保护模式下，段地址是 32 位的线性地址，如果未开启分页功能，该线性地址就是物理地址。

描述符中的段基地址和段界限不是连续的，把它们分成几段似乎不科学。但这也是没有办法的事，这是从 80286 处理器上带来的后遗症。80286 也是 16 位的处理器，也有保护模式，但属于 16 位的保护模式。而且，其地址是 24 位的，允许访问最多16MB 的内存。尽管 80286 的 16 位保护模式从来也没形成气候，但是，32 位处理器为了保持同 80286 的兼容，只能在旧描述符的格式上进行扩充，这是不得已的做法。

代码：进入保护模式

```s
section mbr align=16 vstart=0x7c00
    mov ax, 0x0003; clear screen
    int 0x10;

    ;设置堆栈段和栈指针 
    mov ax,cs      
    mov ss,ax
    mov sp,0x7c00

    ; xchg bx, bx
    ;计算GDT所在的逻辑段地址 
    mov ax,[cs:gdt_base]        ;低16位 0x7e00
    mov dx,[cs:gdt_base+0x02]   ;高16位 0x0000
    mov bx,16        
    div bx                             ;商(ax) 余数(dx) 
    mov ds,ax                          ;令 DS 指向该段以进行操作
    mov bx,dx                          ;段内起始偏移地址

    ;创建0#描述符，它是空描述符，这是处理器的要求
    xor si, si
    mov dword [bx+si],0x00

    add si, 4;
    mov dword [bx+si],0x00

    ;创建#1描述符，保护模式下的代码段描述符
    add si, 4
    mov dword [bx+si],0x7c0001ff 
    ; 0111 1100 0000 0000 0000 0001 1111 1111
    ; 线性基地址 15 - 0 0x7c00, 段界限 15 - 0 0x1ff

    add si, 4;
    mov dword [bx+si],0x00409800 ; 0000 0000 0100 0000 1001 1000 0000 0000
    
    ; 0x00; 段基地址 31 - 24
    ; 0x4;
        ; 0     ; G = 0 粒度字节，段的扩展范围从 1 字节到 1M 字节 (1B - 1MB)
                ; G = 1 段界限是以 4KB 为单位
        ; 1     ; D/B 默认操作数大小，默认的栈指针大小，上部边界标志； 
                ; 代码段为 D，用于指示指令中默认的偏移地址和操作数尺寸。
                ; D = 0 表示指令中的偏移地址或者操作数是 16 位的
                ; D = 1, 指示32位的偏移地址或者操作数。具体的操作影响 使用 ip 还是 eip
                ; 对于栈段来说，该位叫做 B 位，影响 sp / esp
                ; 位的值也决定了栈的上部边界。如果 B=0, 那么栈段的上部边界（也就是SP 寄存器的最大值）为OxFFFF ; 
                ; 如果B = 1, 那么栈段的上部边界 （也就是ESP 寄存器的最大值）为OxFFFFFFFF 。
                ; 由于这里需要做 32 位保护模式，于是这个值应该一直是 1
        ; 0 ; L 64 代码段标志，保留此位给 64 位操作系统使用。目前用不上
        ; 0 ; AVL ; 好吧，该安排的都安排了，最后多出这么一位，不知道干什么用好，就给软件用吧
    ; 0x0 ; 段界限 19 - 16

    ; 0x9
        ; 1 ; P = 1 该段目前在内存中

        ; 00    ; DPL 特权级 0 最高特权级

        ; 1     ; S = 1 属于存储器的段
                ; S = 0 表示一个系统段
    ; 0x8;
    ; 1000  ; Type 表示描述符类型
            ; 数据段：
                ; X (0 不可执行) 
                ; E (0 向上扩展，1 向下扩展)
                ; W (0 只读，1 可写)
                ; A (已访问位，处理器访问时置1，清理由软件负责，用于实现虚拟内存管理)
            ; 代码段 
                ; X(1 可执行)
                ; C 
                    ; 0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；
                    ; 1 表示允许从低特权级的程序转移到该段执行。
                ; R (0 不可读，1 可读)，用于限制操作系统和用户，而非CPU
                ; A (已访问位，处理器访问时置1，清理由软件负责，用于实现虚拟内存管理)

    ; 0x00 段基地址 23 - 16


    ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
    add si, 4;
    mov dword [bx+si],0x8000ffff; 线性基地址 15-0 0x8000; 段界限 15 - 0 0xffff;
    add si, 4;
    mov dword [bx+si],0x0040920b; 100000010010010 00001011

    ; 0x00 ;段基地址 31 - 24
    ; 0x40 ;
        ; 0x4; 0100
            ; 0 ; G 粒度字节
            ; 1 ; D/B 32 位标志
            ; 0 ; L
            ; 0 ; AVL
        ; 0x0; 段界限 19 - 16
    ; 0x92 ;
        ; 0x9 ; 1001 ;
            ; 1 ; P 在内存中
            ; 00 ; 特权级 0
            ; 1 ; S 存储器段
        ; 0x2 ; Type 0 数据段 0 向下扩展 1 可写 0 未访问
    ; 0x0b ; 段基地址 23 - 16

    ; 线性基地址 0x000b8000
    ; 段界限 0x0ffff

    ;创建#3描述符，保护模式下的堆栈段描述符
    add si, 4;
    mov dword [bx+si],0x00007a00 ; 线性基地址 15-0 0x0000; 段界限 15 - 0 0x7a00;

    add si, 4;
    mov dword [bx+si],0x00409600 ; 100000010010110 0000 0000

    ; 0x00 ; 段基地址 31 - 24
    ; 0x40
        ; 0x4; 0100
            ; 0 ; G 粒度字节
            ; 1 ; D/B 32 位标志
            ; 0 ; L
            ; 0 ; AVL
        ; 0x0; 段界限 19 - 16
    ; 0x96
        ; 0x9 ; 1001 ;
            ; 1 ; P 在内存中
            ; 00 ; 特权级 0
            ; 1 ; S 存储器段
        ; 0x6 ; Type 0 数据段 1 向上扩展 1 可写 0 未访问
    ; 0x00 ; 段基地址 23 - 16

    ; 线性基地址 0x00000000
    ; 段界限 0x07a00

    ;初始化描述符表寄存器GDTR
    mov word [cs: gdt_size], 31  ;描述符表的界限（总字节数减一）   

    ; xchg bx, bx
    lgdt [cs: gdt_size] 
    ; 在这6 字节的内存区域中，
    ; 要求前（低） 16 位是GDT 的界限值，
    ; 后（高） 32 位是GDT 的基地址。
    ; 在初始状态下（计算机启动之后）
    ; GDTR 的基地址被初始化为 0x00000000; 界限值为 0xffff 。

    in al,0x92                         ;南桥芯片内的端口
    or al,0000_0010B
    out 0x92,al                        ;打开A20

    cli                                ;保护模式下中断机制尚未建立，应 
                                    ;禁止中断 
    mov eax,cr0
    or eax,1
    mov cr0,eax                        ;设置PE位 Protection Enable

    ;以下进入保护模式... ...
    jmp dword 0x0008:(flush - 0x7c00)   ;16位的描述符选择子：32位偏移
                                        ;清流水线并串行化处理器 
                                        ; 0000_0000_0000_1000b

    [bits 32] 

flush:
    mov cx,0000_0000_00010_0_00B         ;加载数据段选择子(10b)
    mov ds,cx

    ;以下在屏幕上显示"Protect mode OK."
    mov byte [0x00],'P'  
    mov byte [0x02],'r'
    mov byte [0x04],'o'
    mov byte [0x06],'t'
    mov byte [0x08],'e'
    mov byte [0x0a],'c'
    mov byte [0x0c],'t'
    mov byte [0x0e],' '
    mov byte [0x10],'m'
    mov byte [0x12],'o'
    mov byte [0x14],'d'
    mov byte [0x16],'e'
    mov byte [0x18],' '
    mov byte [0x1a],'O'
    mov byte [0x1c],'K'

    ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
    mov cx,00000000000_11_000B         ;加载堆栈段选择子
    mov ss,cx
    mov esp,0x7c00

    mov ebp,esp                        ;保存堆栈指针 
    push byte '.'                      ;压入立即数（字节）
    
    sub ebp,4
    cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
    jnz ghalt                          
    pop eax
    mov [0x1e],al                      ;显示句点 

ghalt:     
    hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------

    gdt_size    dw 0 ; GDT Size - 1 2B
    gdt_base    dd 0x00007e00     ;GDT的物理地址 4B

    times 510-($-$$) db 0
                    db 0x55,0xaa
```

在保护模式下访问一个段时，传送到段选择器的是段选择子。它由三部分组成，

- 第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。
- TI 是描述符表指示器(Table Indicator), 
    - TI = 0 时，表示描述符在 GDT 中； 
    - TI = 1 时，描述符在 LDT 中，它也是一个描述符表，和 GDT 类似。
- RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。

---

在保护模式下，不允许使用 `mov` 指令改变段寄存器 `CS` 的内容，比如：

    mov cs, ax

企图这样做将导致处理器产生一个无效操作码的异常中断。

----

## 存储器的保护

存储器保护代码：

```s
    ;代码清单12-1
    ;文件名：c12_mbr.asm
    ;文件说明：硬盘主引导扇区代码 
    ;创建日期：2011-10-27 22:52

mbr_base equ 0x7c00

section mbr align=16 vstart=mbr_base

    mov ax, 0x0003; clear screen
    int 0x10;

    ;设置堆栈段和栈指针 
    mov eax,cs      
    mov ss,eax
    mov sp, mbr_base

    ;计算GDT所在的逻辑段地址
    mov eax,[cs:gdt+0x02]      ;GDT的32位线性基地址 
    xor edx,edx
    mov ebx,16
    div ebx                            ;分解成16位逻辑地址 

    mov ds,eax                         ;令DS指向该段以进行操作
    mov ebx,edx                        ;段内起始偏移地址 

    ;创建0#描述符，它是空描述符，这是处理器的要求
    mov dword [ebx+0x00],0x00000000
    mov dword [ebx+0x04],0x00000000  

    ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
    mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff
    mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

    ;创建保护模式下初始代码段描述符
    mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
    mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

    ;创建以上代码段的别名描述符
    mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
    mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符

    mov dword [ebx+0x20],0x7c00fffe
    mov dword [ebx+0x24],0x00cf9600
    
    ;初始化描述符表寄存器GDTR
    mov word [cs: gdt],39      ;描述符表的界限   

    lgdt [cs: gdt]

    in al,0x92                         ;南桥芯片内的端口 
    or al,0000_0010B
    out 0x92,al                        ;打开A20

    cli                                ;中断机制尚未工作

    mov eax,cr0
    or eax,1
    mov cr0,eax                        ;设置PE位

    ;以下进入保护模式... ...
    jmp dword 0x0010:(flush - mbr_base)            ;16位的描述符选择子：32位偏移
                                        
    [bits 32]                          
flush:                                     
    mov eax,0x0018                      
    mov ds,eax

    mov eax,0x0008                     ;加载数据段(0..4GB)选择子
    mov es,eax
    mov fs,eax
    mov gs,eax

    mov eax,0x0020                     ;0000 0000 0010 0000
    mov ss,eax
    xor esp,esp                        ;ESP <- 0

    mov dword [es:0x0b8000],0x072e0750 ;字符'P'、'.'及其显示属性
    mov dword [es:0x0b8004],0x072e074d ;字符'M'、'.'及其显示属性
    mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性
    mov dword [es:0x0b800c],0x076b076f ;字符'o'、'k'及其显示属性

    xchg bx, bx
    ;开始冒泡排序 
    mov ecx,gdt-string-1              ;遍历次数=串长度-1 
@@1:
    push ecx                           ;32位模式下的loop使用ecx 
    xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 
@@2:                                      ;是后面的32位 
    mov ax,[string - mbr_base +bx] 
    cmp ah,al                          ;ah中存放的是源字的高字节 
    jge @@3 
    xchg al,ah 
    mov [string - mbr_base +bx],ax 
@@3:
    inc bx 
    loop @@2 
    pop ecx 
    loop @@1

    mov ecx,gdt-string
    xor ebx,ebx                        ;偏移地址是32位的情况 
@@4:                                      ;32位的偏移具有更大的灵活性
    mov ah,0x07
    mov al,[string - mbr_base +ebx]
    mov [es:0xb80a0+ebx*2],ax          ;演示0~4GB寻址。
    inc ebx
    loop @@4
    hlt 

; section data
;-------------------------------------------------------------------------------
string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw'
;-------------------------------------------------------------------------------
gdt     dw 0               ; GDT Size 由程序中计算得出
        dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------                             
times   510-($-$$)  db 0
                    dw 0xaa55
```

## 参考资料

- [李忠 - X86汇编语言](https://book.douban.com/subject/20492528/)