# X86汇编语言 - 保护模式

[annotation]: <id> (b1139606-b12b-48a8-aa7a-8508fb627498)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-02-09 21:41:55)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/b1139606-b12b-48a8-aa7a-8508fb627498)


## 32位 x86 处理器变成架构


Intel 32 位处理器架构简称 IA-32 (Intel Architecture, 32-bit ) ，是以1978 年的 8086 处理器为基础发展起来的。

8086 有 20 根地址线，可以寻址 1MB 内存。但是，它内部的寄存器是 16 位的， 无法在程序中访问整个 1MB 内存。所以，它也是第一款支持内存分段模型的处理器。还有， 8086 处理器只有一种工作模式，即 **实模式**。当然，在那时，还没有实模式这一说。

32 位的处理器有 32 根地址线，数据线的数量是 32 根或者 64 根。特别是最近最新的处理器，都是 64 根。因此，它可以访问 $2^32$ 即 4GB 的内存，而且每次可以读写连续的 4字节 或者 8字节， 这称为双字(Double Word) 或者 4 字(Quad Word) 访问。当然，如果你要按字节或者字来访问内存，也是允许的。

在 16 位处理器内， 有 8 个通用寄存器 AX 、BX 、EX 、DX、SI 、DI 、BP 和 SP, 其中，前 4 个还可以拆分成两个独立的 8 位寄存器来用，即 AH 、AL 、BH 、BL 、CH 、CL 、DH 和 DL。

32 位处理器在 16 位处理器的基础上，扩展了这 8 个通用寄存器的长度，使之达到 32 位。

为了在汇编语言程序中使用经过扩展 (Extend) 的寄存器，需要给它们命名，它们的名字分别是EAX 、EBX 、ECX 、EDX 、ESI 、EDI 、ESP 和 EBP。

---

在 32 位模式下， 对内存的访问从理论上来说不再需要分段，因为它有32 根地址线， 可以自由访问任何一个内存位置。 但是， IA-32 架构的处理器是基于分段模型的，因此， 32 位处理器依然需要以段为单位访问内存，即使它工作在 32 位模式下。不过，它也提供了一种变通的方案，即， 只分一个段，段的基地址是 `0x00000000`, 段的长度
（大小）是 4GB 。在这种情况下，可以视为不分段，即**平坦模型**(Flat Mode)。

----

在 32 位模式下，传统的段寄存器，如CS 、SS 、DS 、ES，保存的不再是 16 位段基地址，而是段的 **选择子**，即用于选择所要访问的段，因此，严格地说，它的新名字叫做**段选择器**。除了段选择器之外，每个段寄存器还包括一个不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。

---

1982 年的时候， Intel 公司推出了 `80286` 处理器。这也是一款 16 位的处理器，大部分的寄存器都和8086 处理器一样。因此， 80286 和8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段：尽管它有 24 根地址线，理论上可以访问 $2^{24}$ 即 16MB 的内存，但依然只能分成多个段来进行。

但是， 80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位千段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。

1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品。

---

IA-32 处理器支持多任务。在多任务环境下，任务的创建需要分配内存空间；当任务终止后，还要回收它所占用的内存空间。在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了， 内存空间就会碎片化，就有可能出现一种情况：内存空间是有的， 但都是小块，无法分配给某个任务。为了解决这个问题， IA-32 处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的， 一般为 4KB , 通过使页，可以简化内存管理。

当页功能开启时，段部件产生的地址就**不再是物理地址**了，而是 **线性地址**(Linear Address) ，线性地址还要经页部件转换后，才是物理地址。

线性地址的概念用来描述任务的地址空间， IA-32 处理器上的每个任务都拥有 4GB 的虚拟内存空间，这是一段长 4GB 的平坦空间，就像一段平直的线段，因此叫线性地址空间。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是线性地址。

---

高速缓存的用处源于程序在运行时所具有的 **局部性原理**。首先，程序常常访问最近刚刚访问过的指令和数据，或者与它们相邻的指令和数据。比如，程序往往是序列化地从内存中取指令执行的，循环操作往往是执行一段固定的指令。当访问数据时，要访问的数据通常都被安排在一起；其次， 一旦访问了某个数据， 那么，不久之后，它可能会被再次访问。

利用程序运行时的局部性原理，可以把处理器正在访问和即将访问的指令和数据块从内存调入高速缓存中。于是，每当处理器要访问内存时，首先检索高速缓存。如果要访问的内容已经在高速缓存中，那么，很好，可以用极快的速度直接从高速缓存中取得，这称为命中(Hit) ；否则，称为不中(miss)。在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为 **不中惩罚**( miss penalty ）。

高速缓存的复杂性在于，每一款处理器可能都有不同的实现。在一些复杂的处理器内部，会存在多级 Cache, 分别应用于各个独立的执行部件。

----

- 流水线
- 高速缓存
- 乱序执行
- 寄存器重命名
- 分支目标预测


在1996 年的Pentium Pro 处理器上，引入了分支预测技术(Branch Prediction)

---

## 参考资料

- [李忠 - X86汇编语言](https://book.douban.com/subject/20492528/)