# X86 汇编语言 - 内存检测

[annotation]: <id> (809f4839-9ad3-4a66-a599-aa445b915157)
[annotation]: <status> (protect)
[annotation]: <create_time> (2021-03-11 17:40:20)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <topic> (x86 汇编语言)
[annotation]: <index> (2)
[annotation]: <url> (http://blog.ccyg.studio/article/809f4839-9ad3-4a66-a599-aa445b915157)


## 0xe820

BIOS 中断 `0x15` 的子功能 `0xE820` 能够获取系统的内存布局，由于系统内存各部分的类型属性不同，BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 `0xE820` 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存
储这种描述符的结构称之为地址范围描述符 (Address Range Descriptor Structure, ARDS)，格式见下表。

| 字节偏移量 | 属性名称     | 描述                             |
| ---------- | ------------ | -------------------------------- |
| 0          | BaseAddrLow  | 基地址的低 32 位                 |
| 4          | BaseAddrHigh | 基地址的高 32 位                 |
| 8          | LengthLow   | 内存长度的低 32 位，以字节为单位 |
| 12         | LengthHigh   | 内存长度的高 32 位，以字节为单位 |
| 16         | Type         | 本段内存的类型                   |

此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 `int 0x15` 之后， BIOS 就返回这样一个结构的数据。

### Type 字段 的解释 

| Type 值 | 名称                 | 描述                                                                                 |
| ------- | -------------------- | ------------------------------------------------------------------------------------ |
| 1       | AddressRangeMemory   | 这段内存可以被操作系统使用                                                           |
| 2       | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以用此内存                                     |
| 其他    | 未定义               | 未定义，将来会用到．目前保留． 但是需要操作系统一样将其视为ARR(AddressRangeReserved) |

### 调用前输入

| 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                                                                                 |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| EAX            | 子功能号： EAX 寄存器用来指定子功能号，此处输入为 0xE820                                                                                                                                                                                                                                                 |
| EBX            | 内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉 BIOS 该返回哪个 ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现，每次中断返回后，BIOS 会更新此值 |
| ES: DI         | ARDS 缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以 ARDS 格式返回                                                                                                                                                                                                                       |
| ECX            | ARDS 结构的字节大小：用来指示 BIOS 写入的字节数。调用者和 BIOS 都同时支持的大小是 20 字节，将来也许会扩展此结构                                                                                                                                                                                          |
| EDX            | 固定为签名标记 `0x534d4150`，此十六进制数字是字符串 `SMAP` 的ASCII 码： BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息                                                                                                                                 |

### 返回后输出

| 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                   |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| CF 位          | 若CF 位为 0 表示调用未出错，CF 为1，表示调用出错                                                                                                                                                                                           |
| EAX            | 字符串 SMAP 的 ASCII 码 `0x534d4150`                                                                                                                                                                                                       |
| ES:DI          | ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被BIOS 填充了内存信息                                                                                                                                                                 |
| ECX            | BIOS 写入到 ES:DI 所指向的 ARDS 结构中的字节数，BIOS 最小写入 20 字节                                                                                                                                                                      |
| EBX            | 后续值：下一个 ARDS 的位置。每次中断返回后，BIOS 会更新此值， BIOS 通过此值可以找到下一个待返回的 ARDS 结构，咱们不需要改变 EBX 的值，下一次中断调用时还会用到它。在 CF 位为 0 的情况下，若返回后的 EBX 值为 0，表示这是最后一个 ARDS 结构 |

## 0xe801

此方法虽然简单，但功能也不强大，最大只能识别 4GB 内存

### 调用前输入

| 寄存器或状态位 | 用途          | 描述             |
| -------------- | ------------- | ---------------- |
| AX             | Function Code | 子功能号：0xE801 |

### 返回后输出

| 寄存器或状态位 | 用途         | 描述                                                                                                      |
| -------------- | ------------ | --------------------------------------------------------------------------------------------------------- |
| CF 位          | Carry Flag   | 若 CF 位为 0 表示调用未出错，CF 为 1，表示调用出错                                                        |
| AX             | Extended 1   | 以 1KB 为单位，只显示 15MB 以下的内存容量，故最大值为 0x3c00 ，即 AX 表示的最大内存为 0x3C00 * 1024= 15MB |
| BX             | Extended 2   | 以 64KB 为单位，内存空间 16MB - 4GB 中连续的单位数量，即内存大小为 BX * 64 * 1024 字节                    |
| EX             | Configured 1 | 同AX                                                                                                      |
| DX             | Configured 2 | 同BX                                                                                                      |

## 0x88

最后一个获取内存的方法也同样是BIOS 0x15 中断，子功能号是 0x88 。该方法使用最简单，但功能也最简单，简单到只能识别最大64肌面的内存。

- 输入
    - AH ：子功能号：0x88
- 输出
    - CF ： 若CF 位为0 表示调用未出错， CF 为1，表示调用出错
    - AX ： 以 1KB 为单位大小，内存空间 1 MB 之上的连续单位数量，不包括低端 1MB 内存。故内存大小为 AX * 1024 字节 + 1MB

## 内存检测代码


```s
    ; detect memory
    xor ebx, ebx
    mov edx, 0x534d4150
    mov di, ards_buffer

.check_memory_r820:
    mov eax, 0x0000e820
    mov ecx, 20
    int 0x15

    jc .get_memory_e801

    add di, cx
    inc word [ards_count]
    cmp ebx, 0
    jnz .check_memory_r820

    mov cx, [ards_count]
    mov ebx, ards_buffer
    xor edx, edx

.get_max_memory_area:

    mov eax, [ebx]
    add eax, [ebx + 8]
    add ebx, 20
    cmp edx, eax
    jge .next_ards
    mov edx, eax

.next_ards:
    loop .get_max_memory_area
    jmp .get_memory_ok

.get_memory_e801:
    mov ax, 0xe801
    mul cx
    shl edx, 16
    and eax, 0x0000ffff
    or edx, eax
    add edx, 0x100000
    mov esi, edx

    xor eax, eax
    mov ax, bx
    mov ecx, 0x10000
    mul ecx
    add esi, eax
    mov edx, esi
    jmp .get_memory_ok

.get_memory_e88:
    mov ah, 0x88
    int 0x15
    jc .get_memory_failure

    and eax, 0x0000ffff

    mov cx, 0x400
    mul cx

    shl edx, 16
    or edx, eax
    and edx, 0x100000

.get_memory_ok:
    mov [total_memory_bytes], edx
    xchg bx, bx

.get_memory_failure:
finish:
    sti ; open interrupt
    hlt ; halt cpu
    jmp finish

total_memory_bytes dd 0
ards_count  dw 0
ards_buffer times 600 db 0
```


## 参考资料

- <https://en.wikipedia.org/wiki/Memory_map>
- <https://wiki.osdev.org/Detecting_Memory_(x86)>