# X86汇编语言 - 实模式

[annotation]: <id> (c4d0635c-fcc9-410d-aedb-c481fb5dd5c7)
[annotation]: <status> (protect)
[annotation]: <create_time> (2021-02-04 14:31:43)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <topic> (x86 汇编语言)
[annotation]: <index> (2)
[annotation]: <url> (http://blog.ccyg.studio/article/c4d0635c-fcc9-410d-aedb-c481fb5dd5c7)


## 编写主引导扇区代码

```s
    base equ 0x7c00;
    video equ 0xb800;

    mov ax, 0x0003; clear screen
    int 0x10;

    mov ax,video  ;指向文本模式的显示缓冲区
    mov es,ax

    ;以下显示字符串"Label offset:"
    mov byte [es:0x00],'L'
    mov byte [es:0x01],0x07
    mov byte [es:0x02],'a'
    mov byte [es:0x03],0x07
    mov byte [es:0x04],'b'
    mov byte [es:0x05],0x07
    mov byte [es:0x06],'e'
    mov byte [es:0x07],0x07
    mov byte [es:0x08],'l'
    mov byte [es:0x09],0x07
    mov byte [es:0x0a],' '
    mov byte [es:0x0b],0x07
    mov byte [es:0x0c],"o"
    mov byte [es:0x0d],0x07
    mov byte [es:0x0e],'f'
    mov byte [es:0x0f],0x07
    mov byte [es:0x10],'f'
    mov byte [es:0x11],0x07
    mov byte [es:0x12],'s'
    mov byte [es:0x13],0x07
    mov byte [es:0x14],'e'
    mov byte [es:0x15],0x07
    mov byte [es:0x16],'t'
    mov byte [es:0x17],0x07
    mov byte [es:0x18],':'
    mov byte [es:0x19],0x07

    mov ax,number                 ;取得标号number的偏移地址
    mov bx,10


    ;设置数据段的基地址
    mov cx,cs
    mov ds,cx

    ;求个位上的数字
    mov dx,0
    div bx
    mov [0x7c00+number+0x00],dl   ;保存个位上的数字

    ;求十位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x01],dl   ;保存十位上的数字

    ;求百位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x02],dl   ;保存百位上的数字

    ;求千位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x03],dl   ;保存千位上的数字

    ;求万位上的数字 
    xor dx,dx
    div bx
    mov [0x7c00+number+0x04],dl   ;保存万位上的数字

    ;以下用十进制显示标号的偏移地址
    mov al,[0x7c00+number+0x04]
    add al,0x30
    mov [es:0x1a],al
    mov byte [es:0x1b],0x04
    
    mov al,[0x7c00+number+0x03]
    add al,0x30
    mov [es:0x1c],al
    mov byte [es:0x1d],0x04
    
    mov al,[0x7c00+number+0x02]
    add al,0x30
    mov [es:0x1e],al
    mov byte [es:0x1f],0x04

    mov al,[0x7c00+number+0x01]
    add al,0x30
    mov [es:0x20],al
    mov byte [es:0x21],0x04

    mov al,[0x7c00+number+0x00]
    add al,0x30
    mov [es:0x22],al
    mov byte [es:0x23],0x04
    
    mov byte [es:0x24],'D'
    mov byte [es:0x25],0x07
    
infi: jmp near infi                 ;无限循环

number db 0,0,0,0,0

times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

- 注释：必须以英文字母 ; 开始。

---

主引导扇区 (MBR Main Boot Sector) 数据有 512 字节，ROM-BIOS 程序将它加载到逻辑地址 0x0000:0x7c00 处，然后判断它是否有效。

一个有效的主引导扇区，最后两个字节应该是 0x55 和 0xAA，如果主引导扇区有效，则以一个段间转移指令 jmp 0x0000:0x7c00 跳到那里继续执行。

---

8086 可以访问 1MB 内存，其中：

- 0x00000-0x9ffff 属于常规内存，由内存条提供；
- 0xa0000-0xeffff 由特定的外围设备提供；
- 0xf0000-0xfffff 由主板上的一个芯片提供，ROM-BIOS；

其中 0xa0000-0xeffff 就包括显卡，由于历史原因，所有在个人计算机上使用的显卡，在加电自检后都会把自己初始化到 80x25 的文本模式，在这种模式下可以显示 25 行，每行 80 个字符，每屏总共 2000 个字符。

0xb8000 - 0xbffff 是留给显卡的，由显卡来提供。

---

字符串显示的格式：

- 高四位背景色：| K | R | G | B |
- 底四位前景色：| I | R | G | B |
- K=0：背景不闪烁
- K=1：背景闪烁
- I=1：浅色
- K=0：深色

---

- 不允许 `mov` 立即数到 段寄存器
- 关键字 `byte` 用来修饰目的操作数，指出本次传送是以字节的方式进行的。
- `mov` 指令的目的操作数不允许为立即数

```s
    mov byte [es:0xf9e],0x48
    mov byte [es:0xf9f],0x27

    ; mov al, 0x55aa ; warning 数据溢出 warning: byte data exceeds bounds
    ; mov ds, 0x6000; invalid combination of opcode and operands
    ; mov ds, al; invalid combination of opcode and operands
    ; mov [0x06], 0x55aa; error: operation size not specified
    mov ds, bx;
    mov ax, 0x02;
    mov word [0x0a], ax;
    mov es, cx;
    ; mov ax, bl; invalid combination of opcode and operands
    mov byte [0x00], 'C';
    ; mov [0x02], [0xf000]; invalid combination of opcode and operands
    mov ds, [0x03];
```

检测点 5.2 

```s
data1 db 0x55, 0xf000, 0x0f; warning: byte data exceeds bounds [-w+number-overflow]
data2 dw 0x38, 0x20, 0x55aa
```

---



下面改良一下字符串显示：

```s
[org 0x7c00]

    base equ 0x7c00;
    video equ 0xb800;
    jmp _start

print:
    cld
print_loop:
    lodsb
    or al, al
    jz print_done
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    jmp print_loop
print_done:
    ret

_start:
    mov ax, cs;
    mov ds, ax;
    mov ss, ax;
    mov sp, base;

    mov ax, 0x0003; clear screen
    int 0x10;

    mov ax,video  ;指向文本模式的显示缓冲区
    mov es,ax

    ; xchg bx, bx; magic break point

    ;以下显示字符串"Label offset:"
    mov si, message
    call print

    mov ax,number  ;取得标号number的偏移地址
    mov cx, 5;
number_loop:

    mov bx,10
    mov dx,0
    div bx ; (dx ax) / bx = 商(ax) 余数(dx)

    mov bx, dx;
    mov dl, [bx + string]

    mov bx, cx;
    mov [bx + number - 1], dl

    loop number_loop

    mov si, number
    call print
    
infi: jmp near infi                 ;无限循环

string: db '0123456789ABCDEF', 0

number db 0,0,0,0,0, 'D', 0
message db "Label offset:", 0; 字符串以 0 结尾
times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

---

- cld / std：用来操作方向标志位 DF(Direction Flag) DF = 0 / 1
- lodsb / lodsw 块装入指令，其具体操作是把 SI 指向的存储单元读入累加器，
  - LODSB就读入AL, SI += 1
  - LODSW就读入AX, SI += 2
- movsb：字符串传送指令，这条指令按字节传送数据。将 [DS:SI] 的一个字节移到 [ES:DI]。
- xchg 指令用于交换，后面两个寄存器，或内存中的值

---

Effective Address Mod R/M Value of ModR/M Byte (in Hexadecimal)


- [BX+SI]
- [BX+DI]
- [BP+SI]
- [BP+DI]
- [SI]
- [DI]
- [BX]
- [BX+SI]+disp8
- [BX+DI]+disp8
- [BP+SI]+disp8
- [BP+DI]+disp8
- [SI]+disp8
- [DI]+disp8
- [BP]+disp8
- [BX]+disp8
- [BX+SI]+disp16
- [BX+DI]+disp16
- [BP+SI]+disp16
- [BP+DI]+disp16
- [SI]+disp16
- [DI]+disp16
- [BP]+disp16
- [BX]+disp16

---

二进制数可以以如下方式输入，用下划线方便确定位数，最后以B结尾。

```s
mov ax, 0000_0001_0111_1111b
```

十六进制数可以以 0x 开始，或者以 H 结束，二者只能存在一种。

---

```s
xchg bx, bx
```

该指令无意义，在 bochs 中调试时表示断点 Magic Breakpoint，可以方便在 bochs 中调试，需要在 bochs 配置文件中，配置 magic breakpoint

    magic_break: enabled=1

另外，也可以打开 gui 调试功能，方便调试：

    display_library: x, options="gui_debug"

---

## 相同的功能，不同的代码

在NASM 里，`\` 是续行符， 当一行写不下时，可以在行尾使用这个符号，以表明下一行与当前行应该合并为一行。


---

- div 除法指令：
    - ax / bl = 商(al) 余数(ah) | 除数为 8 位
    - (dx ax) / bx = 商(ax) 余数(dx) | 除数为 16 位
- idiv 有符号除法指令
- cbw：字节到字的扩展指令
- cwd：字到双字符的扩展指令，可将AX内容扩展到DX
    - 若AX最高位=1，则执行后DX=FFFFH；
    - 若AX最高位=0，则执行后DX=0000H
- neg：求补指令

---

- 奇偶标志位 PF(Parity Flag)
- 进位标志位 CF(Carry Flag)
- 溢出标志位 OF(Overflow Flag)


### 条件转移指令

| 比较结果   | 英文                 | 指令 | 标志                |
| ---------- | -------------------- | ---- | ------------------- |
| 等于       | Equal                | je   | ZF = 1              |
| 不等于     | Not Equal            | jne  | ZF = 0              |
| 大于       | Greater              | jg   | ZF = 0 and SF = OF  |
| 大于等于   | Greater or Equal     | jge  | SF = 0F             |
| 不大于     | Not Greater          | jng  | ZF = 1 or SF != OF  |
| 不大于等于 | Not Greater or Equal | jnge | SF != OF            |
| 小于       | Less                 | jl   | SF != OF            |
| 小于等于   | Less or Equal        | jle  | ZF = 1 and SF != OF |
| 不小于     | Not Less             | jnl  | SF = OF             |
| 不小于等于 | Not Less or Equal    | jnle | ZF = 0 and SF = 0f  |
| 高于       | Above                | ja   | CF = 0 and ZF = 0   |
| 高于等于   | Above or Equal       | jae  | CF = 0              |
| 不高于     | Not Above            | jna  | CF = 1 or ZF = 1    |
| 不高于等于 | Not Above or Equal   | jnae | CF = 1              |
| 低于       | Below                | jb   | CF = 1              |
| 低于等于   | Below or Equal       | jbe  | CF = 1 or ZF = 1    |
| 不低于     | Not Below            | jnb  | CF = 0              |
| 不低于等于 | Not Below or Equal   | jnbe | CF = 0 and ZF = 0   |
| 偶         | Parity Even          | jpe  | PF = 1              |
| 奇         | Parity Odd           | jpo  | PF = 0              |

---

- \$ 代表当前行的汇编地址；
- \$\$ 代表当前汇编节（段）的起始汇编地址

---

## 比高斯更快的计算

```s
[org 0x7c00]

    base equ 0x7c00;
    video equ 0xb800;
    jmp _start

print:
    cld
print_loop:
    lodsb
    or al, al
    jz print_done
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    jmp print_loop
print_done:
    ret

_start:
    ; xchg bx, bx;

    mov ax, cs;
    mov ds, ax;
    mov ss, ax;
    mov sp, base;

    mov ax, 0x0003; clear screen
    int 0x10;

    mov ax,video  ;指向文本模式的显示缓冲区
    mov es,ax

    ;以下显示字符串 message
    mov si, message
    call print

    xor ax, ax
    mov cx, 100

calculate:
    add ax, cx
    loop calculate

    ; xchg bx, bx;

    xor cx, cx
split:
    mov bx, 10;
    mov dx, 0;
    div bx ; (dx ax) / bx = 商(ax) 余数(dx)

    add dl, 0x30;
    push dx

    ; xchg bx, bx;

    inc cx
    cmp ax, 0
    jne split

show_result:
    pop ax
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    loop show_result

infi: jmp near infi                 ;无限循环

message db "1+2+3+...+99+100=", 0; 字符串以 0 结尾
times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

---

### 基址寻址和变址寻址的区别

看起来基址寻址和变址寻址差不多，主要的区别在于使用者的不同。

基址寻址一般是操作系统使用的，使用基址寻址，这样，可以让所有的程序在编写的时候地址都从地址 0 开始，加载到内存中的时候，不同的程序加载到不同的内存空间，基址寄存器中存储内存的开始地址，程序中使用的地址加上基址寄存器中的值就得到了实际地址。

变址寻址一般是用户使用的，最典型的用途就是数组的索引。

---

## 硬盘和显卡的访问和控制

### 从硬盘的读取数据

boot.asm

```s
    boot_base       equ 0x7c00;
    video_base      equ 0xb800;
    app_lba_start   equ 100;

section mbr align=16 vstart=0x7c00
    start:
        ; xchg bx, bx;
        mov ax, 0x0003; clear screen
        int 0x10;

        mov ax, cs;
        mov ds, ax;
        mov ss, ax;
        mov sp, boot_base;

        mov ax,video_base  ;指向文本模式的显示缓冲区
        mov es,ax

        ; 令 ds, es 指向 user_base 代表的位置
        mov ax, [cs:user_base]
        mov dx, [cs:user_base + 0x02]
        mov bx, 16
        div bx
        mov ds, ax
        mov es, ax

        ; read first sector
        xor di, di
        mov si, app_lba_start
        xor bx, bx

        call read_harddisk

        mov dx, [2]
        mov ax, [0]
        mov bx, 512
        div bx
        cmp dx, 0

        ; xchg bx, bx;

        jnz @1
        dec ax
    @1:
        cmp ax, 0
        jz direct

        push ds
        mov cx, ax
    @2:
        mov ax, ds
        add ax, 0x20
        mov ds, ax

        xor bx, bx
        inc si
        call read_harddisk
        loop @2
        pop ds
    direct:

        mov dx, [0x08]
        mov ax, [0x06]
        call calc_segment_base

        ; xchg bx, bx;

        mov [0x06], ax

        mov cx, [0x0a]
        mov bx, 0x0c

    realloc:
        mov dx, [bx + 0x02]
        mov ax, [bx]
        call calc_segment_base

        ; xchg bx, bx;

        mov [bx], ax
        add bx, 4
        loop realloc

    jmp far [0x04]

read_harddisk:
    pusha

    mov dx, 0x1f2
    mov al, 1
    out dx, al ; 读取数量

    inc dx ; 0x1f3
    mov ax, si;
    out dx, al;  lba 地址 7-0

    inc dx; 0x1f4
    mov al, ah;
    out dx, al; lba address 15 - 8 

    inc dx; 0x1f5
    mov ax, di
    out dx, al ; lba address 23 - 16

    inc dx; 0x1f6
    mov al, 0xe0
    or al, ah; lba address 27-24
    out dx, al; 

    inc dx; 0x1f7
    mov al, 0x20; command read
    out dx, al

    ; xchg bx, bx;

.waits:
    in al, dx
    and al, 0x88
    cmp al, 0x08
    jnz .waits

    ; xchg bx, bx;
    mov cx, 256
    mov dx, 0x1f0
.readw:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .readw

    popa
    ret

calc_segment_base:
    ; calculate 
    ;计算16位段地址
    ;输入：DX:AX=32位物理地址
    ;返回：AX=16位段基地址

    push dx

    add ax, [cs:user_base]
    add dx, [cs:user_base + 2]
    shr ax, 4;
    ror dx, 4;
    and dx, 0xf000;
    or ax, dx;

    pop dx
    ret

print:
    cld
print_loop:
    lodsb
    or al, al
    jz print_done
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    jmp print_loop
print_done:
    ret

user_base dd 0x10000;
message db 'hello boot!!!', 0
times   510 - ($ - $$) db 0
        dw 0xaa55; db 0x55,0xaa
```

----

app.asm

```s

section header vstart=0;
    length          dd program_end
    entry           dw start; 偏移地址
                    dd section.code.start; 段地址
    table           dw (header_end - code_segment)/4 ; 段重定位表项个数
    code_segment    dd section.code.start;
    data_segment    dd section.data.start;
    stack_segment   dd section.stack.start;
header_end:

section code align=16 vstart=0


clear_screen:
    mov ax, 0x3
    int 0x10;
    ret

start:
    mov ax, [stack_segment]
    mov ss, ax
    mov sp, stack_end

    mov ax, [data_segment]
    mov ds, ax

    call clear_screen

    mov si, message
    call print

    jmp $

print:
    cld
print_loop:
    lodsb
    or al, al
    jz print_done
    mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
    int 0x10;
    jmp print_loop
print_done:
    ret

code_end:

section data align=16 vstart=0;
    message db 'hello world!!!', 0
data_end:

section stack align=16 vstart=0;
    ; resb 256
    times 256 db 0; 干掉 warning
stack_end:

section trail align=16;
program_end:
```

以上代码功能简单，

- 在 boot 中读取用户程序，并跳转到用户程序继续执行。
- 在 app 中，清屏，并且输出 `hello world!!!`

### nasm 数据类型

- db 定义字节变量 Define Byte
- dw 定义字变量 Define Word
- dd 定义双字变量 Define Double Word
- dq 定义四字变量 Define Quadra Word
- dt 定义十字节变量 Define Ten Byte

---

- resb 5 / 预留 5 个字节的空间
- push / 压栈指令 16 位
- pop / 弹栈指令 16 位
- pusha / 压栈 ax, cx, dx, bx, sp, bp, si, di
- popa / 与 pusha 相对的弹栈指令
- shr / 逻辑右移指令
- shl / 逻辑左移指令
- ror / 循环右移
- rol / 循环左移

---

从硬盘读写数据，最经典的方式是向硬盘控制器分别发送磁头号、柱面号和扇区号（扇区在某个柱面上的编号），这称为 CHS (Heads, Cylinder, Sector) 模式。这种方法最原始，最自然，也最容易理解。

实际上，在很多时候，我们并不关心扇区的物理位置，所以希望所有的扇区都能统一编址。这就是逻辑扇区，它把硬盘上所有可用的扇区都一一从 0 编号，而不管它位于哪个盘面，也不管它属于哪个柱面。这种方式就是 LBA(Logical Block Address) 模式。

最早的逻辑扇区编址方法是 LBA28, 使用 28 个比特来表示逻辑扇区号，从逻辑扇区 0x0000000 到 0xFFFFFFF, 共可以表示 $2^{28}=268435456$ 个扇区。每个扇区有 512 字节，所以 LBA28 可以管理128GB 的硬盘。

硬盘技术发展得非常快，最新的硬盘已经达到几百个吉字节的容量， LBA28 已经落后了。在这种情况下，业界又共同推出了 LBA48, 采用48 个比特来表示逻辑扇区号。如此一来，就可以管理 131072 TB 的硬盘容量了。

---

1. 设置要读取的扇区数量。这个数值要写入 `0x1f2` 端口。这是个8 位端口，因此每次只能读写 255 个扇区。

2. 第2 步，设置起始 LBA 扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28 位的扇区号太长，需要将其分成4 段， 分别写入端口 `0x1f3` `0x1f4` `0x1f5` 和 `0x1f6` 号端口。其中，`0x1f3` 号端口存放的是 0~7 位；`0x1f4` 号端口存放的是 8~15 位； `0x1f5` 号端口存放的是16~23 位，最后4 位在 `0x1f6` 号端口中。

3. 在现行的体系下，每个 `PATA/SATA` 接口允许挂接两块硬盘，分别是主盘 (Master) 和从盘 (Slave)。 `0x1f6` 端口的低 4 位用于存放逻辑扇区号的 24~27位，第 4 位用于指示硬盘号， 0 表示主盘，1 表示从盘。高3 位是 `111`，表示 LBA 模式。

4. 向端口 `0x1f7` 写入 `0x20`, 请求硬盘读。

5. 等待读写操作完成。端口 `0x1f7` 既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就开始工作了。在它内部操作期间，它将 `0x1f7` 端口的第 7 位置 1，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3 位置 1，意思是准备好了，请求主机发送或者接收数据。

6. `0x1f0` 是硬盘接口的数据端口，而且还是一个16 位端口。一旦硬盘控制器空闲， 且准备就绪，就可以连续从这个端口写入或者读取数据。读取的数据存放到由段寄存器 DS 指定的数据段，偏移地址由寄存器BX 指定。

7. `0x1f1` 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态。

---

### 过程（函数）调用指令

调用过程的指令是 `call`，8086 处理器支持四种调用方式。

1. 16 位相对近调用：

        call near proc_1
        call proc_1

2. 16 位间接绝对近调用：

        call cx
        call [0x3000]
        call [bx]
        call [bx + si + 0x02]

3. 16 位直接绝对远调用：

        call 0x2000:0x0030 

4. 16 位间接绝对远调用：

        call far [0x2000]
        call far [proc_1]
        call far [bx]
        call far [bx + si]

假如在数据段内声明了标号 proc_1 并初始化了两个字：

```s
proc_1 dw 0x0102, 0x2000
```

这两个字分别是某个过程的段地址和偏移地址。按处理器的要求，偏移地址在前，段地址在后。也就是说，`0x0102` 是偏移地址； `0x2000` 是段地址。

- ret / 近返回指令
- retf / 远返回指令

---

### 无条件转移指令

1. 相对短转移

    相对短转移的操作码为0xEB , 操作数是相对千目标位置的偏移量，仅 1 字节，是个有符号数。由于这个原因，该指令属于段内转移指令，而且只允许转移到距离当前指令 -128~127 字节的地方。相对短转移指令必须使用关键字 `short` 。

        jmp short infinite
        jmp short 0x2000

2. 16 位相对近转移

    由于这是一个 16 位的有符号数，故可以转移到距离当前指令-32768~32767 字节的地方。

        jmp near infinite
        jmp near 0x3000

3. 16 位间接绝对近转移

        jmp near bx
        jmp near cx

4. 16 位直接绝对远转移

        jmp 0x0000:0x7c00

5. 16 位间接绝对远转移(jmp far)

    远转移的目标地址可以通过访问内存来间接得到，这叫间接远转移，但是要使用关键字 `far`。假如在某程序的数据段内声明了标号 `jump_far`, 并在其后初始化了两个字：

        jump_far dw 0x33c0, 0xf000

    这不是两个普通的数值，它们分别是某个程序片断的偏移地址和段地址。为了转移到该程序片断上执行，可以在使用下面的转移指令：

        jmp far [jump_far]

    关键字 `far` 的作用是告诉编译器，该指令应当编译成一个远转移。处理器执行这条指令后，访问段寄存器 DS 所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS 和指令指针寄存器 IP 的内容。

----

### 显卡操作

获取光标位置：

```s
get_cursor:
    push dx

    mov dx, 0x3d4; 索引寄存器端口号
    mov al, 0x0e ; 光标寄存器 高八位
    out dx, al

    mov dx, 0x3d5; 数据端口号
    in al, dx; 获得高八位
    mov ah, al;

    mov dx, 0x3d4; 索引寄存器端口号
    mov al, 0x0f ; 光标寄存器 低八位
    out dx, al

    mov dx, 0x3d5; 数据端口号
    in al, dx; 获得低八位

    pop dx
    ret; 结果存在 ax 寄存器中
```

写入光标位置：

```s
set_cursor:
    ; 将 AX 寄存器中的光标位置 写入显卡

    push dx
    push bx
    push ax

    mov bx, ax;

    mov dx, 0x3d4; 索引寄存器端口号
    mov al, 0x0e ; 光标寄存器 高八位
    out dx, al

    mov dx, 0x3d5; 数据端口号
    mov al, bh; 获得高八位
    out dx, al; 写入高八位

    mov dx, 0x3d4; 索引寄存器端口号
    mov al, 0x0f ; 光标寄存器 低八位
    out dx, al

    mov dx, 0x3d5; 数据端口号
    mov al, bl; 获得低八位
    out dx, al; 写入低八位

    pop ax
    pop bx
    pop dx
    ret;
```

向上滚动若干行：

```s
scroll_screen:
    ; 向上滚动 Al 行;

    pusha
    push ds
    push es

    mov bx, 0xb800;
    mov ds, bx;
    mov es, bx;

    cld; 递增方向

    push ax;

    mov ah, 80 * 2;
    mul ah
    mov si, ax;
    mov di, 0x00

    mov cx, 80 * 24;
    rep movsw

    pop ax;
    mov ah, 80;
    mul ah; 计算字符数量

    ;清除新出现的行
    mov bx, 25 * 80 * 2;
    mov cx, ax;
    shl ax, 1;
    sub bx, ax;
    mov si, ax;

    .cls:
    sub si, 2
    mov word [es:bx + si], 0x0720; 0x07 默认颜色; 0x20 空格
    loop .cls

    pop es
    pop ds
    popa

    ret
```

硬盘写入，以下代码可以将正在执行的 app.bin 中的内容写入磁盘，不过下一次就启动不了了，应该是加载程序对 app 有修改吧。

```s
write_harddisk:
    pusha
    push ds

    mov bx, message
    mov byte [bx], 'K'

    mov si, 100
    xor di, di

    mov ax, 0x1000
    mov ds, ax

    mov dx, [2]
    mov ax, [0]
    mov bx, 512
    div bx
    cmp dx, 0
    je .direct
    inc ax
.direct:

    ; xchg bx, bx;
    mov cx, ax; 记录写入扇区数量

    mov dx, 0x1f2
    ; mov al, al
    out dx, al ; 写入数量

    inc dx ; 0x1f3
    mov ax, si;
    out dx, al;  lba 地址 7-0

    inc dx; 0x1f4
    mov al, ah;
    out dx, al; lba address 15 - 8 

    inc dx; 0x1f5
    mov ax, di
    out dx, al ; lba address 23 - 16

    inc dx; 0x1f6
    mov al, 0xe0
    or al, ah; lba address 27-24
    out dx, al; 

    inc dx; 0x1f7
    mov al, 0x30; command write
    out dx, al

    ; xchg bx, bx;

.waits:
    in al, dx
    and al, 0x88
    cmp al, 0x08
    jnz .waits

    ; xchg bx, bx;
    xor bx, bx

.write_sector:
    push cx

    mov cx, 256
    mov dx, 0x1f0

    .readw:
        mov ax, [bx]
        out dx, ax
        ; in ax, dx
        ; mov [bx], ax
        add bx, 2
        nop
        nop
        nop
        nop
        nop
        loop .readw

    pop cx
    loop .write_sector

    pop ds
    popa
    ret
```

----

## 中断和动态时钟显示

### 显示时间的代码

```s
section header vstart=0;
    length          dd program_end
    entry           dw start; 偏移地址
                    dd section.code.start; 段地址
    table           dw (header_end - code_segment)/4 ; 段重定位表项个数
    code_segment    dd section.code.start;
    data_segment    dd section.data.start;
    stack_segment   dd section.stack.start;
header_end:

section code align=16 vstart=0

start:
    ; xchg bx, bx

    mov ax, [stack_segment]
    mov ss, ax
    mov sp, stack_end

    mov ax, [data_segment]
    mov ds, ax

    call clear_screen

    mov si, message
    call print

    mov al, 0x70
    mov bl, 4
    mul bl
    mov bx, ax

    cli

    push es
    mov ax, 0x0000
    mov es, ax
    mov word [es:bx], int_0x70
    mov word [es:bx+2], cs
    pop es

    mov al,0x0b                        ;RTC寄存器B
    or al,0x80                         ;阻断NMI 
    out 0x70,al
    mov al,0x12                        ;设置寄存器B，禁止周期性中断，开放更 
    out 0x71,al                        ;新结束后中断，BCD码，24小时制 

    mov al,0x0c
    out 0x70,al
    in al,0x71                         ;读RTC寄存器C，复位未决的中断状态

    in al,0xa1                         ;读8259从片的IMR寄存器 
    and al,0xfe                        ;清除bit 0(此位连接RTC)
    out 0xa1,al                        ;写回此寄存器 

    sti                                ;重新开放中断 

    .idle:
        hlt                                ;使CPU进入低功耗状态，直到用中断唤醒
        jmp .idle

    jmp $

int_0x70:
        pusha
        push ds
        push es

        mov al,0x0a                         ;阻断NMI。当然，通常是不必要的
        or al,0x80                          
        out 0x70,al
        in al,0x71                          ;读寄存器A
        test al,0x80                        ;测试第7位UIP 
        jnz .return                         ;以上代码对于更新周期结束中断来说 
                                            ;是不必要的 

        xor al,al
        or al,0x80
        out 0x70,al
        in al,0x71                         ;读RTC当前时间(秒)
        call bcd_to_ascii
        mov [seconds], ax


        mov al, 2
        or al, 0x80
        out 0x70, al
        in al, 0x71                         ;读RTC当前时间(秒)
        call bcd_to_ascii
        mov [minutes], ax

        mov al, 4
        or al, 0x80
        out 0x70, al
        in al, 0x71                         ;读RTC当前时间(秒)
        call bcd_to_ascii
        mov [hours], ax

        mov al, 7
        or al, 0x80
        out 0x70, al
        in al, 0x71                         ;读RTC当前时间(日)
        call bcd_to_ascii
        mov [days], ax


        mov al, 8
        or al, 0x80
        out 0x70, al
        in al, 0x71                         ;读RTC当前时间(月)
        call bcd_to_ascii
        mov [months], ax

        mov al, 9
        or al, 0x80
        out 0x70, al
        in al, 0x71                         ;读RTC当前时间(年)
        call bcd_to_ascii
        mov [years], ax

        mov al,0x0c                         ;寄存器C的索引。且开放NMI 
        out 0x70,al
        in al,0x71                          ;读一下RTC的寄存器C，否则只发生一次中断
                                            ;此处不考虑闹钟和周期性中断的情况 
    ; 将 datetime 处的内容拷贝到 显存，以显示时间
        mov ax,0xb800
        mov es,ax

        mov si, datetime
        mov di, 12 * 160 + 30 * 2

    .showtime:
        mov ax, [si]
        cmp ax, 0
        je .return
        movsb
        inc di
        jmp .showtime

    .return:

        mov al,0x20                        ;中断结束命令EOI 
        out 0xa0,al                        ;向从片发送 
        out 0x20,al                        ;向主片发送 

        pop es
        pop ds
        popa

        iret


bcd_to_ascii:                            ;BCD码转ASCII
                                         ;输入：AL=bcd码
                                         ;输出：AX=ascii
                                         ; 采用小端方式，可以直接写入内存
                                         ; 设 AX = 0x0028

    mov ah, al                          ;分拆成两个数字  0x2828
    and al, 0xf0                        ;仅保留高4位 0x2820
    shr al, 4;                          ;0x2802
    add al, 0x30                        ;转换成ASCII 0x2832

    and ah, 0x0f                        ; 0x0832
    add ah, 0x30                        ; 0x3832; 结果

    ret

clear_screen:
    mov ax, 0x3
    int 0x10;
    ret

print:
    cld
    .print_loop:
        lodsb
        or al, al
        jz .print_done

        mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
        int 0x10;
        jmp .print_loop

    .print_done:
        ret

code_end:

section data align=16 vstart=0;
    message db 'Hello world!!!', 0
    datetime db '20'
    years db '21-'
    months db '02-'
    days db '02 '
    hours db '02:'
    minutes db '02:'
    seconds db '02', 0
data_end:

section stack align=16 vstart=0;
    ; resb 256
    times 0x100 db 0; 干掉 warning
stack_end:

section trail align=16;
    ending db 'program ending', 0
program_end:
```

以上代码可以在屏幕中央显示当前时间。

---

- test / 功能上和 and 指令一样，不过只用于更新 FLAG
- iret / 中断返回指令
- sti / 允许中断
- cli / 禁止中断

### 实模式下的中断向量表

在实模式下， 处理器要求将它们的入口点集中存放到内存中从物理地址 `0x0000` 开始，到 `0x003ff` 结束，共 `1KB` 的空间内， 这就是所谓的中断向量表 (Interrupt Vector Table, IVT)，中断向量表中保存了，中断程序的入口地址。

每个中断在中断向蜇表中占 2 个字，分别是中断处理程序的偏移地址和段地址。中断 0 的入口点位于物理地址 `0x00000` 处，也就是逻辑地址 `0x0000:0x0000` ; 中断 1 的入口点位于物理地址 `0x00004` 处，即逻辑地址 `0x0000:0x0004`; 其他中断以此类推，总之是按顺序的。

中断信号来自哪个引脚， 8259 芯片是最清楚的， 所以它会把对应的中断号告诉处理器，处理器拿着这个中断号，要顺序做以下几件事。

- 保护断点的现场。首先要将标志寄存器 FLAGS 压栈，然后消除它的 IF 位和 TF 位。TF 是陷阱标志。接着，再将当前的代码段寄存器 CS 和指令指针寄存器 IP 压栈。
- 执行中断处理程序。由于处理器已经拿到了中断号，它将该号码乘以4，就得到了该中断入口点在中断向童表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP 和 CS ，自然地，处理器就开始执行中断处理程序了。由于IF 标志被消除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用 sti 指令开放中断。
- 返回到断点接着执行。所有中断处理程序的最后一条指令必须是中断返回指令 iret。这将导致处理器依次从栈中弹出（恢复） IP 、CS 和 FLAGS 的原始内容，于是转到主程序接着执行。

---

### 实时时钟 (RTC Real Time Clock)

早期的 RTC 芯片是摩托罗拉(Motorola) MS 146818B, 现在直接集成在 ICH 内, 并且在信号上与其兼容。除了日期和时间的保存功能外， RTC 芯片也可以提供 **闹钟** 和 **周期性** 的中断功能。

日期和时间信息是保存在 CMOS RAM 中的，通常有 128 字节，而日期和时间信息只占了一小部分容量，其他空间则用于保存整机的配置信息，比如各种硬件的类型和工作参数、开机密码和辅助存储设备的启动顺序等。

CMOS RAM 的访问，需要通过两个端口来进行。0x70 或者0x74 是索引端口，用来指定CMOS RAM 内的单元； 0x71 或者0x75 是数据端口。

不得不说的是，从很早的时候开始，端口 0x70 的最高位(bit 7) 是控制 NMI 中断的开关。当它为 0 时，允许 NMI 中断到达处理器，为 1 时，则阻断所有的 NMI 信号，其他 7 个比特，即0~6位，则实际上用于指定 CMOS RAM 单元的索引号，这种规定直到现在也没有改变。

通常来说，在往端口 0x70 写入索引时，应当先读取 0x70 原先的内容，然后将它用于随后的写索引操作中。但是，该端口是只写的，不能用于读出。在早期的系统中，计算机的制造成本很高，为了最大化地利用硬件资源，导致出现很多稀奇古怪的做法，这就是一个活生生的例子。

为了解决这个问题，同时也为了兼容以前的老式硬件，ICH 芯片允许通过切换访问模式来临时取得那些只写寄存器的内容，但这涉及更高层次的知识，已经超出了当前的话题范畴。现在，我们只想把问题搞得简单些，这么说吧，NMI 中断应当始终是允许的，在访问RTC 时，我们直接关闭 NMI ，访问结束后，再打开NMI, 而不管它以前到底是什么样子。

---

### BIOS 中断

```s
section header vstart=0;
    length          dd program_end
    entry           dw start; 偏移地址
                    dd section.code.start; 段地址
    table           dw (header_end - code_segment)/4 ; 段重定位表项个数
    code_segment    dd section.code.start;
    data_segment    dd section.data.start;
    stack_segment   dd section.stack.start;
header_end:

section code align=16 vstart=0

start:
    ; xchg bx, bx

    mov ax, [stack_segment]
    mov ss, ax
    mov sp, stack_end

    mov ax, [data_segment]
    mov ds, ax

    call clear_screen

    mov si, message
    call print

    .idle:
        call get_key
        ; hlt                                ;使CPU进入低功耗状态，直到用中断唤醒
        jmp .idle

    jmp $

clear_screen:
    mov ax, 0x3
    int 0x10;
    ret

get_key:
    mov ah, 0x00
    int 0x16

    mov ah, 0x0e
    int 0x10;

    ret

print:
    cld
    .print_loop:
        lodsb
        or al, al
        jz .print_done

        mov ah, 0x0e ; 0000 黑色背景 1110 浅灰色，默认颜色
        int 0x10;
        jmp .print_loop

    .print_done:
        ret

code_end:

section data align=16 vstart=0;
    message db 'Hello world!!!', 0
data_end:

section stack align=16 vstart=0;
    ; resb 256
    times 0x100 db 0; 干掉 warning
stack_end:

section trail align=16;
    ending db 'program ending', 0
program_end:
```

上面的代码，可以将键盘输入显示到屏幕上。

---

## 参考资料

- [李忠 - X86汇编语言](https://book.douban.com/subject/20492528/)
- <https://www.nasm.us/xdoc/2.11.06/html/nasmdoc3.html#section-3.2.2>
- <https://wiki.osdev.org/ATA_PIO_Mode>