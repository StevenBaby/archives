# X86 汇编语言 - 内存分页机制

[annotation]: <id> (c67d8f71-3a22-4f18-8dd1-0f2b0cc76ec7)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-03-12 15:57:16)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (汇编语言)
[annotation]: <comments> (true)
[annotation]: <topic> (x86汇编语言)
[annotation]: <index> (10)
[annotation]: <url> (http://blog.ccyg.studio/article/c67d8f71-3a22-4f18-8dd1-0f2b0cc76ec7)


从 80386 处理器开始，引入了分页机制。

## 简单的分页模型

页的最小单位是 4KB , 也就是 4096 字节，用十六进制数表示就是 `0x1000`。因此，第 1 个页的物理地址是 `0x00000000`, 第2 个页的物理地址是 `0x00001000`，...，最后一个页的物理地址是 `0xFFFF0000`。这样，可以将 4GB 内存划分为 1048576 (`0x100000`) 个页。很显然， 页的物理地址，其低 12 位始终为全零。

因为有 1048576 个页，所以转换表也有 1048576 项。这是个一维表格，每个表项占 4 字节，内容为页的物理地址。

因为页的尺寸是 4KB, 故，线性地址的低 12 位可用于访问页内偏移，高 20 位可用于指定一个物理页。因此，把线性地址的高 20 位当成索引，乘以 4 作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。

在页式内存管理中，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。很显然，也很重要的结论是，线性地址，包括线性地址空间，和页面分配机制没有关系。

在分页模式下，操作系统可以创建一个为所有任务共用的 4GB 虚拟内存空间，也可以为每一个任务创建独立的 4GB 虚拟内存空间，这都是可行的。


为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务
准备一张页映射表。因为任务的虚拟地址空间为4GB, 可以分出 1048576 个页，所以，映射表需要 1048576 个表项，用于存放页的物理地址。又因为每个表项占 4 字节，所以，映射表的总大小为4MB。

没错，这张表很大，占用相当一部分内存空间，考虑到在实践中，没有哪个任务会其的用到所有表项，充其量只是很小一部分，这就很浪费了。当然，你可能会建议先划出一小块内存给它，然后，根据需要再动态扩展。的确，这是可行的。但是，因为一个特殊的原因，这张表在实际使用的时候，它的前半部分和后半部分会被同时用到。具体是什么原因，马上就要讲到，也正是因为这个尚未说明的原因，这张表从一开始就必须完全定义，而且不可避免地要占用 4MB 内存空间。为了解决这个问题，同时又不会浪费宝贵的内存空间，处理器设计了层次化的分页结构。

分页结构层次化的主要手段是不采用单一的映射表，取而代之的是页目录表和页表，首先，因为 4GB 的虚拟内存空间对应着 1048576 个 4KB 的页，可以随机地抽取这些页，将它们组织在 1024 个页表内，每个页表可以容纳 1024 个页。页表内的每个项目叫做页表项，占 4 字节，存放的是页的物理地址，故每个页表的大小是 4KB, 正好是一个标准页的长度。

页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通页的不同之处仅仅在于功能不一样。

## 地址变换的具体过程

对于 Intel 处理器来说，有关分页，最简单和最基本的机制就是这些：CR3 寄存器给出了页目录的物理基地址；页目录给出了所有页表的物理地址，而每个页表给出了它所包含的页的物理地址。

CPU 在不打开分页机制的情况下，是按照默认的分段方式进行的，段基址和段内偏移地址经过段部件处理后所输出的线性地址， CPU 就认为是物理地址。如果打开了分页机制，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址。CPU 必须要拿到物理地址才行，此虚拟地址对应的物理地址需要在页表中查找，这项查找工作是由页部件自动完成的。

假设段部件会输出线性地址 `0x00801050`。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了分页机制，所以，这是一个虚拟地址，要经过页部件的转换，才能得到物理地址。

处理器的页部件专门负责线性地址到物理地址的转换工作。它首先将段部件送来的 32 位线性地址截成 3 段，分别是高 10 位、中间的 10 位和低 12 位。高 10 位是页目录的索引，中间 10 位是页表的索引，低 12 位则作为页内偏移来用。

当前任务页目录的物理地址在处理器的 CR3 寄存器中，假设它的内容为 `0x00005000`。段管理部件输出的线性地址是 `0x00801050`, 其二进制的形式为 `0000 0000 1000 0000 0001 0000 0101 0000`。高 10 `位为0000000010`, 也就是十六进制的 `0x002`, 它是页目录表内的索引， 处理器将它乘以4（因为每个目录项为 4 字节），作为偏移量访问页目录。最终，处理器从物理地址 `0x00005008` 处取得页表的物理地址 `0x08001000`。

线性地址的中间 10 位为二进制的 `0000000001`, 即 0x001, 处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以 4 , 作为偏移量访问页表。最终，处理器又从物理地址 `0x08001004` 处取得页的物理地址， 这就是我们一直努力寻找的那个页。

页的物理地址是 `0x0000C000`, 而线性地址的低 12 位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址 `0x0000C050`, 这就是线性地址 `0x00801050` 所对应的物理地址，要访问的数据就在这里。

注意，这种变换不是无缘无故的，而是事先安排好的。当任务加载时，操作系统先创建虚拟的段，并根据段地址的高 20 位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候， 才能以相反的顺序进行地址变换，并找到正确的数据。

## 总结

- 由于分页 $4G=2^{32}B$ 可以分成 $2^{32} \div 2^{12} = 2^{20} = 1048576$ 个 $2^{12}B = 4KB$ 的页
- 要保存这些分页的地址信息，一个地址是 $4B$，那么就需要一个 `int32[1048576]` 的数组来存储，这个数组总共需要 $4MB$ 的内存空间
- 这 $4MB$ 存储在 $1024$ 个页中，那么存储这个数组的这些页就是 **页表**；
- 可以将这 $1024$ 存储数组的页，汇总到一个页中，相当于数组 `int32[1024]`，而汇总的这个页就是**页目录**；
- 如果没有后面的这个汇总，那么每个程序就必须有 $4MB$ **连续** 的内存空间来存储分页信息，而并不是每个程序都要用到所有的页。所以实际上会有大量的数据是没用的。  
- 有了汇总，汇总相当于对后面 $1024$ 个页的注册信息，如果没有用到就可以不用注册，这样的话，最少就只用到两个页，一个存储页目录，一个存储页表，剩下的 $1023$ 个页表由于没有用到，所以就不用存储了，这样就把 $4MB$ 的信息压缩到了 $8KB$ 中，不过之所以能压缩，是由于 $4MB$ 中有大两没用的信息。
- 另外分页信息存储了 $4B$ 的内容，页的位置是 $4KB$ 对齐的，也就是说任何一个页的起始地址的最后 $12$ 位都是 $0$，这样这些信息就成了冗余信息，实际上分页只用到了前面的 $20$ 位，这样 `Intel` 用后面的 $12$ 位标记了一些信息，比如这个页在不在内存中，这个页的权限等等。



## 分页代码

```s
setup_page:

    ; xchg bx, bx
    mov ecx, PAGE_SIZE * 3
    mov esi, 0

.reset_page:
    mov byte [PAGE_DIR_TABLE_ADDR + esi], 0
    inc esi
    loop .reset_page

    ; xchg bx, bx

.create_pde: ; PDE 页目录表，只有一个

    ; 0000_0000_00b 对应的页表
    ; 设置基础页目录，使前 1M 内存映射到自己
    ; 使虚拟地址 3G 后的内存也映射到 1M 内存中

    mov eax, PAGE_DIR_TABLE_ADDR + PAGE_SIZE;
    or eax, PAGE_ATTRIBUTE
    mov [PAGE_DIR_TABLE_ADDR + 0], eax
    mov [PAGE_DIR_TABLE_ADDR + (0x300 * 4)], eax; 第 0x300 个目录项，每个目录项占四个字节

    ; 使最高的目录指向自己，方便修改，这将浪费一个表项，使虚拟地址最高的 4M 无法访问，
    ; 不过也没关系，一般程序不会用到那么高的地址

    mov eax, PAGE_DIR_TABLE_ADDR
    or eax, PAGE_ATTRIBUTE
    mov [PAGE_DIR_TABLE_ADDR + (0x3ff * 4)], eax;
    
    ; 低端 1M 内存 / 4KB = 256

    ; xchg bx, bx

    mov ebx, PAGE_DIR_TABLE_ADDR + PAGE_SIZE;
    mov ecx, (BASE_ADDRESS_LIMIT / PAGE_SIZE)  ; 256
    mov esi, 0
    mov edx, PAGE_ATTRIBUTE


.create_pte:
    mov [ebx + esi * 4], edx
    add edx, PAGE_SIZE
    inc esi
    loop .create_pte

    ; 设置 CR3 寄存器
    mov eax, PAGE_DIR_TABLE_ADDR
    mov cr3, eax

    ; 打开分页功能 打开cr0的pg位(第31位)
    mov eax, cr0
    or eax, 10000000_00000000_00000000_00000000b
    mov cr0, eax

    ret
```


## 参考资料

- [李忠 - 《X86汇编语言》](https://book.douban.com/subject/26745156/)
- [郑刚 - 《操作系统真象还原》](https://book.douban.com/subject/20492528/)
- <https://en.wikipedia.org/wiki/Memory_map>
- <https://wiki.osdev.org/Detecting_Memory_(x86)>