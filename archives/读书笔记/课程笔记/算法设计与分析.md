# 算法设计与分析

[annotation]: [id] (6a208dc4-6d3b-4ce2-bd82-d6856eab1ff3)
[annotation]: [status] (public)
[annotation]: [create_time] (2021-09-07 10:21:33)
[annotation]: [category] (读书笔记)
[annotation]: [tags] (研究生课程|算法)
[annotation]: [comments] (true)
[annotation]: [url] (http://blog.ccyg.studio/article/6a208dc4-6d3b-4ce2-bd82-d6856eab1ff3)

## 考核方式

- 作业 20%
- 上课 10%
- 笔试 70%

## 绪论

- 人机大战 / 2016 年 3 月，阿尔法狗战胜李世石

* 算法是计算机软件的灵魂
* 算法是计算机科学的核心
* 国家科技综合实力的体现

---

算法设计的目的：

- 好奇心的需要：人们热衷于寻找不同的方法解决各种各样的问题
- 研究的需要：
    - 性质不同：稳定/不稳定
    - 性能不同：速度，空间
    - 适用场合不同
- 应用的需要：没有万能的算法适用于所有的应用


----

学习算法的收获：

* 积累经验
* 训练编程
* 训练思维
    * 严谨、科学的逻辑推理能力
    * 培养计算机系统观
    * 计算机求解问题的能力

----

### 算法的定义和特性

算法是解一 **确定类问题** 的任意一种 **特殊的方法**

算法是一组 **有穷的规则**，它规定了解决某一**特定类型问题**的一系列运算

- 算法：
    - 数值计算：求解数值问题，插值计算
    - 非数值计算

算法早于计算机出现

--- 

算法的五个重要特性：：

- 确定性
- 可行性 （能行性）<- 我觉得这个词好别扭
- 输入：可能没有
- 输出：至少有一个
- 有穷性

---

课程的主要任务：

- 设计算法
- 表示算法
- 确认算法
- 分析算法
- 测试程序

![](./images/algorithm_01.drawio.svg)

[感觉这个流程图画了个寂寞]

---

### 复杂性分析初步

计算的约定

算法的执行时间：

$$T=\sum F_i \cdot t_i$$

其中：

- $F_i$ 是运算 $i$ 执行的 **频率计数**
- $t_i$ 是运算 $i$ 执行的时间

---

- 时间囿界于常数的运算
    - 执行时间是固定量，与操作数无关
- 时间非囿界于常数的运算
    - 运行时间是其包含的所有基本运算的执行时间之和
    - 可将其分解为若干时间囿界于常数的运算

![](./images/algorithm_02.jpg)

然而，我没有找到 **囿界** 这个词的定义，但是从字面意思理解，应该是和某常量差不多的意思；

----

在不同的数据配置上，同一算法有不同的执行情况，可分为 **最好**、**最坏** 和 **平均** 等情况讨论；[信息会影响决策]

---

算法的分析步骤：

- 事前分析：
    - 时间分析
    - 空间分析
- 事后分析：
    - 直接与物理实现有关
    - 分析手段：作时空性能分布图

算法分析主要集中于 **与物理实现无关** 的 **事前分析** 阶段，也就是获取算法的时间复杂度和空间复杂度。

---

一般更关心算法的 **最坏时间** 执行时间，是算法渐进执行时间的上界，用 $O$ 来表示；

下界用 $\Omega$ 表示

如果上界和下届相等 则用 $\Theta$ 表示

> 渐进时间复杂度，我觉得是求 $n \to \infty$ 时，算法的极限，**渐进** 就是 **趋于无穷** 的这个过程；

### 递归

程序调用自身的编程技巧称为递归(recursion)，包括直接或简介调用自身。

它通常把一个 **大型复杂的问题** 层层 **转化为** 一个与原问题 **相似的** **规模较小的问题** 来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量；

递归调用的堆栈操作的问题，主要有两方面：

- 一方面，任何函数调用时需要将指令指针入栈，也就是函数执行完成之后，需要执行的下一条指令的地址，这样函数返回时就可以通过这个地址找到相应的位置了。
- 另一方面，递归函数中如果有局部变量，这些局部变量也是需要存储在栈中的，所以如果递归过多可能会造成堆栈溢出；

于是，一般情况下，递归会比非递归算法更加低效。

---

递归算法设计：

定义：**树** 是一个或多个结点的有限集合，它使得：

- 有一个指定为根(root)的结点
- 剩余结点被划分成 $m \geqslant 0$ 个不相交的集合：$T_1,\cdots, T_m$, 这些集合的每一个又都是一棵树，并称 $T_1,\cdots, T_m$ 为根的子树

定义：**二叉树**（二元树）是结点的有限集合：

- 它或者为空
- 或者由一个根和两棵称为左子树和右子树的不相交二叉树所组成

```cpp
int P(参数表)
{
    if(递归出口)
    {
        简单操作;
    }
    else
    {
        一种简单操作;
        P(递归参数);
        另一种简单操作;
    }
}
```

相关问题：

- 阶乘
- 斐波那契数列  
    $F_0 = F_1 = 1; F_i = F_{i - 1} + F_{i-2} \ (i > 1)$
- 最大公因数 / 辗转相除法
- 汉诺塔问题

## 参考资料

- [算法导论](https://book.douban.com/subject/20432061/)
- [计算机算法基础](https://book.douban.com/subject/1815995/)  
    这本书只看豆瓣评价，感觉好辣鸡啊！！！
