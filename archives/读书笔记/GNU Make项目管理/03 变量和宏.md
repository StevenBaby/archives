# GNU Make 项目管理 第三章 变量和宏

[annotation]: <id> (9d9e86bc-196b-4e14-a433-56b7d5a2afeb)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 19:13:11)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (3)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/9d9e86bc-196b-4e14-a433-56b7d5a2afeb)

我们知道 makefile 变量已经有一段时间了，我们看到了许多在内置规则和用户定义规则中使用它们的例子。但我们看到的例子只是触及了表面。变量和宏会变得更加复杂，并赋予 GNU make 强大的功能。

在我们继续之前，重要的是要理解 make 是两种语言的结合体。第一种语言描述由目标和依赖组成的依赖关系图。(这门语言在第二章中介绍过) 第二语言是执行文本替换的宏语言。您可能熟悉的其他语言的宏，例如，C 预处理器、m4、TEX 和 宏汇编器。与其他宏语言一样，make 允许您为更长的字符序列定义一个简写术语，并在程序中使用这个简写。宏处理器会识别你的简写术语，并用它们的展开形式替换它们。尽管把 makefile 变量看作传统编程语言变量很容易，但宏 “变量” 和 “传统” 变量是有区别的。宏变量 被 “就地” 展开以产生一个字符串，然后可以进一步展开。随着我们的深入，这种区别将变得更加清楚。

变量名可以包含几乎任何字符，包括大多数标点符号。即使是空格也是允许的，但如果你想保持理智，就应该避免使用空格。变量名中不允许使用的字符只有 `:`, `#` 和 `=`。

变量是区分大小写的，所以 `cc` 和 `CC` 指向不同的变量。要获取变量的值，请将变量名括在 `$()` 中。作为一种特殊情况，单字母变量名可以省略圆括号，直接使用$letter。这就是为什么自动变量可以不用圆括号来写。一般来说，应该使用括号形式，而避免使用单个字母的变量名。

变量也可以像在 `${CC}` 中那样使用花括号展开，你经常会看到这种形式，特别是在旧的 makefile 中。使用其中一种并没有什么优势，所以选择一种并坚持使用。有些人在变量引用时使用花括号，在函数调用时使用圆括号，类似于 shell 使用它们的方式。大多数现代的 makefile 都使用圆括号，这也是我们在整本书中都会用到的。

按照惯例，用户希望在命令行或环境中自定义的常量都是全大写的。单词之间用下划线分隔。仅出现在 makefile 中的变量都是小写的，单词之间用下划线分隔。最后，在本书中，用户定义的函数在变量和宏中使用小写字母，中间用破折号隔开。其他命名约定将在它们发生的地方进行解释。(下面的示例使用了我们还没有讨论的特性。我用它们来说明变量命名约定，现在不要太关心右边的内容。)

```makefile
# Some simple constants.
CC := gcc
MKDIR := mkdir -p

# Internal variables.
sources = *.c
objects = $(subst .c,.o,$(sources))

# A function or two.
maybe-make-dir = $(if $(wildcard $1),,$(MKDIR) $1)
assert-not-null = $(if $1,,$(error Illegal null value.))
```

变量的值由赋值符号右侧的所有单词组成，并去掉前面的空格。不去掉后面的空格。这有时会造成麻烦，例如，如果变量中包含末尾的空格，然后使用在命令脚本中:

```makefile
LIBRARY = libio.a # LIBRARY has a trailing space.
missing_file:
    touch $(LIBRARY)
    ls -l | grep '$(LIBRARY)'
```

变量赋值包含一个尾随空格，注释使其更加明显(但尾随空格也可以不带尾随注释)。当这个 makefile 运行时，我们得到:

```text
$ make
touch libio.a
ls -l | grep 'libio.a '
make: *** [missing_file] Error 1
```

糟糕，grep 搜索字符串还包括尾随空格，无法在 ls 的输出中找到该文件。稍后我们将更详细地讨论空格问题。现在，让我们更详细地继续研究变量。

## 变量是用来干嘛的

一般来说，使用变量来表示外部程序是一个好主意。这允许 makefile 的用户更容易地使 makefile 适应他们特定的环境。

例如，在一个系统上通常有几个版本的 awk: awk、nawk、gawk。通过创建一个变量 AWK 来保存 AWK 程序的名称，可以使 makefile 的其他用户更容易使用它。另外，如果您的环境中存在安全问题，一个好的做法是使用绝对路径访问外部程序，以避免用户路径出现问题。绝对路径还可以减少出现问题的可能性，如果系统程序的木马版本已经安装在用户路径的某个地方。当然，绝对路径也会降低 makefile 对其他系统的可移植性。这得看你的需求。

虽然变量的第一次使用应该是用来保存简单常量，但它们也可以存储用户定义的命令序列，比如:

```makefile
DF = df
AWK = awk
free-space := $(DF) . | $(AWK) 'NR = = 2 { print $$4 }'
```

用于获取空闲的磁盘空间。我们将会看到，变量被用于这两个目的外，还能做别的。

## 变量类型

在 make 中有两种类型的变量，简单展开变量和递归展开变量。使用 := 赋值操作符定义一个简单展开的变量(或简单变量):

```makefile
MAKE_DEPEND := $(CC) -M
```

它被称为“简单展开”，因为它的右侧在读取 makefile 中的行后立即展开。右侧的任何 make 变量引用都将展开，并将结果文本保存为变量的值。这种行为与大多数编程和脚本语言相同。例如，这个变量的正常展开结果是:

```makefile
gcc -M
```

然而，如果上面的 `CC` 还没有赋值，那么上面赋值的值将是:

```makefile
<space>-M
```

`$(CC)` 被扩展为它的值(不包含字符)，并收缩为空。变量没有定义不是错误。事实上，这非常有用。大多数隐式命令包括未定义的变量，这些变量充当用户自定义的占位符。如果用户没有自定义一个变量，它将压缩为空。现在注意前导空格。右手边首先由 make 进行解析，生成字符串 `$(CC) -M`。当变量引用被压缩为空时，make 不会重新扫描值并修剪空白。空白部分保持完整。

第二种类型的变量称为递归扩展变量。递归展开变量(或递归变量)使用 `=` 赋值操作符定义:

```makefile
MAKE_DEPEND = $(CC) -M
```

它被称为“递归展开”，因为它的右边只是被 make 吃掉，并存储为变量的值，而不需要求值或以任何方式展开。相反，在使用变量时执行展开。对于这个变量，一个更好的术语可能是惰性展开变量，因为计算被推迟到实际使用它的时候。这种扩展风格的一个令人惊讶的效果是，作业可以“无序”执行

```makefile
MAKE_DEPEND = $(CC) -M
...

# Some time later
CC = gcc
```

这里，命令脚本中的 `MAKE_DEPEND` 的值是 `gcc -M`，即使在分配 `MAKE_DEPEND` 时没有定义 `CC`。

实际上，递归变量并不是真正的惰性赋值(至少不是普通的惰性赋值)。每次使用递归变量时，都会对其右侧重新求值。对于根据简单常量定义的变量，如上面的 `MAKE_DEPEND`，这种区别是没有意义的，因为右边的所有变量也是简单常量。但是想象一下，如果右手边的一个变量表示程序的执行，比如 date。每次递归变量展开时，都会执行日期程序，并且每个变量展开都会有不同的值(假设它们至少间隔一秒执行)。有时这是非常有用的。在其他时候，它是非常烦人的!

### 其他赋值类型

在前面的例子中，我们已经看到了两种类型的赋值 `=` 用于创建递归变量，`:=` 用于创建简单变量。make 还提供了另外两个赋值操作符。

`?=` 操作符称为条件变量赋值操作符。这很复杂，我们称之为条件赋值。只有当变量还没有值时，该操作符才会执行所请求的变量赋值。

```makefile
# Put all generated files in the directory $(PROJECT_DIR)/out.
OUTPUT_DIR ?= $(PROJECT_DIR)/out
```

这里，我们设置了输出目录变量 `OUTPUT_DIR`，只有在前面没有设置它的情况下才设置它。这个特性可以很好地与环境变量交互。我们将在本章后面的“变量从何而来”一节讨论这个问题。

另一个赋值操作符 `+=` 通常被称为追加。顾名思义，这个操作符将文本追加到一个变量。这看起来似乎没什么特别的，但在使用递归变量时，这是一个重要的特性。具体来说，赋值右边的值被附加到变量上，而不改变变量中的原始值。“有什么大不了的，这不就是 `append` 一直在做的吗?” 我听到你说。是的，但等等，这有点棘手。

添加一个简单的变量是非常明显的。`+=` 操作符可以这样实现:

```makefile
simple := $(simple) new stuff
```

由于简单变量中的值已经进行了展开，make 可以展开 `$(simple)`、追加文本并完成赋值。但是递归变量带来了一个问题。不允许像下面这样的实现。

```makefile
recursive = $(recursive) new stuff
```

这是一个错误，因为 make 没有好的方法来处理它。如果 make 存储了递归的当前定义加上新东西，make 就不能在运行时再次展开它。此外，尝试展开包含对自身引用的递归变量会产生无限循环。

```text
$ make
makefile:2: *** Recursive variable `recursive' references itself (eventually). Stop.
```

因此，实现 `+=` 是为了允许将文本添加到递归变量中，并执行正确的操作。这个操作符对于将值递增地收集到变量中特别有用。

## 宏

## 什么时候展开变量

## 目标和特殊模式变量

## 变量来自何处

## 条件和包含处理

## 标准 make 变量

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)
