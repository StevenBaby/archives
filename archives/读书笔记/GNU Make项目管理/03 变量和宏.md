# GNU Make 项目管理 第三章 变量和宏

[annotation]: [id] (9d9e86bc-196b-4e14-a433-56b7d5a2afeb)
[annotation]: [status] (public)
[annotation]: [create_time] (2021-04-18 19:13:11)
[annotation]: [category] (读书笔记)
[annotation]: [tags] (Make|Makefile|GNU)
[annotation]: [topic] (GNU Make 项目管理)
[annotation]: [index> (3)
[annotation]: [comments] (true)
[annotation]: [url] (http://blog.ccyg.studio/article/9d9e86bc-196b-4e14-a433-56b7d5a2afeb)

我们知道 makefile 变量已经有一段时间了，我们看到了许多在内置规则和用户定义规则中使用它们的例子。但我们看到的例子只是触及了表面。变量和宏会变得更加复杂，并赋予 GNU make 强大的功能。

在我们继续之前，重要的是要理解 make 是两种语言的结合体。第一种语言描述由目标和依赖组成的依赖关系图。(这门语言在第二章中介绍过) 第二语言是执行文本替换的宏语言。您可能熟悉的其他语言的宏，例如，C 预处理器、m4、TEX 和 宏汇编器。与其他宏语言一样，make 允许您为更长的字符序列定义一个简写术语，并在程序中使用这个简写。宏处理器会识别你的简写术语，并用它们的展开形式替换它们。尽管把 makefile 变量看作传统编程语言变量很容易，但宏 “变量” 和 “传统” 变量是有区别的。宏变量 被 “就地” 展开以产生一个字符串，然后可以进一步展开。随着我们的深入，这种区别将变得更加清楚。

变量名可以包含几乎任何字符，包括大多数标点符号。即使是空格也是允许的，但如果你想保持理智，就应该避免使用空格。变量名中不允许使用的字符只有 `:`, `#` 和 `=`。

变量是区分大小写的，所以 `cc` 和 `CC` 指向不同的变量。要获取变量的值，请将变量名括在 `$()` 中。作为一种特殊情况，单字母变量名可以省略圆括号，直接使用$letter。这就是为什么自动变量可以不用圆括号来写。一般来说，应该使用括号形式，而避免使用单个字母的变量名。

变量也可以像在 `${CC}` 中那样使用花括号展开，你经常会看到这种形式，特别是在旧的 makefile 中。使用其中一种并没有什么优势，所以选择一种并坚持使用。有些人在变量引用时使用花括号，在函数调用时使用圆括号，类似于 shell 使用它们的方式。大多数现代的 makefile 都使用圆括号，这也是我们在整本书中都会用到的。

按照惯例，用户希望在命令行或环境中自定义的常量都是全大写的。单词之间用下划线分隔。仅出现在 makefile 中的变量都是小写的，单词之间用下划线分隔。最后，在本书中，用户定义的函数在变量和宏中使用小写字母，中间用破折号隔开。其他命名约定将在它们发生的地方进行解释。(下面的示例使用了我们还没有讨论的特性。我用它们来说明变量命名约定，现在不要太关心右边的内容。)

```makefile
# Some simple constants.
CC := gcc
MKDIR := mkdir -p

# Internal variables.
sources = *.c
objects = $(subst .c,.o,$(sources))

# A function or two.
maybe-make-dir = $(if $(wildcard $1),,$(MKDIR) $1)
assert-not-null = $(if $1,,$(error Illegal null value.))
```

变量的值由赋值符号右侧的所有单词组成，并去掉前面的空格。不去掉后面的空格。这有时会造成麻烦，例如，如果变量中包含末尾的空格，然后使用在命令脚本中:

```makefile
LIBRARY = libio.a # LIBRARY has a trailing space.
missing_file:
    touch $(LIBRARY)
    ls -l | grep '$(LIBRARY)'
```

变量赋值包含一个尾随空格，注释使其更加明显(但尾随空格也可以不带尾随注释)。当这个 makefile 运行时，我们得到:

```text
$ make
touch libio.a
ls -l | grep 'libio.a '
make: *** [missing_file] Error 1
```

糟糕，grep 搜索字符串还包括尾随空格，无法在 ls 的输出中找到该文件。稍后我们将更详细地讨论空格问题。现在，让我们更详细地继续研究变量。

## 变量是用来干嘛的

一般来说，使用变量来表示外部程序是一个好主意。这允许 makefile 的用户更容易地使 makefile 适应他们特定的环境。

例如，在一个系统上通常有几个版本的 awk: awk、nawk、gawk。通过创建一个变量 AWK 来保存 AWK 程序的名称，可以使 makefile 的其他用户更容易使用它。另外，如果您的环境中存在安全问题，一个好的做法是使用绝对路径访问外部程序，以避免用户路径出现问题。绝对路径还可以减少出现问题的可能性，如果系统程序的木马版本已经安装在用户路径的某个地方。当然，绝对路径也会降低 makefile 对其他系统的可移植性。这得看你的需求。

虽然变量的第一次使用应该是用来保存简单常量，但它们也可以存储用户定义的命令序列，比如:

```makefile
DF = df
AWK = awk
free-space := $(DF) . | $(AWK) 'NR = = 2 { print $$4 }'
```

用于获取空闲的磁盘空间。我们将会看到，变量被用于这两个目的外，还能做别的。

## 变量类型

在 make 中有两种类型的变量，简单展开变量和递归展开变量。使用 := 赋值操作符定义一个简单展开的变量(或简单变量):

```makefile
MAKE_DEPEND := $(CC) -M
```

它被称为“简单展开”，因为它的右侧在读取 makefile 中的行后立即展开。右侧的任何 make 变量引用都将展开，并将结果文本保存为变量的值。这种行为与大多数编程和脚本语言相同。例如，这个变量的正常展开结果是:

```makefile
gcc -M
```

然而，如果上面的 `CC` 还没有赋值，那么上面赋值的值将是:

```makefile
<space>-M
```

`$(CC)` 被扩展为它的值(不包含字符)，并收缩为空。变量没有定义不是错误。事实上，这非常有用。大多数隐式命令包括未定义的变量，这些变量充当用户自定义的占位符。如果用户没有自定义一个变量，它将压缩为空。现在注意前导空格。右手边首先由 make 进行解析，生成字符串 `$(CC) -M`。当变量引用被压缩为空时，make 不会重新扫描值并修剪空白。空白部分保持完整。

第二种类型的变量称为递归扩展变量。递归展开变量(或递归变量)使用 `=` 赋值操作符定义:

```makefile
MAKE_DEPEND = $(CC) -M
```

它被称为“递归展开”，因为它的右边只是被 make 吃掉，并存储为变量的值，而不需要求值或以任何方式展开。相反，在使用变量时执行展开。对于这个变量，一个更好的术语可能是惰性展开变量，因为计算被推迟到实际使用它的时候。这种扩展风格的一个令人惊讶的效果是，作业可以“无序”执行

```makefile
MAKE_DEPEND = $(CC) -M
...

# Some time later
CC = gcc
```

这里，命令脚本中的 `MAKE_DEPEND` 的值是 `gcc -M`，即使在分配 `MAKE_DEPEND` 时没有定义 `CC`。

实际上，递归变量并不是真正的惰性赋值(至少不是普通的惰性赋值)。每次使用递归变量时，都会对其右侧重新求值。对于根据简单常量定义的变量，如上面的 `MAKE_DEPEND`，这种区别是没有意义的，因为右边的所有变量也是简单常量。但是想象一下，如果右手边的一个变量表示程序的执行，比如 date。每次递归变量展开时，都会执行日期程序，并且每个变量展开都会有不同的值(假设它们至少间隔一秒执行)。有时这是非常有用的。在其他时候，它是非常烦人的!

### 其他赋值类型

在前面的例子中，我们已经看到了两种类型的赋值 `=` 用于创建递归变量，`:=` 用于创建简单变量。make 还提供了另外两个赋值操作符。

`?=` 操作符称为条件变量赋值操作符。这很复杂，我们称之为条件赋值。只有当变量还没有值时，该操作符才会执行所请求的变量赋值。

```makefile
# Put all generated files in the directory $(PROJECT_DIR)/out.
OUTPUT_DIR ?= $(PROJECT_DIR)/out
```

这里，我们设置了输出目录变量 `OUTPUT_DIR`，只有在前面没有设置它的情况下才设置它。这个特性可以很好地与环境变量交互。我们将在本章后面的“变量从何而来”一节讨论这个问题。

另一个赋值操作符 `+=` 通常被称为追加。顾名思义，这个操作符将文本追加到一个变量。这看起来似乎没什么特别的，但在使用递归变量时，这是一个重要的特性。具体来说，赋值右边的值被附加到变量上，而不改变变量中的原始值。“有什么大不了的，这不就是 `append` 一直在做的吗?” 我听到你说。是的，但等等，这有点棘手。

添加一个简单的变量是非常明显的。`+=` 操作符可以这样实现:

```makefile
simple := $(simple) new stuff
```

由于简单变量中的值已经进行了展开，make 可以展开 `$(simple)`、追加文本并完成赋值。但是递归变量带来了一个问题。不允许像下面这样的实现。

```makefile
recursive = $(recursive) new stuff
```

这是一个错误，因为 make 没有好的方法来处理它。如果 make 存储了递归的当前定义加上新东西，make 就不能在运行时再次展开它。此外，尝试展开包含对自身引用的递归变量会产生无限循环。

```text
$ make
makefile:2: *** Recursive variable `recursive' references itself (eventually). Stop.
```

因此，实现 `+=` 是为了允许将文本添加到递归变量中，并执行正确的操作。这个操作符对于将值递增地收集到变量中特别有用。

## 宏

变量可以很好地将值存储为一行文本，但如果我们有一个多行值，比如想要在几个地方执行的命令脚本，该怎么办？例如，可以使用以下命令序列从 Java  .class 文件创建 Java 存档 (或 jar):

```makefile
echo Creating $@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(MANIFEST)
$(RM) $(TMP_JAR_DIR)
```

在像这样的长序列的开头，我喜欢打印一条简短的消息。它可以使阅读 make 的输出更容易。在收到消息后，我们将类文件收集到一个干净的临时目录中。因此，我们删除临时 jar 目录，以防旧的 jar 目录仍然存在，然后我们创建一个新的临时目录。接下来，我们将依赖(及其所有子目录)复制到临时目录中。然后切换到我们的临时目录并创建带有目标文件名的 jar。我们将清单文件添加到 jar 中，最后进行清理。显然，我们不希望在 makefile 中复制这个命令序列，因为这将成为将来的维护问题。我们可以考虑将所有这些命令打包到一个递归变量中，但当 make 回显命令行时，这样做既不方便维护，也难以阅读 (整个序列被回显为一个巨大的文本行)。

相反，我们可以使用由 `define` 指令创建的 GNU make “罐装序列”。术语 “罐装序列” 有点尴尬，所以我们称之为 **宏**。宏只是 make 中定义变量的另一种方式，它可以包含内嵌的换行符，GNU make 手册似乎交替使用变量和宏这两个词。在本书中，我们将特别使用宏这个词来表示使用 define 指令定义的变量，以及用变量表示仅在使用赋值时才定义的变量。

```makefile
define create-jar
    @echo Creating $@...
    $(RM) $(TMP_JAR_DIR)
    $(MKDIR) $(TMP_JAR_DIR)
    $(CP) -r $^ $(TMP_JAR_DIR)
    cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
    $(JAR) -ufm $@ $(MANIFEST)
    $(RM) $(TMP_JAR_DIR)
endef
```

define 指令后面跟着变量名和换行符。变量的主体包含了直到 `endf` 关键字的所有文本，该关键字必须单独出现在一行中。用 define 创建的变量与其他变量展开的方式非常相似，只是在命令脚本的上下文中使用时，宏的每行前面都有一个制表符。一个例子是:

```makefile
$(UI_JAR): $(UI_CLASSES)
    $(create-jar)
```

注意，我们在 echo 命令前添加了一个 `@` 字符。带 `@` 前缀的命令行在执行命令时不会被 make 回显。因此，当我们运行 make 时，它不打印 echo 命令，只打印该命令的输出。如果在宏中使用 `@` 前缀，则前缀字符将应用于使用它的单个行。但是，如果在宏引用中使用了前缀字符，则整个宏体将被隐藏:

```makefile
$(UI_JAR): $(UI_CLASSES)
    @$(create-jar)
```

这只显示:

```text
$ make
Creating ui.jar...
```

`@` 的使用在第五章的“命令修饰符”一节中有更详细的介绍。

## 何时展开变量

在前面几节中，我们开始了解变量扩展的一些微妙之处。结果很大程度上取决于之前定义的内容和地点。您可以很容易地得到您不想要的结果，即使找不到任何错误。那么展开变量的规则是什么呢？这究竟是如何运作的呢？

当 make 运行时，它将分两个阶段执行它的工作。在第一阶段，make 读取 makefile 和包含的任何 makefile。此时，变量和规则被加载到 make 的内部数据库中，并创建了依赖关系图。在第二阶段，make 分析依赖关系图并确定需要更新的目标，然后执行命令脚本来执行所需的更新。

当一个递归变量或定义指令被 make 处理时，变量或宏体中的行会被存储，包括未展开的换行。宏定义的最后一行换行不作为宏的一部分存储。否则，当宏展开时，make 将读取额外的换行符。

当宏被展开时，展开的文本会立即被扫描，以查找进一步的宏或变量引用，这些宏或变量会被展开，以此类推，递归地进行。如果在操作的上下文中展开宏，则宏的每一行都插入一个前导制表符。

总结一下，以下是 makefile 元素展开时的规则:

- 对于变量赋值，当 make 在其第一阶段读取该行时，赋值的左侧总是立即展开。
- `=` 和 `?=` 的右边被推迟，直到在第二阶展开它们。
- `:=` 的右侧立即展开。
- 如果左边最初定义为一个简单变量，则 `+=` 的右边立即展开。否则，它的评估将被推迟。
- 对于宏定义(使用 define 的定义)，宏变量名会立即展开，宏体会推迟到使用时。
- 对于规则，目标和依赖总是立即展开，而命令总是推迟。

表 3-1 总结了变量展开时的情况。

**表 3-1 立即和推迟展开的规则**

| 定义                                                                                                                  | a 的展开 | b 的展开     |
| --------------------------------------------------------------------------------------------------------------------- | -------- | ------------ |
| a = b                                                                                                                 | 立刻     | 推迟         |
| a ?= b                                                                                                                | 立刻     | 推迟         |
| a := b                                                                                                                | 立刻     | 立刻         |
| a += b                                                                                                                | 立刻     | 推迟 或 立刻 |
| define a</br>&nbsp;&nbsp;&nbsp;&nbsp;b...</br>&nbsp;&nbsp;&nbsp;&nbsp;b...</br>&nbsp;&nbsp;&nbsp;&nbsp;b...</br>endef | 立刻     | 推迟         |

作为一条通用规则，在使用变量和宏之前一定要定义它们。特别是，需要在使用目标或依赖中使用的变量之前定义它。

下面的示例将使这一切更加清楚。假设我们重新实现了 `free-space` 宏。我们将一次处理一点示例，然后在最后把它们放在一起。

```makefile
BIN := /usr/bin
PRINTF := $(BIN)/printf
DF := $(BIN)/df
AWK := $(BIN)/awk
```

我们定义了三个变量来保存宏中使用的程序的名称。为了避免代码重复，我们将 `bin` 目录分解为第四个变量。读取这四个变量定义，并立即展开它们的右侧，因为它们是简单的变量。因为 `BIN` 是在其他文件之前定义的，所以可以将它的值插入到它们的值中。

接着，我们定义 `free-space` 宏。

```makefile
define free-space
    $(PRINTF) "Free disk space "
    $(DF) . | $(AWK) 'NR = = 2 { print $$4 }'
endef
```

define 指令后面跟着一个立即展开的变量名。在这种情况下，不需要展开。读取和存储宏的主体是未展开的。

最后，我们在规则中使用宏。

```makefile
OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
    $(free-space)
```

当读取 `$(OUTPUT_DIR)/very_big_file` 时，在目标和依赖中使用的任何变量都会立即展开。在这里，`$(OUTPUT_DIR)` 被扩展到 `/tmp`，形成 `/tmp/very_big_file` 目标文件。接下来，读取此目标的命令脚本。命令行可由前导制表符识别，并可以读取和存储，但不能展开。

下面是整个示例 makefile。为了说明 make 的评估算法，对文件中元素的顺序进行了有意置乱。

```makefile
OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
    $(free-space)

define free-space
    $(PRINTF) "Free disk space "
    $(DF) . | $(AWK) 'NR = = 2 { print $$4 }'
endef

BIN := /usr/bin
PRINTF := $(BIN)/printf
DF := $(BIN)/df
AWK := $(BIN)/awk
```

注意，尽管 makefile 中的行顺序似乎是向后的，但它执行得很好。这是递归变量令人惊讶的效果之一。它可能非常有用，但同时也令人困惑。这个 makefile 工作的原因是命令脚本和宏体的扩展被推迟到实际使用时。因此，它们发生的相对顺序对 makefile 的执行并不重要。

在处理的第二阶段，读取 makefile 之后，make 标识目标、执行依赖项分析并为每个规则执行操作。这里唯一的目标 `$(OUTPUT_DIR)/very_big_file` 没有先决条件，因此 make 将简单地执行操作(假设文件不存在)。命令为 `$(free-space)`。所以 make 展开它，就像程序员写的那样:

```makefile
/tmp/very_big_file:
    /usr/bin/printf "Free disk space "
    /usr/bin/df . | /usr/bin/awk 'NR = = 2 { print $$4 }'
```

一旦所有变量都展开，它就开始一次执行一个命令。

让我们看一下 makefile 中顺序很重要的两个部分。如前所述，立即展开目标 `$(OUTPUT_DIR)/very_big_file`。如果变量 `OUTPUT_DIR` 的定义遵循了该规则，则目标的展开将生成 `/very_big_file`。可能不是用户想要的。类似地，如果 `BIN` 的定义在 `AWK` 之后被移除，这三个变量就会展开为 `/printf`、`/df` 和 `/AWK`，因为使用 `:=` 会立即对赋值的右侧进行计算。然而，在这种情况下，我们可以通过更改 `:=` 为 `=` 来避免 `PRINTF`、`DF` 和 `AWK` 的问题，使它们成为递归变量。

最后一个细节。请注意，将 `OUTPUT_DIR` 和 `BIN` 的定义更改为递归变量并不会改变前面排序问题的效果。重要的问题是，当 `$(OUTPUT_DIR)/very_big_file` 以及 `PRINTF`、`DF` 和 `AWK` 的右侧展开时，它们的展开会立即发生，因此它们引用的变量必须已经定义。

## 特定目标的模式变量

在 makefile 执行期间，变量通常只有一个值。这是由 makefile 处理的两阶段性质所保证的。在第一阶段，读取 makefile，分配和扩展变量，并构建依赖关系图。在第二阶段，分析并遍历依赖关系图。因此，当执行命令脚本时，所有的变量处理都已经完成。但是假设我们想为单个规则或模式重新定义一个变量。

在这个例子中，我们正在编译的文件需要一个额外的命令行选项 `-DUSE_NEW_MALLOC=1`，这个选项不应该提供给其他编译器:

```makefile
gui.o: gui.h
    $(COMPILE.c) -DUSE_NEW_MALLOC=1 $(OUTPUT_OPTION) $<
```

这里，我们通过复制编译命令脚本并添加新的选项解决了这个问题。这种方法在几个方面不太令人满意。首先，我们在复制代码。如果规则发生变化，或者我们选择用自定义模式规则替换内置规则，则需要更新这段代码，但我们可能会忘记更新。其次，如果许多文件需要特殊处理，那么粘贴这段代码的任务很快就会变得非常繁琐并且容易出错(想象一下有 100 个这样的文件)。

为了解决这个问题和其他问题，make 提供了特定目标的变量。这些是附加在目标上的变量定义，仅在处理该目标及其任何依赖期间有效。使用这个特性，我们可以这样改写前面的例子:

```makefile
gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h
    $(COMPILE.c) $(OUTPUT_OPTION) $<
```

变量 `CPPFLAGS` 内置在默认的 C 编译规则中，它包含用于 C 预处理器的选项。通过使用 `+=` 形式的赋值，我们将新选项附加到任何已经存在的值上。现在编译命令脚本可以完全删除:

```makefile
gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h
```

在 `gui.o` 目标正在被处理时，`CPPFLAGS` 的值将包含 `-DUSE_NEW_MALLOC=1`，除了其原始内容。当目标完成后，`CPPFLAGS` 将恢复到原始值。

特定目标变量的通用语法是:

```makefile
target...: variable = value
target...: variable := value
target...: variable += value
target...: variable ?= value
```

如您所见，所有不同形式的赋值对于特定目标的变量都是有效的。变量在赋值之前不需要存在。

而且，直到开始处理目标时，才会实际执行变量赋值。因此，赋值的右侧本身可以是另一个特定目标的变量中设置的值。该变量在处理所有依赖的期间也是有效的。

## 变量来自何处

## 条件和包含处理

## 标准 make 变量

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)
