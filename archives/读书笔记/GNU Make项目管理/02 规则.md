# GNU Make 项目管理 第二章 规则

[annotation]: <id> (09443028-3ef7-4314-8998-5593c2b8c8c8)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 17:40:01)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (2)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/09443028-3ef7-4314-8998-5593c2b8c8c8)

在上一章中，我们编写了一些规则来编译和链接我们的单词计数程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组文件。当要求更新目标时，如果任何先决条件文件比目标修改时间最近，make 将执行规则的命令脚本。由于一个规则的目标可以作为另一条规则的依赖来引用，因此目标和先决条件的集合形成了依赖关系链或图。构建并处理此依赖关系图以更新需要的目标是 make 的全部目的。

由于规则在 make 中是如此重要，因此存在许多不同种类的规则。与上一章中的规则一样，显式规则指出了要更新的特定目标，如果该目标的任何依赖已过时。这是您将要编写的最常见的规则类型。模式规则使用通配符而不是显式文件名。这样，只要需要更新与该模式匹配的目标文件，make 便可以应用该规则。隐式规则是在内置的规则数据库中找到的模式规则或后缀规则。具有内置的规则数据库使编写 makefile 更加容易，因为对于许多常见任务而言，他们已经知道文件类型，后缀和用于更新目标的程序。静态模式规则类似于常规模式规则，但它们仅适用于目标文件的特定列表。

GNU make 可以用作许多其他版本的 make 的替代，并包括一些专门用于兼容性的功能。后缀规则是编写一般规则的原始方法。 GNU make包含对后缀规则的支持，由于被更清晰，更通用的模式规则所取代，它们被认为已过时。

## 显式规则

您将编写的大多数规则都是将特定文件指定为目标和依赖的显式规则。一条规则可以有多个目标。这意味着每个目标都具有与其他目标相同的依赖。如果目标已过期，则将执行同一组操作来更新每个目标。例如：

```makefile
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```

这表明 `vpath.o` 和 `variable.o` 都依赖于同一组 C 头文件。该行与以下内容具有相同的作用：

```makefile
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```

这两个目标是独立处理的。如果任何一个目标文件相对于其任何依赖都过期（也就是说，任何头文件的修改时间都比该目标文件的更新时间晚），make 将通过执行与该规则关联的命令来更新该目标文件。

规则不必一次全部定义。每次 make 看到目标文件时，它都会将目标和依赖添加到依赖关系图中。如果在关系图中已经看到目标并且该目标已存在，则任何其他依赖都将附加到 make 的依赖关系图的目标文件条目中。在简单的情况下，这对于打断长行以提高 makefile 的可读性很有用：

```makefile
vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
```

在更复杂的情况下，依赖列表可以由管理方式非常不同的文件组成：

```makefile
# Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...

# Compile vpath.c with special flags.
vpath.o: vpath.c
    $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

...
# Include dependencies generated by a program.
include auto-generated-dependencies.d
```

第一条规则说，只要更新 `lexer.c` 就必须更新 `vpath.o` 目标（可能是因为生成 `lexer.c` 具有其他副作用）。该规则还可以确保在更新目标之前始终更新依赖。（请注意，规则具有双向性。在向前的方向上，规则表示如果 `lexer.c` 已更新，请执行操作以更新 `vpath.o`。在向后的方向上，规则表示如果需要 make 或使用 `vpath.o`，请首先确保lexer.c是最新的。）此规则可能放在管理 `lexer.c` 的规则附近，因此提醒开发人员这种微妙的关系。随后，将 `vpath.o` 的编译规则放在其他编译规则中。该规则的命令使用三个 make 变量。您会看到很多这样的东西，但是现在您只需要知道变量是 $ 符号后跟一个字符，还是 $ 符号后跟一对括号。 （我将在本章后面的内容中进行更多的解释，而在第三章中将进行详细的解释。）最后，`.o/.h` 依赖关系包含在 makefile 中，它是由外部程序管理的独立文件。

### 通配符

### 伪目标

### 空目标

## 变量

### 自动变量

## 使用 VPATH 和 vpath 查找文件

## 模式规则

### 模式

### 静态模式规则

### 后缀规则

## 隐式规则数据库

### 使用隐式规则

### 规则结构

### 源码控制的隐式规则

### 简单的帮助命令

## 特殊目标

## 依赖生成自动化

## 管理库

### 创建和更新库

### 使用库作为依赖

### 双冒号规则

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)