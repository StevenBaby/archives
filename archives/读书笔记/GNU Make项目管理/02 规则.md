# GNU Make 项目管理 第二章 规则

[annotation]: <id> (09443028-3ef7-4314-8998-5593c2b8c8c8)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 17:40:01)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (2)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/09443028-3ef7-4314-8998-5593c2b8c8c8)

在上一章中，我们编写了一些规则来编译和链接我们的单词计数程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组文件。当要求更新目标时，如果任何先决条件文件比目标修改时间最近，make 将执行规则的命令脚本。由于一个规则的目标可以作为另一条规则的依赖来引用，因此目标和先决条件的集合形成了依赖关系链或图。构建并处理此依赖关系图以更新需要的目标是 make 的全部目的。

由于规则在 make 中是如此重要，因此存在许多不同种类的规则。与上一章中的规则一样，显式规则指出了要更新的特定目标，如果该目标的任何依赖已过时。这是您将要编写的最常见的规则类型。模式规则使用通配符而不是显式文件名。这样，只要需要更新与该模式匹配的目标文件，make 便可以应用该规则。隐式规则是在内置的规则数据库中找到的模式规则或后缀规则。具有内置的规则数据库使编写 makefile 更加容易，因为对于许多常见任务而言，他们已经知道文件类型，后缀和用于更新目标的程序。静态模式规则类似于常规模式规则，但它们仅适用于目标文件的特定列表。

GNU make 可以用作许多其他版本的 make 的替代，并包括一些专门用于兼容性的功能。后缀规则是编写一般规则的原始方法。 GNU make包含对后缀规则的支持，由于被更清晰，更通用的模式规则所取代，它们被认为已过时。

## 显式规则

您将编写的大多数规则都是将特定文件指定为目标和依赖的显式规则。一条规则可以有多个目标。这意味着每个目标都具有与其他目标相同的依赖。如果目标已过期，则将执行同一组操作来更新每个目标。例如：

```makefile
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```

这表明 `vpath.o` 和 `variable.o` 都依赖于同一组 C 头文件。该行与以下内容具有相同的作用：

```makefile
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```

这两个目标是独立处理的。如果任何一个目标文件相对于其任何依赖都过期（也就是说，任何头文件的修改时间都比该目标文件的更新时间晚），make 将通过执行与该规则关联的命令来更新该目标文件。

规则不必一次全部定义。每次 make 看到目标文件时，它都会将目标和依赖添加到依赖关系图中。如果在关系图中已经看到目标并且该目标已存在，则任何其他依赖都将附加到 make 的依赖关系图的目标文件条目中。在简单的情况下，这对于打断长行以提高 makefile 的可读性很有用：

```makefile
vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
```

在更复杂的情况下，依赖列表可以由管理方式非常不同的文件组成：

```makefile
# Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...

# Compile vpath.c with special flags.
vpath.o: vpath.c
    $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

...
# Include dependencies generated by a program.
include auto-generated-dependencies.d
```

第一条规则说，只要更新 `lexer.c` 就必须更新 `vpath.o` 目标（可能是因为生成 `lexer.c` 具有其他副作用）。该规则还可以确保在更新目标之前始终更新依赖。（请注意，规则具有双向性。在向前的方向上，规则表示如果 `lexer.c` 已更新，请执行操作以更新 `vpath.o`。在向后的方向上，规则表示如果需要 make 或使用 `vpath.o`，请首先确保lexer.c是最新的。）此规则可能放在管理 `lexer.c` 的规则附近，因此提醒开发人员这种微妙的关系。随后，将 `vpath.o` 的编译规则放在其他编译规则中。该规则的命令使用三个 make 变量。您会看到很多这样的东西，但是现在您只需要知道变量是 $ 符号后跟一个字符，还是 $ 符号后跟一对括号。 （我将在本章后面的内容中进行更多的解释，而在第三章中将进行详细的解释。）最后，`.o/.h` 依赖关系包含在 makefile 中，它是由外部程序管理的独立文件。

### 通配符

makfile 通常包含很长的文件列表。为了简化此过程，make 支持通配符。 make 的通配符与 **Bourne Shell (sh)** 的通配符相同：`~`，`*`，`?`，`[...]` 和 `[^...]` 。例如，`*.*` 扩展到包含句点的所有文件。一个问号代表任何单个字符，而 `[...]` 代表一个字符类别。要选择 **相反（否定）** 字符类，请使用 `[^...]`。

此外，波浪号 `~` 可以用来表示当前用户的主目录。`~` 后跟用户名代表该用户的主目录。

只要通配符出现在目标，依赖或命令脚本上下文中，通配符就会通过 make 自动展开。在其他情况下，通配符可以通过调用函数来显式扩展。通配符对于创建更具适应性的 makefile 非常有用。例如，您可以使用通配符 `*` 而不是显式列出程序中的所有文件（在更受控的环境中，使用通配符选择程序中的文件被认为是不好的做法，因为流氓源文件可能会意外地链接到程序中）：

```makefile
prog: *.c
    $(CC) -o $@ $^
```

但是，请务必注意通配符。如以下示例所示，很容易滥用它们：

```makefile
*.o: constants.h
```

目的很明确：所有目标文件都依赖于头文件 `constants.h`，但是请考虑如何在没有任何目标文件的干净目录中扩展它：

```makefile
: constants.h
```


这是一个合法的 make 表达式，不会自行产生错误，但也不会提供用户所需的依赖关系。实施此规则的正确方法是对源文件执行通配符（因为它们始终存在）并将其转换为目标文件列表。我们将在第四章中讨论 make 函数时，介绍这种技术。

最后，值得注意的是，当模式作为目标或依赖出现时，通配符扩展是由 make 执行的。但是，当模式出现在命令中时，扩展由子 shell 执行。这有时可能很重要，因为 make 会在读取 makefile 时立即扩展通配符，但是 shell 将在执行命令后更晚地扩展命令中的通配符。当完成许多复杂的文件操作时，两个通配符扩展可能会大不相同。

### 伪目标

到现在为止，所有目标和依赖都是要创建或更新的文件。通常是这种情况，但是对于目标来说，只是代表命令脚本的标签通常会很有用。例如，前面我们注意到，在许多 makefile 文件中，一个标准的第一个目标称为 `all`。不代表文件的目标称为伪目标。另一个标准的伪造目标是 `clean` ：

```makefile
clean:
    rm -f *.o lexer.c
```

通常，由于与规则关联的命令不会创建目标名称，因此始终会执行伪造目标。

If by chance the name of a phony target exists as a file, make will associate the file with the phony target name in its dependency graph. If, for example, the file clean happened to be created running make clean would yield the confusing message:

重要的是要注意，make 无法区分文件目标和假目标。如果不幸伪目标的名称作为文件存在，make 将在其依赖关系图中将文件与伪目标名称相关联。例如，如果碰巧创建了文件 clean，则运行 make clean 会产生令人困惑的消息：

```text
$ make clean
make: `clean' is up to date.
```

由于大多数虚假目标没有依赖，因此干净目标总是被认为是最新的，并且永远不会执行。

为避免此问题，GNU make 包含一个特殊的目标 `.PHONY`，以告知 make 目标不是真实文件。可以通过将任何目标包含为 `.PHONY` 的依赖来声明其为伪目标：

```makefile
.PHONY: clean
clean:
    rm -f *.o lexer.c
```

现在，即使存在一个名为 clean 的文件，make 仍将始终执行与 clean 相关的命令。除了将目标标记为始终过期之外，指定目标为伪目标还可以使此文件不遵循从源文件创建目标文件的正常规则。因此，make 可以优化其常规规则搜索以提高性能。

However, it is often useful to give phony targets prerequisites. For instance, the all target is usually given the list of programs to be built:

使用伪造的目标作为真实文件的依赖几乎没有任何意义，因为伪造总是过时的，并且总是会导致目标文件被重新制作。但是，给伪目标加依赖通常是有用的。例如，通常为 all 目标提供要构建的程序列表：

```makefile
.PHONY: all
all: bash bashbug
```

这里，all 目标都创建了 bash 程序和 bashbug 错误报告工具。

伪目标也可以看作是嵌入在 makefile 中的 shell 脚本。使一个伪目标成为另一个目标的依赖将在创建实际目标之前调用该伪目标脚本。假设我们的磁盘空间紧张，在执行磁盘密集型任务之前，我们要显示可用的磁盘空间。我们可以这样写：

```makefile
.PHONY: make-documentation
make-documentation:
    df -k . | awk 'NR = = 2 { printf( "%d available\n", $$4 ) }'
    javadoc ...
```

这里的问题是，我们最终可能会在不同的目标下多次指定 df 和 awk 命令，这是一个维护问题，因为如果在另一个格式不同的系统上遇到df，则必须更改每个实例。相反，我们可以将 df 行放置在其自己的伪目标中：

```makefile
.PHONY: make-documentation
make-documentation: df
    javadoc ...
.PHONY: df
df:
    df -k . | awk 'NR = = 2 { printf( "%d available\n", $$4 ) }'
```

通过使 `df` 成为 `make-documentation` 的先决条件，我们可以使 make 在生成文档之前调用 `df` 目标。这很有效，因为 make 文档也是一个伪目标。现在，我可以轻松地在其他目标中重用 df 了。

伪目标还有许多其他很好的用途。

make 的输出可能会混淆阅读和调试。造成这种情况的原因有很多：makefile 是自顶向下编写的，但命令是由 make 自底向上执行的；同样，也没有迹象表明当前正在评估哪个规则。如果在 make 输出中注释了主要目标，则可以使 make 的输出更易于阅读。伪目标是实现此目标的有用方法。这是取自 bash makefile 的示例：

```makefile
$(Program): build_msg $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
    $(RM) $@
    $(CC) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
    ls -l $(Program)
    size $(Program)

.PHONY: build_msg
build_msg:
    @printf "#\n# Building $(Program)\n#\n"
```

由于 `printf` 位于伪目标中，因此在更新任何先决条件之前，将立即打印该消息。如果将构建消息放置为 `$(Program)` 命令脚本的第一个命令，则它将在所有编译和依赖项生成之后执行。重要的是要注意，因为伪目标总是过时的，所以伪目标 `build_msg` 即使没有过时也会重新生成 `$(Program)`。在这种情况下，这似乎是一个合理的选择，因为大多数计算是在编译目标文件时执行的，因此始终只执行最终链接。

伪目标也可以用于改善 Makefile 的“用户界面”。目标通常是包含目录路径，其他文件名组件（例如版本号）和标准后缀的复杂字符串。这会使在命令行上指定目标文件名成为一个挑战。可以通过添加一个简单的伪目标来避免该问题，该伪目标的依赖是实际的目标文件。

按照惯例，许多 makefile 包含一组或多或少的标准伪目标。表2-1列出了这些标准伪目标。

**表 2-1 标准伪目标**

| 目标      | 功能                               |
| --------- | ---------------------------------- |
| all       | 执行所有任务以构建应用程序         |
| install   | 从编译的二进制文件安装程序         |
| clean     | 删除从源生成的二进制文件           |
| distclean | 删除所有不在原始源代码中的生成文件 |
| TAGS      | 创建标签表供编辑人员使用           |
| info      | 从其 Texinfo 源创建 GNU 信息文件   |
| check     | 运行与此应用程序相关的任何测试     |

目标 TAGS 并不是真正的伪目标，因为 ctags 和 etags 程序的输出是一个名为 TAGS 的文件。它包含在此处是因为它是我们所知道的唯一标准非伪目标。

### 空目标

空目标与伪目标类似，因为目标本身被用作一种利用 make 能力的设备。伪目标总是过时的，因此它们总会执行，并且依赖它们的目标总会被重新构建。但是，假设我们有一些命令，没有输出文件，只需要偶尔执行一次，并且我们不希望依赖他的目标得到更新。为此，我们可以制定一条规则，其目标是一个空文件（有时称为 cookie）：

```makefile
prog: size prog.o
    $(CC) $(LDFLAGS) -o $@ $^

size: prog.o
    size $^
    touch size
```

请注意，size 规则将会在命令完成后使用 touch 创建一个名为 size 的空文件。此空文件用它自己的时间戳，以便仅在 prog.o 更新后，make 才会执行 size 规则。而且，除非 prog 的目标文件也较新，否则 prog 的 size 依赖不会强制更新 prog。

空文件与自动变量 `$?` 结合使用时特别有用。我们将在 “自动变量” 部分讨论自动变量，但是先看一看自动变量不会有任何问题。在规则的命令脚本部分中，make 定义变量 `$?`。是比目标更新的依赖集合。这是打印自上次执行 make print 以来更改过的所有文件的规则：

```makefile
print: *.[hc]
    lpr $?
    touch $@
```

通常，空文件可用于标记特定事件的上次发生时间。

## 变量

让我们看一下我们在示例中一直使用的一些变量。最简单的语法如下：

```makefile
$(variable-name)
```

这表明我们要扩展名为 variable-name 的变量。变量名几乎可以包含任何文本，变量名称可以包含大多数字符，包括标点符号。例如，包含C 编译命令的变量是 `COMPILE.c`。通常，变量名必须用 `$()` 括起来才能被 make 识别。在特殊情况下，单个字符变量名称不需要括号。

一个 makefile 通常会定义许多变量，但也有许多由 make 自动定义的特殊变量。用户可以将某些设置为控制 make 的行为，而其他则可以通过 make 与用户的 makefile 进行通信。

### 自动变量

Automatic variables are set by make after a rule is matched. They provide access to elements from the target and prerequisite lists so you don’t have to explicitly specify any filenames. They are very useful for avoiding code duplication, but are critical when defining more general pattern rules (discussed later).

规则匹配后，由 make 设置自动变量。它们提供对目标和依赖列表中元素的访问，因此您不必显式指定任何文件名。它们对于避免代码重复非常有用，但是在定义更一般的模式规则（稍后讨论）时很关键。

有六个“核心”自动变量：

- `$@` 代表目标的文件名
- `$%` 仅当目标是函数库文件时，表示规则中的目标成员名。
- `$<` 第一个依赖的文件名
- `$?` 比目标更新的所有依赖的名称，用空格分隔
- `$^` 所有依赖的文件名，用空格分隔。此列表已删除重复的文件名，因为对于大多数用途（例如编译，复制等），不需要重复的文件名。
- `$+` 与 `$^` 类似, 这是用空格分隔的所有依赖的名称，除了 `$+` 包含重复项。该变量是为特定情况创建的，例如链接器的参数，其中重复的值具有含义。
- `$*` 目标文件名的主干。词干通常是没有后缀的文件名。（稍后，在“样式规则”部分中，我们将讨论如何计算词干。）不建议在样式规则之外使用该词干。

此外，上述每个变量都有两个变体，以便与其他 make 兼容。一个变体仅返回值的目录部分。这是通过在符号后追加一个 `D`，`$(@D)`，`$(<D)$` 等等。另一个变体仅返回值的文件部分。。这是通过在符号后追加一个 `F`，`$(@F)`，`$(<F)$` 等等。请注意，这些变量名称的长度超过一个字符，因此必须用括号括起来。 GNU make 使用 dir 和 notdir 函数提供了更具可读性的替代方法。我们将在第四章中讨论此功能。

在规则与其目标和依赖匹配之后，由 make 设置自动变量，因此这些变量仅在规则的命令脚本中可用。

这是我们的 makefile，其显式文件名已替换为适当的自动变量。

```makefile
count_words: count_words.o counter.o lexer.o -lfl
    gcc $^ -o $@

count_words.o: count_words.c
    gcc -c $<

counter.o: counter.c
    gcc -c $<

lexer.o: lexer.c
    gcc -c $<

lexer.c: lexer.l
    flex -t $< > $@
```

## 使用 VPATH 和 vpath 查找文件

到目前为止，我们的示例非常简单，因此 makefile 和源代码都位于一个目录中。现实世界中的程序更加复杂（什么时候是您上一次时什么时候处理的单个目录的项目？）。让我们重构我们的示例并创建一个更真实的文件布局。我们可以通过将 main 重构为一个称为 counter 的函数来修改我们的单词计数程序。

```cpp
#include <lexer.h>
#include <counter.h>
void counter( int counts[4] )
{
    while ( yylex( ) )
    ;
    counts[0] = fee_count;
    counts[1] = fie_count;
    counts[2] = foe_count;
    counts[3] = fum_count;
}
```

可重用的库函数应该在头文件中有一个声明，因此让我们创建包含声明的头文件 `counter.h`：

```cpp
#ifdef COUNTER_H_
#define COUNTER_H_

extern void
counter( int counts[4] );

#endif
```

我们还可以将 `lexer.l` 符号的声明放置在 `lexer.h` 中：

```cpp
#ifndef LEXER_H_
#define LEXER_H_

extern int fee_count, fie_count, foe_count, fum_count;
extern int yylex( void );

#endif
```

 We’ll do this and put our makefile in the parent directory. Our example program now has the layout shown in Figure 2-1.

在传统的源代码树布局中，头文件放置在 include 目录中，而源文件放置在 src 目录中。我们也这样做，并将我们的 makefile 放在父目录中。现在，我们的示例程序的布局如图所示。

![](./images/2-1.jpg)

由于我们的源文件现在包括头文件，因此这些新的依赖关系应记录在我们的 makefile 中，以便在修改头文件时，更新相应的目标文件。

```makefile
count_words: count_words.o counter.o lexer.o -lfl
    gcc $^ -o $@

count_words.o: count_words.c include/counter.h
    gcc -c $<

counter.o: counter.c include/counter.h include/lexer.h
    gcc -c $<

lexer.o: lexer.c include/lexer.h
    gcc -c $<

lexer.c: lexer.l
    flex -t $< > $@
```

现在，当我们运行 makefile 时，我们得到：

```text
$ make
make: *** No rule to make target `count_words.c', needed by `count_words.o'. Stop.
```

糟糕，发生了什么事？该 makefile 正在尝试更新 `count_words.c`，但这是源文件！让我们来“玩玩” make。我们的第一个依赖是`count_words.o`。我们看到文件丢失，并寻找创建它的规则。创建 `count_words.o` 的显式规则引用 `count_words.c`。但是为什么找不到源文件？因为源文件位于 `src` 目录中，而不是当前目录中。除非另有说明，否则 make 将在当前目录中查找其目标和依赖。我们如何在 `src` 目录中查找源文件？或更笼统地说，我们如何分辨源代码在哪里？

您可以告诉 make 使用 VPATH 和 vpath 的功能在不同的目录中查找其源文件。为了解决当前的问题，我们可以将 VPATH 赋值并添加到 makefile 中：

```makefile
VPATH = src
```

这表明，如果 make 所需的文件不在当前目录中，则 make 应该在目录 src 中查找。现在，当我们运行 makefile 时，我们得到：

```text
$ make
gcc -c src/count_words.c -o count_words.o
src/count_words.c:2:21: counter.h: No such file or directory
make: *** [count_words.o] Error 1
```

注意，make 现在可以成功尝试编译第一个文件，并正确填写源的相对路径。这是使用自动变量的另一个原因：如果对文件名进行硬编码，make 将无法使用源的适当路径。不幸的是，编译失败了，因为 `gcc` 找不到包含文件。我们可以通过使用适当的 `-I` 选项 “自定义” 隐式编译规则来解决此最新问题：

```makefile
CPPFLAGS = -I include
```

现在构建成功：

```text
$ make
gcc -I include -c src/count_words.c -o count_words.o
gcc -I include -c src/counter.c -o counter.o
flex -t src/lexer.l > lexer.c
gcc -I include -c lexer.c -o lexer.o
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words
```

`VPATH` 变量由目录列表组成，在 make 需要文件时将在这些目录中进行搜索列表中目标和依赖，但不搜索命令脚本中提到的文件。目录列表在 Unix 上可以用空格或冒号分隔，而在 Windows 上可以用空格或分号分隔。我更喜欢使用空格，因为它可以在所有系统上使用，并且我们可以避免整个 冒号/分号 的出现。同样，目录之间用空格分隔时更易于阅读。

`VPATH` 变量很好，因为它解决了上面的搜索问题，但是它同样是一个很大的问题。 make 将在每个目录中搜索所需的任何文件。如果同名文件存在于 `VPATH` 列表中的多个位置，则 make 会取第一个文件。有时这可能是个问题。

`vpath` 指令是实现我们目标的一种更精确的方法。该指令的语法为：

```makefile
vpath pattern directory-list
```

因此，我们以前的 `VPATH` 用法可以重写为：

```makefile
vpath %.c src
vpath %.h include
```

现在我们告诉 make 它应该在 `src` 目录中搜索 `.c` 文件，并且我们还添加了一行来在 `include` 目录中搜索 .`h` 文件（因此我们可以从头文件的依赖中删除 `include/` ） 。在更复杂的应用程序中，此控件可以节省很多麻烦和调试时间。

在这里，我们使用 `vpath` 来处理查找分布在多个目录中的源代码的问题。有一个构建程序时相关但不同的问题，如何构建应用程序以使目标文件写入“二进制树”，而源文件位于单独的“源代码树”中。正确使用 `vpath` 也可以帮助解决这个新问题，但是任务很快就变得复杂了，仅凭 `vpath` 是不够的。我们将在后面的部分中详细讨论此问题。

## 模式规则

### 模式

### 静态模式规则

### 后缀规则

## 隐式规则数据库

### 使用隐式规则

### 规则结构

### 源码控制的隐式规则

### 简单的帮助命令

## 特殊目标

## 依赖生成自动化

## 管理库

### 创建和更新库

### 使用库作为依赖

### 双冒号规则

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)