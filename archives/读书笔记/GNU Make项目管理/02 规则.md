# GNU Make 项目管理 第二章 规则

[annotation]: <id> (09443028-3ef7-4314-8998-5593c2b8c8c8)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 17:40:01)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (2)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/09443028-3ef7-4314-8998-5593c2b8c8c8)

在上一章中，我们编写了一些规则来编译和链接我们的单词计数程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组文件。当要求更新目标时，如果任何先决条件文件比目标修改时间最近，make 将执行规则的命令脚本。由于一个规则的目标可以作为另一条规则的依赖来引用，因此目标和先决条件的集合形成了依赖关系链或图。构建并处理此依赖关系图以更新需要的目标是 make 的全部目的。

由于规则在 make 中是如此重要，因此存在许多不同种类的规则。与上一章中的规则一样，显式规则指出了要更新的特定目标，如果该目标的任何依赖已过时。这是您将要编写的最常见的规则类型。模式规则使用通配符而不是显式文件名。这样，只要需要更新与该模式匹配的目标文件，make 便可以应用该规则。隐式规则是在内置的规则数据库中找到的模式规则或后缀规则。具有内置的规则数据库使编写 makefile 更加容易，因为对于许多常见任务而言，他们已经知道文件类型，后缀和用于更新目标的程序。静态模式规则类似于常规模式规则，但它们仅适用于目标文件的特定列表。

GNU make 可以用作许多其他版本的 make 的替代，并包括一些专门用于兼容性的功能。后缀规则是编写一般规则的原始方法。 GNU make包含对后缀规则的支持，由于被更清晰，更通用的模式规则所取代，它们被认为已过时。

## 显式规则

您将编写的大多数规则都是将特定文件指定为目标和依赖的显式规则。一条规则可以有多个目标。这意味着每个目标都具有与其他目标相同的依赖。如果目标已过期，则将执行同一组操作来更新每个目标。例如：

```makefile
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```



### 通配符

### 伪目标

### 空目标

## 变量

### 自动变量

## 使用 VPATH 和 vpath 查找文件

## 模式规则

### 模式

### 静态模式规则

### 后缀规则

## 隐式规则数据库

### 使用隐式规则

### 规则结构

### 源码控制的隐式规则

### 简单的帮助命令

## 特殊目标

## 依赖生成自动化

## 管理库

### 创建和更新库

### 使用库作为依赖

### 双冒号规则

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)