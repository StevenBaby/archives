# GNU Make 项目管理 第二章 规则

[annotation]: <id> (09443028-3ef7-4314-8998-5593c2b8c8c8)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 17:40:01)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (2)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/09443028-3ef7-4314-8998-5593c2b8c8c8)

在上一章中，我们编写了一些规则来编译和链接我们的单词计数程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组文件。当要求更新目标时，如果任何先决条件文件比目标修改时间最近，make 将执行规则的命令脚本。由于一个规则的目标可以作为另一条规则的依赖来引用，因此目标和先决条件的集合形成了依赖关系链或图。构建并处理此依赖关系图以更新需要的目标是 make 的全部目的。

由于规则在 make 中是如此重要，因此存在许多不同种类的规则。与上一章中的规则一样，显式规则指出了要更新的特定目标，如果该目标的任何依赖已过时。这是您将要编写的最常见的规则类型。模式规则使用通配符而不是显式文件名。这样，只要需要更新与该模式匹配的目标文件，make 便可以应用该规则。隐式规则是在内置的规则数据库中找到的模式规则或后缀规则。具有内置的规则数据库使编写 makefile 更加容易，因为对于许多常见任务而言，他们已经知道文件类型，后缀和用于更新目标的程序。静态模式规则类似于常规模式规则，但它们仅适用于目标文件的特定列表。

GNU make 可以用作许多其他版本的 make 的替代，并包括一些专门用于兼容性的功能。后缀规则是编写一般规则的原始方法。 GNU make包含对后缀规则的支持，由于被更清晰，更通用的模式规则所取代，它们被认为已过时。

## 显式规则

您将编写的大多数规则都是将特定文件指定为目标和依赖的显式规则。一条规则可以有多个目标。这意味着每个目标都具有与其他目标相同的依赖。如果目标已过期，则将执行同一组操作来更新每个目标。例如：

```makefile
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```

这表明 `vpath.o` 和 `variable.o` 都依赖于同一组 C 头文件。该行与以下内容具有相同的作用：

```makefile
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```

这两个目标是独立处理的。如果任何一个目标文件相对于其任何依赖都过期（也就是说，任何头文件的修改时间都比该目标文件的更新时间晚），make 将通过执行与该规则关联的命令来更新该目标文件。

规则不必一次全部定义。每次 make 看到目标文件时，它都会将目标和依赖添加到依赖关系图中。如果在关系图中已经看到目标并且该目标已存在，则任何其他依赖都将附加到 make 的依赖关系图的目标文件条目中。在简单的情况下，这对于打断长行以提高 makefile 的可读性很有用：

```makefile
vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
```

在更复杂的情况下，依赖列表可以由管理方式非常不同的文件组成：

```makefile
# Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...

# Compile vpath.c with special flags.
vpath.o: vpath.c
    $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

...
# Include dependencies generated by a program.
include auto-generated-dependencies.d
```

第一条规则说，只要更新 `lexer.c` 就必须更新 `vpath.o` 目标（可能是因为生成 `lexer.c` 具有其他副作用）。该规则还可以确保在更新目标之前始终更新依赖。（请注意，规则具有双向性。在向前的方向上，规则表示如果 `lexer.c` 已更新，请执行操作以更新 `vpath.o`。在向后的方向上，规则表示如果需要 make 或使用 `vpath.o`，请首先确保lexer.c是最新的。）此规则可能放在管理 `lexer.c` 的规则附近，因此提醒开发人员这种微妙的关系。随后，将 `vpath.o` 的编译规则放在其他编译规则中。该规则的命令使用三个 make 变量。您会看到很多这样的东西，但是现在您只需要知道变量是 $ 符号后跟一个字符，还是 $ 符号后跟一对括号。 （我将在本章后面的内容中进行更多的解释，而在第三章中将进行详细的解释。）最后，`.o/.h` 依赖关系包含在 makefile 中，它是由外部程序管理的独立文件。

### 通配符

makfile 通常包含很长的文件列表。为了简化此过程，make 支持通配符。 make 的通配符与 **Bourne Shell (sh)** 的通配符相同：`~`，`*`，`?`，`[...]` 和 `[^...]` 。例如，`*.*` 扩展到包含句点的所有文件。一个问号代表任何单个字符，而 `[...]` 代表一个字符类别。要选择 **相反（否定）** 字符类，请使用 `[^...]`。

此外，波浪号 `~` 可以用来表示当前用户的主目录。`~` 后跟用户名代表该用户的主目录。

只要通配符出现在目标，依赖或命令脚本上下文中，通配符就会通过 make 自动展开。在其他情况下，通配符可以通过调用函数来显式扩展。通配符对于创建更具适应性的 makefile 非常有用。例如，您可以使用通配符 `*` 而不是显式列出程序中的所有文件（在更受控的环境中，使用通配符选择程序中的文件被认为是不好的做法，因为流氓源文件可能会意外地链接到程序中）：

```makefile
prog: *.c
    $(CC) -o $@ $^
```

但是，请务必注意通配符。如以下示例所示，很容易滥用它们：

```makefile
*.o: constants.h
```

目的很明确：所有目标文件都依赖于头文件 `constants.h`，但是请考虑如何在没有任何目标文件的干净目录中扩展它：

```makefile
: constants.h
```


这是一个合法的 make 表达式，不会自行产生错误，但也不会提供用户所需的依赖关系。实施此规则的正确方法是对源文件执行通配符（因为它们始终存在）并将其转换为目标文件列表。我们将在第四章中讨论 make 函数时，介绍这种技术。

最后，值得注意的是，当模式作为目标或依赖出现时，通配符扩展是由 make 执行的。但是，当模式出现在命令中时，扩展由子 shell 执行。这有时可能很重要，因为 make 会在读取 makefile 时立即扩展通配符，但是 shell 将在执行命令后更晚地扩展命令中的通配符。当完成许多复杂的文件操作时，两个通配符扩展可能会大不相同。

### 伪目标

到现在为止，所有目标和依赖都是要创建或更新的文件。通常是这种情况，但是对于目标来说，只是代表命令脚本的标签通常会很有用。例如，前面我们注意到，在许多 makefile 文件中，一个标准的第一个目标称为 `all`。不代表文件的目标称为伪目标。另一个标准的伪造目标是 `clean` ：

```makefile
clean:
    rm -f *.o lexer.c
```

通常，由于与规则关联的命令不会创建目标名称，因此始终会执行伪造目标。

If by chance the name of a phony target exists as a file, make will associate the file with the phony target name in its dependency graph. If, for example, the file clean happened to be created running make clean would yield the confusing message:

重要的是要注意，make 无法区分文件目标和假目标。如果不幸伪目标的名称作为文件存在，make 将在其依赖关系图中将文件与伪目标名称相关联。例如，如果碰巧创建了文件 clean，则运行 make clean 会产生令人困惑的消息：

```text
$ make clean
make: `clean' is up to date.
```

由于大多数虚假目标没有依赖，因此干净目标总是被认为是最新的，并且永远不会执行。

为避免此问题，GNU make 包含一个特殊的目标 `.PHONY`，以告知 make 目标不是真实文件。可以通过将任何目标包含为 `.PHONY` 的依赖来声明其为伪目标：

```makefile
.PHONY: clean
clean:
    rm -f *.o lexer.c
```

现在，即使存在一个名为 clean 的文件，make 仍将始终执行与 clean 相关的命令。除了将目标标记为始终过期之外，指定目标为伪目标还可以使此文件不遵循从源文件创建目标文件的正常规则。因此，make 可以优化其常规规则搜索以提高性能。

However, it is often useful to give phony targets prerequisites. For instance, the all target is usually given the list of programs to be built:

使用伪造的目标作为真实文件的依赖几乎没有任何意义，因为伪造总是过时的，并且总是会导致目标文件被重新制作。但是，给伪目标加依赖通常是有用的。例如，通常为 all 目标提供要构建的程序列表：

```makefile
.PHONY: all
all: bash bashbug
```

这里，all 目标都创建了 bash 程序和 bashbug 错误报告工具。

伪目标也可以看作是嵌入在 makefile 中的 shell 脚本。使一个伪目标成为另一个目标的依赖将在创建实际目标之前调用该伪目标脚本。假设我们的磁盘空间紧张，在执行磁盘密集型任务之前，我们要显示可用的磁盘空间。我们可以这样写：

```makefile
.PHONY: make-documentation
make-documentation:
    df -k . | awk 'NR = = 2 { printf( "%d available\n", $$4 ) }'
    javadoc ...
```

这里的问题是，我们最终可能会在不同的目标下多次指定 df 和 awk 命令，这是一个维护问题，因为如果在另一个格式不同的系统上遇到df，则必须更改每个实例。相反，我们可以将 df 行放置在其自己的伪目标中：

```makefile
.PHONY: make-documentation
make-documentation: df
    javadoc ...
.PHONY: df
df:
    df -k . | awk 'NR = = 2 { printf( "%d available\n", $$4 ) }'
```

通过使 `df` 成为 `make-documentation` 的先决条件，我们可以使 make 在生成文档之前调用 `df` 目标。这很有效，因为 make 文档也是一个伪目标。现在，我可以轻松地在其他目标中重用 df 了。

伪目标还有许多其他很好的用途。

make 的输出可能会混淆阅读和调试。造成这种情况的原因有很多：makefile 是自顶向下编写的，但命令是由 make 自底向上执行的；同样，也没有迹象表明当前正在评估哪个规则。如果在 make 输出中注释了主要目标，则可以使 make 的输出更易于阅读。伪目标是实现此目标的有用方法。这是取自 bash makefile 的示例：

```makefile
$(Program): build_msg $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
    $(RM) $@
    $(CC) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
    ls -l $(Program)
    size $(Program)

.PHONY: build_msg
build_msg:
    @printf "#\n# Building $(Program)\n#\n"
```

由于 `printf` 位于伪目标中，因此在更新任何先决条件之前，将立即打印该消息。如果将构建消息放置为 `$(Program)` 命令脚本的第一个命令，则它将在所有编译和依赖项生成之后执行。重要的是要注意，因为伪目标总是过时的，所以伪目标 `build_msg` 即使没有过时也会重新生成 `$(Program)`。在这种情况下，这似乎是一个合理的选择，因为大多数计算是在编译目标文件时执行的，因此始终只执行最终链接。

伪目标也可以用于改善 Makefile 的“用户界面”。目标通常是包含目录路径，其他文件名组件（例如版本号）和标准后缀的复杂字符串。这会使在命令行上指定目标文件名成为一个挑战。可以通过添加一个简单的伪目标来避免该问题，该伪目标的依赖是实际的目标文件。

按照惯例，许多 makefile 包含一组或多或少的标准伪目标。表2-1列出了这些标准伪目标。

**表 2-1 标准伪目标**

| 目标      | 功能                               |
| --------- | ---------------------------------- |
| all       | 执行所有任务以构建应用程序         |
| install   | 从编译的二进制文件安装程序         |
| clean     | 删除从源生成的二进制文件           |
| distclean | 删除所有不在原始源代码中的生成文件 |
| TAGS      | 创建标签表供编辑人员使用           |
| info      | 从其 Texinfo 源创建 GNU 信息文件   |
| check     | 运行与此应用程序相关的任何测试     |

目标 TAGS 并不是真正的伪目标，因为 ctags 和 etags 程序的输出是一个名为 TAGS 的文件。它包含在此处是因为它是我们所知道的唯一标准非伪目标。

### 空目标

空目标与伪目标类似，因为目标本身被用作一种利用 make 能力的设备。伪目标总是过时的，因此它们总会执行，并且依赖它们的目标总会被重新构建。但是，假设我们有一些命令，没有输出文件，只需要偶尔执行一次，并且我们不希望依赖他的目标得到更新。为此，我们可以制定一条规则，其目标是一个空文件（有时称为 cookie）：

```makefile
prog: size prog.o
    $(CC) $(LDFLAGS) -o $@ $^

size: prog.o
    size $^
    touch size
```

请注意，size 规则将会在命令完成后使用 touch 创建一个名为 size 的空文件。此空文件用它自己的时间戳，以便仅在 prog.o 更新后，make 才会执行 size 规则。而且，除非 prog 的目标文件也较新，否则 prog 的 size 依赖不会强制更新 prog。

空文件与自动变量 `$?` 结合使用时特别有用。我们将在 “自动变量” 部分讨论自动变量，但是先看一看自动变量不会有任何问题。在规则的命令脚本部分中，make 定义变量 `$?`。是比目标更新的依赖集合。这是打印自上次执行 make print 以来更改过的所有文件的规则：

```makefile
print: *.[hc]
    lpr $?
    touch $@
```

通常，空文件可用于标记特定事件的上次发生时间。

## 变量

让我们看一下我们在示例中一直使用的一些变量。最简单的语法如下：

```makefile
$(variable-name)
```

这表明我们要扩展名为 variable-name 的变量。变量名几乎可以包含任何文本，变量名称可以包含大多数字符，包括标点符号。例如，包含C 编译命令的变量是 `COMPILE.c`。通常，变量名必须用 `$()` 括起来才能被 make 识别。在特殊情况下，单个字符变量名称不需要括号。

一个 makefile 通常会定义许多变量，但也有许多由 make 自动定义的特殊变量。用户可以将某些设置为控制 make 的行为，而其他则可以通过 make 与用户的 makefile 进行通信。

### 自动变量

规则匹配后，由 make 设置自动变量。它们提供对目标和依赖列表中元素的访问，因此您不必显式指定任何文件名。它们对于避免代码重复非常有用，但是在定义更一般的模式规则（稍后讨论）时很关键。

有六个“核心”自动变量：

- `$@` 代表目标的文件名
- `$%` 仅当目标是函数库文件时，表示规则中的目标成员名。
- `$<` 第一个依赖的文件名
- `$?` 比目标更新的所有依赖的名称，用空格分隔
- `$^` 所有依赖的文件名，用空格分隔。此列表已删除重复的文件名，因为对于大多数用途（例如编译，复制等），不需要重复的文件名。
- `$+` 与 `$^` 类似, 这是用空格分隔的所有依赖的名称，除了 `$+` 包含重复项。该变量是为特定情况创建的，例如链接器的参数，其中重复的值具有含义。
- `$*` 目标文件名的主干。词干通常是没有后缀的文件名。（稍后，在“样式规则”部分中，我们将讨论如何计算词干。）不建议在样式规则之外使用该词干。

此外，上述每个变量都有两个变体，以便与其他 make 兼容。一个变体仅返回值的目录部分。这是通过在符号后追加一个 `D`，`$(@D)`，`$(<D)$` 等等。另一个变体仅返回值的文件部分。。这是通过在符号后追加一个 `F`，`$(@F)`，`$(<F)$` 等等。请注意，这些变量名称的长度超过一个字符，因此必须用括号括起来。 GNU make 使用 dir 和 notdir 函数提供了更具可读性的替代方法。我们将在第四章中讨论此功能。

在规则与其目标和依赖匹配之后，由 make 设置自动变量，因此这些变量仅在规则的命令脚本中可用。

这是我们的 makefile，其显式文件名已替换为适当的自动变量。

```makefile
count_words: count_words.o counter.o lexer.o -lfl
    gcc $^ -o $@

count_words.o: count_words.c
    gcc -c $<

counter.o: counter.c
    gcc -c $<

lexer.o: lexer.c
    gcc -c $<

lexer.c: lexer.l
    flex -t $< > $@
```

## 使用 VPATH 和 vpath 查找文件

到目前为止，我们的示例非常简单，因此 makefile 和源代码都位于一个目录中。现实世界中的程序更加复杂（什么时候是您上一次时什么时候处理的单个目录的项目？）。让我们重构我们的示例并创建一个更真实的文件布局。我们可以通过将 main 重构为一个称为 counter 的函数来修改我们的单词计数程序。

```cpp
#include <lexer.h>
#include <counter.h>
void counter( int counts[4] )
{
    while ( yylex( ) )
    ;
    counts[0] = fee_count;
    counts[1] = fie_count;
    counts[2] = foe_count;
    counts[3] = fum_count;
}
```

可重用的库函数应该在头文件中有一个声明，因此让我们创建包含声明的头文件 `counter.h`：

```cpp
#ifdef COUNTER_H_
#define COUNTER_H_

extern void
counter( int counts[4] );

#endif
```

我们还可以将 `lexer.l` 符号的声明放置在 `lexer.h` 中：

```cpp
#ifndef LEXER_H_
#define LEXER_H_

extern int fee_count, fie_count, foe_count, fum_count;
extern int yylex( void );

#endif
```

在传统的源代码树布局中，头文件放置在 include 目录中，而源文件放置在 src 目录中。我们也这样做，并将我们的 makefile 放在父目录中。现在，我们的示例程序的布局如图所示。

![](./images/2-1.jpg)

由于我们的源文件现在包括头文件，因此这些新的依赖关系应记录在我们的 makefile 中，以便在修改头文件时，更新相应的目标文件。

```makefile
count_words: count_words.o counter.o lexer.o -lfl
    gcc $^ -o $@

count_words.o: count_words.c include/counter.h
    gcc -c $<

counter.o: counter.c include/counter.h include/lexer.h
    gcc -c $<

lexer.o: lexer.c include/lexer.h
    gcc -c $<

lexer.c: lexer.l
    flex -t $< > $@
```

现在，当我们运行 makefile 时，我们得到：

```text
$ make
make: *** No rule to make target `count_words.c', needed by `count_words.o'. Stop.
```

糟糕，发生了什么事？该 makefile 正在尝试更新 `count_words.c`，但这是源文件！让我们来“玩玩” make。我们的第一个依赖是`count_words.o`。我们看到文件丢失，并寻找创建它的规则。创建 `count_words.o` 的显式规则引用 `count_words.c`。但是为什么找不到源文件？因为源文件位于 `src` 目录中，而不是当前目录中。除非另有说明，否则 make 将在当前目录中查找其目标和依赖。我们如何在 `src` 目录中查找源文件？或更笼统地说，我们如何分辨源代码在哪里？

您可以告诉 make 使用 VPATH 和 vpath 的功能在不同的目录中查找其源文件。为了解决当前的问题，我们可以将 VPATH 赋值并添加到 makefile 中：

```makefile
VPATH = src
```

这表明，如果 make 所需的文件不在当前目录中，则 make 应该在目录 src 中查找。现在，当我们运行 makefile 时，我们得到：

```text
$ make
gcc -c src/count_words.c -o count_words.o
src/count_words.c:2:21: counter.h: No such file or directory
make: *** [count_words.o] Error 1
```

注意，make 现在可以成功尝试编译第一个文件，并正确填写源的相对路径。这是使用自动变量的另一个原因：如果对文件名进行硬编码，make 将无法使用源的适当路径。不幸的是，编译失败了，因为 `gcc` 找不到包含文件。我们可以通过使用适当的 `-I` 选项 “自定义” 隐式编译规则来解决此最新问题：

```makefile
CPPFLAGS = -I include
```

现在构建成功：

```text
$ make
gcc -I include -c src/count_words.c -o count_words.o
gcc -I include -c src/counter.c -o counter.o
flex -t src/lexer.l > lexer.c
gcc -I include -c lexer.c -o lexer.o
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words
```

`VPATH` 变量由目录列表组成，在 make 需要文件时将在这些目录中进行搜索列表中目标和依赖，但不搜索命令脚本中提到的文件。目录列表在 Unix 上可以用空格或冒号分隔，而在 Windows 上可以用空格或分号分隔。我更喜欢使用空格，因为它可以在所有系统上使用，并且我们可以避免整个 冒号/分号 的出现。同样，目录之间用空格分隔时更易于阅读。

`VPATH` 变量很好，因为它解决了上面的搜索问题，但是它同样是一个很大的问题。 make 将在每个目录中搜索所需的任何文件。如果同名文件存在于 `VPATH` 列表中的多个位置，则 make 会取第一个文件。有时这可能是个问题。

`vpath` 指令是实现我们目标的一种更精确的方法。该指令的语法为：

```makefile
vpath pattern directory-list
```

因此，我们以前的 `VPATH` 用法可以重写为：

```makefile
vpath %.c src
vpath %.h include
```

现在我们告诉 make 它应该在 `src` 目录中搜索 `.c` 文件，并且我们还添加了一行来在 `include` 目录中搜索 .`h` 文件（因此我们可以从头文件的依赖中删除 `include/` ） 。在更复杂的应用程序中，此控件可以节省很多麻烦和调试时间。

在这里，我们使用 `vpath` 来处理查找分布在多个目录中的源代码的问题。有一个构建程序时相关但不同的问题，如何构建应用程序以使目标文件写入“二进制树”，而源文件位于单独的“源代码树”中。正确使用 `vpath` 也可以帮助解决这个新问题，但是任务很快就变得复杂了，仅凭 `vpath` 是不够的。我们将在后面的部分中详细讨论此问题。

## 模式规则

我们一直在看的 makefile 示例有些冗长。对于一个包含十几个文件或更少文件的小型程序，我们可能并不在乎，但是对于具有成百上千个文件的程序，指定每个目标，依赖和命令脚本将变得不可行。此外，命令本身代表我们 makefile 中的重复代码。如果命令包含错误或有任何更改，我们将必须更新所有这些规则。这可能是主要的维护问题，也可能是错误的来源。

读取一种文件类型并输出另一种文件类型的许多程序都符合标准约定。例如，所有 C 编译器都假定后缀为 `.c` 的文件包含 C 源代码，并且可以通过将 `.c` 后缀替换为 `.o`（对于某些 Windows 编译器为 `.obj`）来得到对象文件名。在上一章中，我们注意到 `flex` 输入文件使用 `.l` 后缀，而 `flex` 生成 .`c` 文件。

这些约定允许 make 通过识别常见文件名模式来简化规则的创建，并且提供内置规则来处理它们。例如，通过使用这些内置规则，我们的 17 行 makefile 可以减少为：

```makefile
VPATH = src include
CPPFLAGS = -I include

count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h
```

内置规则是模式规则的所有实例。模式规则看起来像您已经看到的普通规则，只是文件的茎（后缀前的部分）用 `%` 字符表示。由于三个内置规则，此 makefile 才起作用。第一个指定如何从 `.c` 文件编译 `.o` 文件：

```makefile
%.o: %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<
```

The second specifies how to make a .c file from a .l file:


第二个参数指定如何从 `.l` 文件生成 `.c` 文件

```makefile
%.c: %.l
    @$(RM) $@
    $(LEX.l) $< > $@
```

最后，有一个特殊规则来从 .c 文件生成不带后缀的文件（始终是可执行文件）：

```makefile
%: %.c
    $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

我们将详细讨论该语法的细节，但首先让我们仔细检查 make 的输出，然后了解 make 如何应用这些内置规则。

在运行我们的这两行 makefile 时，输出为：

```text
$ make
gcc -I include -c -o count_words.o src/count_words.c
gcc -I include -c -o counter.o src/counter.c
flex -t src/lexer.l > lexer.c
gcc -I include -c -o lexer.o lexer.c
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words
rm lexer.c
```

首先，由于未指定命令行目标，因此 make 读取 makefile 并将默认目标设置为 count_words。查看默认目标，make识别四个依赖项：`count_words.o`（该依赖在 makefile 中没有，但由隐式规则提供），`counter.o`，`lexer.o` 和 `-lfl`。然后，它尝试依次更新每个依赖项。

当 make 检查第一个依赖 `count_words.o` 时，make 不会找到任何显式规则，而找到了隐式规则。在本地目录中查找，make 无法找到源代码，因此它开始搜索 `VPATH` 并在 src 中找到匹配的源文件。由于 `src/count_words.c` 没有依赖，因此 make 可以随时更新`count_words.o`，因此它可以运行隐式规则的命令。 `counter.o` 是相似的。当 make 考虑更新 `lexer.o` 时，它找不到对应的源文件（即使在 `src` 中），因此它假定该源文件（不存在）是中间文件，并寻找一种从其他源文件生成 `lexer.c` 的方法。它发现从 `.l` 文件创建 `.c` 文件的规则，并注意到 `lexer.l` 存在。不需要执行任何操作来更新 `lexer.l`，因此它将移至用于更新`lexer.c` 的命令，这将产生 flex 命令行。接下来，make 从 C 源代码更新目标文件。使用这样的规则序列来更新目标称为规则序列。

接下来，make 检查库规范 `-lfl`。它在系统标准库目录中搜索，并发现了 `/lib/libfl.a`。

现在 make 具有更新 count_words 的所有依赖，因此它执行最终的 gcc 命令。最后，make 意识到它创建了一个不需要保留的中间文件，因此可以清理它。

如你所见，在 makefile 文件中使用规则可以省略很多细节。规则可以具有复杂的交互作用，从而产生非常强大的行为。特别的，具有通用规则的内置数据库使许多类型的 Makefile 文件非常简单。

可以通过更改命令脚本中变量的值来自定义内置规则。典型的规则有很多变量，从要执行的程序开始，包括设置命令行选项（例如输出文件，优化，调试等）的变量。您可以查看 make 的默认规则集（和变量），方法是运行 `make --print-data-base`。

### 模式

模式规则中的 `%` 字符大致相当于Unix shell中的 `*` 。它代表任意数量的任何字符。`%` 可以放在模式中的任何位置，但只能出现一次。下面 `%` 的一些有效用法：

```makefile
%,v
s%.o
wrapper_%
```

除 % 以外的其他字符在文件名中实际匹配。模式可以包含前缀或后缀或两者都有。在 make 搜索以应用模式规则时，它首先查找匹配的模式规则目标。模式规则目标必须以前缀开头，并以后缀结尾（如果存在）。如果找到匹配项，则前缀和后缀之间的字符将作为名称的词干。接下来，通过将词干替换为依赖模式来研究模式规则的依赖。如果结果文件名存在或可以通过应用其他规则来创建，则进行匹配并应用该规则。词干必须至少包含一个字符。

也可以使用仅包含 % 字符的模式。此模式最常见的用途是构建 Unix 可执行程序。例如，以下是 GNU make 的用于构建程序的几种模式规则：

```makefile
%: %.mod
    $(COMPILE.mod) -o $@ -e $@ $^

%: %.cpp
    $(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@

%: %.sh
    cat $< >$@
    chmod a+x $@
```

这些模式将分别用于从 Modula 源文件，预处理的 C 源文件和 Bourne shell 脚本生成可执行文件。我们将在 “隐式规则数据库” 部分中看到更多隐式规则。

### 静态模式规则

静态模式规则是仅适用于特定目标列表的规则。

```makefile
$(OBJECTS): %.o: %c
    $(CC) -c $(CFLAGS) $< -o $@
```

此规则与普通模式规则之间的唯一区别是初始 `$(OBJECTS)`：规范。这将规则限制为  `$(OBJECTS)` 变量中列出的文件。

这与模式规则非常相似。`$(OBJECTS)` 中的每个目标文件都与模式 `%.o` 匹配，并且提取了其词干。然后将词干替换为模式 `%.c`，以产生目标的依赖。如果目标模式不存在，make 将发出警告。

只要比通过后缀或其他模式标识目标文件更容易显式列出目标文件，请使用静态模式规则。

### 后缀规则

后缀规则是定义隐式规则的原始（和过时）的方法。由于其他版本的 make 可能不支持 GNU make 的模式规则语法，因此您仍然会在旨在多环境的 makefile 中看到后缀规则，所以能够阅读和理解该语法非常重要。为此，尽管为目标系统编译 GNU make 是使 makefile 具有可移植性的首选方法，但是在极少数情况下，您可能仍需要编写后缀规则。

后缀规则由一个或两个后缀组成，并被用作目标：

```makefile
.c.o:
    $(COMPILE.c) $(OUTPUT_OPTION) $<
```

这有点令人困惑，因为依赖后缀排在第一位，目标后缀排在第二位。该规则与以下目标和依赖相同：

```makefile
%.o: %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<
```

后缀规则通过删除目标后缀来形成文件的词干。它通过将目标后缀替换为依赖后缀来构成依赖。仅当两个后缀在已知后缀列表中时，make 才能识别后缀规则。

上面的后缀规则被称为双后缀规则，因为它包含两个后缀。也有单后缀规则。如你所想一个后缀规则仅包含一个后缀，即源文件的后缀。这些规则用于创建可执行文件，因为 Unix 可执行文件没有后缀：

```makefile
.p:
    $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

此规则从 Pascal 源文件生成可执行映像。这完全类似于模式规则：

```makefile
%: %.p
    $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

后缀列表是已知语法中最奇怪的部分。特殊目标 `.SUFFIXES` 用于设置已知后缀的列表。这是默认的 `.SUFFIXES` 定义的第一部分：

```makefile
.SUFFIXES: .out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l
```

您只需添加一个 `.SUFFIXES` 规则到您的 makefile 中，即可添加自己的后缀：

```makefile
.SUFFIXES: .pdf .fo .html .xml
```

如果要删除所有已知的后缀（因为它们会干扰您的特殊后缀），则无需指定任何依赖：

```makefile
.SUFFIXES:
```

您还可以使用命令行选项 `--no-builtin-rules (-r)`。

在本书的其余部分中，我们不会使用这种旧语法，因为 GNU make 的模式规则更清晰，更常规。

## 隐式规则数据库

GNU make 3.80 具有大约 90 个内置的隐式规则。隐式规则可以是模式规则，也可以是后缀规则（我们将在后面简要讨论）。有针对 `C`，`C++`，`Pascal`，`FORTRAN`，`ratfor`，`Modula`，`Texinfo`，`TEX`（包括 `Tangle` 和 `Weave` ），`Emacs` `Lisp`，`RCS` 和 `SCCS` 的内置模式规则。此外，还有支持这些语言的程序的规则，例如 `cpp`，`as`，`yacc`，`lex`，`tangle`，`weave` 和 `dvi` 工具。

如果您使用这些工具中的任何一个，则可能会在内置规则中找到大部分所需的工具。如果您使用的是 `Java` 或 `XML` 等不受支持的语言，则必须编写自己的规则。但请放心，您通常只需要一些规则即可支持一种语言，而且它们很容易编写。

要检查 make 中内置的规则数据库，请使用 `--print-data-base (-p)` 命令行选项。这将产生大约一千行输出。在版本和版权信息之后，make 会在每个变量定义之前打印其变量定义，并在注释中注明该定义的“来源”。例如，变量可以是环境变量，默认值，自动变量等。在变量之后，就是规则。 GNU make 使用的实际格式为：

```makefile
%: %.C
# commands to execute (built-in):
    $(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

对于由 makefile 定义的规则，注释将包括文件和定义规则的行：

```makefile
%.html: %.xml
# commands to execute (from `Makefile', line 168):
    $(XMLTO) $(XMLTO_FLAGS) html-nochunks $<
```

### 使用隐式规则

### 规则结构

### 源码控制的隐式规则

### 简单的帮助命令

## 特殊目标

## 依赖生成自动化

## 管理库

### 创建和更新库

### 使用库作为依赖

### 双冒号规则

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)