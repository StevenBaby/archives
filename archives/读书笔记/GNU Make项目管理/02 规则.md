# GNU Make 项目管理 第二章 规则

[annotation]: <id> (09443028-3ef7-4314-8998-5593c2b8c8c8)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 17:40:01)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make 项目管理)
[annotation]: <index> (2)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/09443028-3ef7-4314-8998-5593c2b8c8c8)

在上一章中，我们编写了一些规则来编译和链接我们的单词计数程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组文件。当要求更新目标时，如果任何先决条件文件比目标修改时间最近，make 将执行规则的命令脚本。由于一个规则的目标可以作为另一条规则的依赖来引用，因此目标和先决条件的集合形成了依赖关系链或图。构建并处理此依赖关系图以更新需要的目标是 make 的全部目的。

由于规则在 make 中是如此重要，因此存在许多不同种类的规则。与上一章中的规则一样，显式规则指出了要更新的特定目标，如果该目标的任何依赖已过时。这是您将要编写的最常见的规则类型。模式规则使用通配符而不是显式文件名。这样，只要需要更新与该模式匹配的目标文件，make 便可以应用该规则。隐式规则是在内置的规则数据库中找到的模式规则或后缀规则。具有内置的规则数据库使编写 makefile 更加容易，因为对于许多常见任务而言，他们已经知道文件类型，后缀和用于更新目标的程序。静态模式规则类似于常规模式规则，但它们仅适用于目标文件的特定列表。

GNU make 可以用作许多其他版本的 make 的替代，并包括一些专门用于兼容性的功能。后缀规则是编写一般规则的原始方法。 GNU make包含对后缀规则的支持，由于被更清晰，更通用的模式规则所取代，它们被认为已过时。

## 显式规则

您将编写的大多数规则都是将特定文件指定为目标和依赖的显式规则。一条规则可以有多个目标。这意味着每个目标都具有与其他目标相同的依赖。如果目标已过期，则将执行同一组操作来更新每个目标。例如：

```makefile
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```

这表明 `vpath.o` 和 `variable.o` 都依赖于同一组 C 头文件。该行与以下内容具有相同的作用：

```makefile
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```

这两个目标是独立处理的。如果任何一个目标文件相对于其任何依赖都过期（也就是说，任何头文件的修改时间都比该目标文件的更新时间晚），make 将通过执行与该规则关联的命令来更新该目标文件。

规则不必一次全部定义。每次 make 看到目标文件时，它都会将目标和依赖添加到依赖关系图中。如果在关系图中已经看到目标并且该目标已存在，则任何其他依赖都将附加到 make 的依赖关系图的目标文件条目中。在简单的情况下，这对于打断长行以提高 makefile 的可读性很有用：

```makefile
vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
```

在更复杂的情况下，依赖列表可以由管理方式非常不同的文件组成：

```makefile
# Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...

# Compile vpath.c with special flags.
vpath.o: vpath.c
    $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

...
# Include dependencies generated by a program.
include auto-generated-dependencies.d
```

第一条规则说，只要更新 `lexer.c` 就必须更新 `vpath.o` 目标（可能是因为生成 `lexer.c` 具有其他副作用）。该规则还可以确保在更新目标之前始终更新依赖。（请注意，规则具有双向性。在向前的方向上，规则表示如果 `lexer.c` 已更新，请执行操作以更新 `vpath.o`。在向后的方向上，规则表示如果需要 make 或使用 `vpath.o`，请首先确保lexer.c是最新的。）此规则可能放在管理 `lexer.c` 的规则附近，因此提醒开发人员这种微妙的关系。随后，将 `vpath.o` 的编译规则放在其他编译规则中。该规则的命令使用三个 make 变量。您会看到很多这样的东西，但是现在您只需要知道变量是 $ 符号后跟一个字符，还是 $ 符号后跟一对括号。 （我将在本章后面的内容中进行更多的解释，而在第三章中将进行详细的解释。）最后，`.o/.h` 依赖关系包含在 makefile 中，它是由外部程序管理的独立文件。

### 通配符

makfile 通常包含很长的文件列表。为了简化此过程，make 支持通配符。 make 的通配符与 **Bourne Shell (sh)** 的通配符相同：`~`，`*`，`?`，`[...]` 和 `[^...]` 。例如，`*.*` 扩展到包含句点的所有文件。一个问号代表任何单个字符，而 `[...]` 代表一个字符类别。要选择 **相反（否定）** 字符类，请使用 `[^...]`。

此外，波浪号 `~` 可以用来表示当前用户的主目录。`~` 后跟用户名代表该用户的主目录。

只要通配符出现在目标，依赖或命令脚本上下文中，通配符就会通过 make 自动展开。在其他情况下，通配符可以通过调用函数来显式扩展。通配符对于创建更具适应性的 makefile 非常有用。例如，您可以使用通配符 `*` 而不是显式列出程序中的所有文件（在更受控的环境中，使用通配符选择程序中的文件被认为是不好的做法，因为流氓源文件可能会意外地链接到程序中）：

```makefile
prog: *.c
    $(CC) -o $@ $^
```

但是，请务必注意通配符。如以下示例所示，很容易滥用它们：

```makefile
*.o: constants.h
```

目的很明确：所有目标文件都依赖于头文件 `constants.h`，但是请考虑如何在没有任何目标文件的干净目录中扩展它：

```makefile
: constants.h
```


这是一个合法的 make 表达式，不会自行产生错误，但也不会提供用户所需的依赖关系。实施此规则的正确方法是对源文件执行通配符（因为它们始终存在）并将其转换为目标文件列表。我们将在第四章中讨论 make 函数时，介绍这种技术。

最后，值得注意的是，当模式作为目标或依赖出现时，通配符扩展是由 make 执行的。但是，当模式出现在命令中时，扩展由子 shell 执行。这有时可能很重要，因为 make 会在读取 makefile 时立即扩展通配符，但是 shell 将在执行命令后更晚地扩展命令中的通配符。当完成许多复杂的文件操作时，两个通配符扩展可能会大不相同。

### 伪目标

### 空目标

## 变量

### 自动变量

## 使用 VPATH 和 vpath 查找文件

## 模式规则

### 模式

### 静态模式规则

### 后缀规则

## 隐式规则数据库

### 使用隐式规则

### 规则结构

### 源码控制的隐式规则

### 简单的帮助命令

## 特殊目标

## 依赖生成自动化

## 管理库

### 创建和更新库

### 使用库作为依赖

### 双冒号规则

## 参考资料

- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)