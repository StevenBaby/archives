# GNU Make项目管理 第一章 怎样写简单的 Makefile

[annotation]: <id> (5bddf3e8-f84d-4111-b8dc-9ff18943f299)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-17 23:47:31)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make项目管理)
[annotation]: <index> (1)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/5bddf3e8-f84d-4111-b8dc-9ff18943f299)


编程技巧通常遵循及其简单的流程，编辑源文件、编译源文件到可执行的形式，然后调试编译结果。尽管将源程序转换到可执行程序是常规操作，但是如果操作不当，程序员可能会浪费大量的时间来跟踪问题。大多开发者都经历过修改功能和运行新代码的挫败感，仅仅是发现刚才的改动无法解决某个bug。然后他们发现由于某些流程错误，例如重编译源码失败，链接失败，或重构建 jar 包失败，程序并没有执行他们修改的功能，此外，随着程序复杂度的增加这些简单的任务可能会随着开发不同版本的程序而变得越来越容易出错。也可能其他平台或者其他版本的库等。

**make** 程序旨在将源码编译成为可执行文件的日常工作自动化，与脚本相比 **make** 的优势在于，你可以给 **make** 指定程序对象之间的关系，而且通过这些关系和时间戳，可以准确地知道每次生成程序的时候哪些步骤需要重新做。使用此信息，**make** 还优化了构建程序的过程而避免了一些不必要的步骤。

GNU make （和其他一些变体）正是这样做的，**make** 定义了一种语言来描述代码、中间文件和可执行文件之间的关系。它还提供了一些功能：管理备用配置，实现规范的可复用的库，以及使用用户定义的宏来对过程参数化，简而言之，可以通过提供程序组件之间的路线图以及他们如何组织在一起的方式，将 **make** 视为开发流程的中心。

**make** 的规范文件通常保存在名为 **makefile** 的文件中，下面是一个 **makefile** 文件，用以构建 **hello, world** 程序：

```makefile
hello: hello.c
    gcc hello.c -o hello
```

要编译程序的话只需在你喜欢的 shell 中执行命令：

    make

这将导致 make 程序读取 makefile 文件来构建we文件中找到的第一个目标文件。

```sh
$ make
gcc hello.c -o hello
```

如果命令行参数中包含目标，那么将会更新该目标，如果命令行参数中没有给出目标，则使用文件中第一个目标，称为默认目标。

通常，默认目标在大多书的 makefile 中应该是构建一个程序，一般会引发很多步骤。通常程序得源码是不完整的，源码必须由一些工具来生成，比如 **flex** 或者 **bison**。然后源码将被编译成二进制目标文件 (C/C++ 生成 .o 文件，Java 生成 .class 文件)。再然后，对于 C/C++，将目标文件合在一起链接成为一个可执行文件（通常由编译器 gcc 调用）

改动任何一个源代码文件，然后重新执行 make 将会导致一些（通常不会是全部）命令重复出现，所以源码得改动会适当的编译到可执行文件中。makefile 规范文件描述了代码、中间文件和可执行文件之间的关系，以便 make 可以执行最小的必要工作来更新可执行文件。

所以 **make** 的核心价值在于其执行构建程序时的一系列复杂的必要命令的能力，而且尽可能地优化这些操作来减少 编辑-编译-调试 的开发周期中所需的时间。此外，**make** 足够灵活，可以在一个文件依赖于另一个文件的任何地方使用，比如，传统编程 C/C++ , Java, TEX, 数据库管理，等等。

## 目标和先决条件
 
## 参考资料

- Managing Projects with GNU Make