# GNU Make 项目管理 第六章 管理大项目

[annotation]: <id> (8bd85294-b86c-4947-a79a-f63038e72783)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 19:18:41)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make项目管理)
[annotation]: <index> (6)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/8bd85294-b86c-4947-a79a-f63038e72783)

什么样的项目才配称为大项目？对我而言，可能需要一个团队的开发者，可能需要在多种体系结构上运行，也可能有多种领域需要维护。当然，不是所有的大项目都满足以上所有要求。单一平台八万行代码级别的 C++ 的预发布版本同样也是大项目。但是软件不会永远停留在预发布版本。如果它是成功的，那么终将有人想让它运行在其他的平台。所以一段时间之后，大多数大型软件系统都十分相似。

大型软件系统通常通过将系统拆分多个主要的组件来简化复杂性。一般包括程序、库，或者二者皆有。这些组件通常保存在它们自己的目录中而且通过它们自己的 makefile 来管理。一种构建整个系统的方式是自顶向下对每个组件采用 makefile，调用 make 会以适当的顺序构建每个组件。这种方式叫做递归 make，因为顶层 makefile 调用对每个组件递归地调用 make。递归 make 是处理组件构建的常用技巧。

彼得·米勒（Peter Miller）在 1998 年给出了一些替代性建议，通过对每个组件的目录中包含的信息使用单独的 makefile，来避免递归 make 的很多问题。

一旦一个项目超出了构建组件的范围，最终会发现在管理构建中存在很大的组织问题。这里包括了项目开发中处理多版本、支持多平台、提供高效的访问源码和二进制文件，还有执行自动化构建。我们将在本章第二部分讨论这些问题。

## 递归 make

递归 make 背后的动机是简单的：make 在单个目录（或一小撮目录）下工作的特别好，但是当目录的数量多起来以后就变得复杂了。所以，我们可以通过在每一个目录写一个简单的，自包含的 makefile，然后用 make 来构建大项目。然后分别执行它们。我们可以使用一个脚本工具来完成这些步骤，但是，使用 make 本身更高效，特别是更高的级别同样会存在依赖。

例如，假设我们有一个 mp3 播放器程序，他可以在逻辑上分为几个组件：用户图形界面、解码器、和数据区管理工具。可分别表示成三个库文件：`libui.a`, `libcodec.a` 和 `libdb.a`。程序自身再将这些组件组合在一起。一种直接的这些组件到文件结构映射可能如下图所示：

![](./images/6-1.jpg)

更传统的层次将 程序主函数和 粘合在顶层目录而非子目录 `app/player`，我更喜欢将应用程序代码放在它自身的目录，来为顶层创建一个更加清洁的布局，这样允许系统的增长时添加额外的模块。例如，如果我们选择添加一个独立的目录程序，将来我们可以整齐的放在 `app/catalog` 目录下面。

如果每个目录 `lib/db`, `lib/codec`, `lib/ui` 和 `app.player` 都有自己的 `makefile`，然后下面是顶层 makefile 的工作是来调用它们。

```makefile
lib_codec := lib/codec
lib_db    := lib/db
lib_ui 	  := lib/ui
libraries := $(lib_ui) $(lib_db) $(lib_codec)
player 	  := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
	$(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

顶层 makefile  通过一条规则在每个子目录中 调用 make，该规则列出了子目录，并将其作为目标，然后执行 make。

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@
```

变量 `MAKE` 应该总是用于在 makefile 中调用 make. `MAKE` 变量由 make 识别，并设置为 make 的实际路径，因此所有递归调用都使用同一可执行文件。同样，使用命令行选项 `--touch(-t)`, `-just-print(-n)` 和 --question(-q) 时，将特别处理表含变量 `MAKE` 的行。我们将在本章后面的 命令行选项 中详细讨论。

目标目录如果在 `.PHONY` 标识，那么即使目标可能是最新的，规则也会触发。 `--directory (-C)` 选项将会在读 makefile 之前改变目标目录。

下面这个规则，尽管有点微妙，克服了与更直接的命令脚本相关的一些问题。

```makefile
all:
    for d in $(player) $(libraries); \
    do \
        $(MAKE) --directory=$$d; \
    done
```

这个命令脚本给父 make 传递错误时将会失败，而且不允许 make 并行执行多个子目录，我们将会在第十章讨论这个问题。 

在 make 计划执行依赖关系图时，目标的依赖彼此相互独立。此外，彼此之间没有依赖关系的目标也是独立的。例如，这些库与 `app/player` 目标或彼此之间没有继承关系。这意味着 make 在构建任何库之前，随时都可以构建 app/player。很明显，因为链接应用程序需要库，所以这将导致构建失败。为了解决这个问题，我们需要提供额外的依赖信息。

```makefile
$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

这里我们声明库子目录中的 makefile 必须在播放器目录的 makefile 执行之前被执行。类似的 `lib/ui` 代码需要 `lib/db` 和 `lib/codec` 库才能编译。这保证了任何生成代码的操作 (例如 yacc/lex 文件) 将在 ui 代码编译之前被生成。

在更新依赖时，还有一个更微妙的排序问题。与所有依赖项一样，更新顺序由对依赖关系图的分析确定。但是当目标的依赖在一行中列出时， GNU make 就会从左向右进行更新。例如：

```makefile
all: a b c
all: d e f
```

如果这里没有依赖关系需要考虑，这六个依赖可以以其他的顺序更新，（例如：d b a c e f），但是 GNU make 使用从左向右的顺序更新单行上的目标，所以更新顺序应为：**a b c d e f** 或者 **d e f a b c**。

尽管这个顺序时实现的偶然事件，但执行的顺序似乎时正确的，这样容易忘掉正确的顺序是一次偶然的意外，并且无法提供完整的依赖关系信息。最终，依赖分析将会依从于一种不同的顺序而导致错误。所以，如果某些目标必须以一种特殊的顺序来更新，需要在适当的条件下执行适当的命令。

当顶层 makefile 执行时，我们将看到：

```text
$ make
make --directory=lib/db
make[1]: Entering directory `/test/book/out/ch06-simple/lib/db'
Update db library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/book/out/ch06-simple/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/book/out/ch06-simple/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/book/out/ch06-simple/app/player'
Update player application...
make[1]: Leaving directory `/test/book/out/ch06-simple/app/player'
```

当 make 检测到调用其他递归 make 时，它将打开 `--print-directory (-w)` 选项，这样 make 会在进入目录和离开目录时打印消息。这个命令同样会在 `--directory (-C)` 选项打开时使用。make 变量 `MAKELEVEL` 的值，在每行打印时会包在中括号里。在这个简单的例子里，每个组件的 makefile 在更新组件时打印一个简单的信息。

### 命令行选项

递归 make 是一个非常简单的想法，很快就会变得复杂。完美的递归 make 实现的形为就像系统中的许多 makefile 是单个 makefile 一样。实现这种协调水平实际上是不可能的，因此必须做出妥协。当我们查看必须如何处理命令行选项时，这些细微的问题就变得更加清晰。

假设我们已经在 mp3 播放器的头文件中添加了注释。我们意识到，我们无需编译依赖于已修改头文件的所有目标。我们可以执行 `make --touch` 让相关文件的时间戳保持最新。通过在执行顶层 makefile 时，执行 `make --touch`，我们希望 make 可以 touch 子 make 中所有合适的文件。让我们看看它是怎么工作的。

通常，当 `--touch` 选项在命令行中时，正常的规则处理将被暂停。取而代之的是，遍历依赖关系图，并通过在目标上执行 `touch` 来使选定的目标以及那些未标记为 .PHONY 的依赖保持最新状态。由于我们的子目录被标为 `.PHONY` 因此通常将忽略它们（像普通文件一样 `touch` 毫无意义）。但是我们不希望这些目标被忽略，我们希望它们的命令脚本的已执行。要执行正确的操作， make 会使用 + 修饰符自动标记任何包含 MAKE 的行，这意味着 make 会运行子 make，而不管 `--touch` 选项。

当 make 运行子 make 时，它还必须安排 `--touch` 标志传递给子进程。通过 `MAKEFLAGS` 变量执行此操作。当启动 make 时，它自动将大多数命令行选项附加到 `MAKEFLAGS`，例外是选项是 `--directory (-C)`, `--file (-f)`, `--old-file (-o)` 和 `--newfile (-W)`。然后 `MAKEFLAGS` 将到处到环境变量中，由子 make 在启动时读取。

有了这个特殊支持，子 make 的行为通常会达到你想要的方式。`$(MAKE)` 的递归执行和应用于 `--touch (-t)` 的 `MAKEFLAGS` 的特殊处理，也应用于选项 `--just-print (-n)` 和 `--question (-q)`。

### 传递参数

You can explicitly override the environment for a specific assignment (even when the --environment-overrides option is used) with the override directive:

如前所述，变量通过环境变量传递给子 make 并使用 `export` 和 `unexport` 指令进行控制。通过环境变量传递的参数被视为默认值。但是任何赋值操作都会将其覆盖。使用选项 `--environment-overrides (-e)` 可以允许环境变量覆盖局部赋值。你可以使用 `override` 指令显式覆盖特定赋值（即使是使用 `--environment-overrides` 选项时，也可以）

```makefile
override TMPDIR = ~/tmp
```

如果命令行中定义的变量使用合法的 shell 语法，则会自动导出到环境中。如果变量仅使用字母，数字和下划线，则视为合法。命令行中的变量分配与命令行选项一起存储在 `MAKEFLAGS` 变量中。

### 错误处理

递归 make 出错时会发生什么？实际上，没有什么异常的，接收到错误状态的 make 以状态码 2 终止其处理过程。然后, 父 make 退出，将错误码传递到 递归 make 进程树上。如果在顶层 make 使用 `--keep-going (-k)` 选项，则该选项将照常传递给子 make。子 make 将正常的执行操作。跳过当前目标，然后找到不使用错误目标作为依赖的下一个目标。

例如，如果我们的 mp3 播放器程序在 `lib/db` 组件遇到了编译错误，`lib/db` make 将会退出，向顶层 make 返回错误码 2。如果我们使用了 `--keep-going (-k)` 选项，顶层 makefile 将会处理下一个与之无关的目标，`lib/codec`。当它完成该目标时，无论其状态如何，make 都将以状态 2 退出，因为 `lib/db` 的错误而导致无法处理其他的目标。

`--question (-q)` 选项的行为十分相似，如果某个目标不是最新的，这个选项将使 make 返回错误码 1，否则返回 0。当应用到生成文件树时，make 将开始递归执行 makefile，直到它可以确定项目是否时最新的。一旦发现过期文件，make 将终止当前活动然后展开递归。

### 构建其他目标

基本的构建目标对任何构建系统都是必不可少的，但是我们还需要依赖其他目标来支持。例如 `clean`, `install`, `print` 等等。由于这些是 `.PHONY` 目标，因此前面介绍的技术不能很好的工作。 

例如，这里有几个有问题的方式：

```makefile
clean: $(player) $(libraries)
    $(MAKE) --directory=$@ clean
```

或者 

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@ clean
```

第一个错误是因为依赖会触发 `$(player)`, `$(libraries)` makefile 中默认目标的构建。而不是 `clean` 目标。第二个错误是因为这些目标已经存在与不同的命令脚本中。

一种方法依赖于 shell 的 `for` 循环才能工作：

```makefile
clean:
    for d in $(player) $(libraries); \
    do \
        $(MAKE) --directory=$$f clean; \
    done
```

A for loop is not very satisfying for all the reasons described earlier, but it (and the preceding illegal example) points us to this solution:

对于如前所述的所有原因，`for` 循环并不是很令人满意，但是它（以及前面的错误案例）是我们找到了这种解决方法：

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@ $(TARGET)
```

By adding the variable $(TARGET) to the recursive make line and setting the TARGET variable on the make command line, we can add arbitrary goals to the sub-make:

通过添加变量 `$(TARGET)` 到递归 make 的命令行并且在 make 的命令行上设置 `TARGET` 变量，我们可以向子 make 添加任意目标。

```sh
$ make TARGET=clean
```

不幸的是，这并没有在顶层 makefile 调用 `$(TARGET)` 目标，常常是不需要的因为顶层 makefile 无事可做，但是，如果需要，我们可以添加一个受 `if` 保护的 make 调用。

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@ $(TARGET)
    $(if $(TARGET), $(MAKE) $(TARGET))
```

Now we can invoke the clean target (or any other target) by simply setting TARGET on the command line.

现在我们可以通过简单的在命令行设置 `TARGET` 来调用 clean 目标（或者任何其他目标）。

### 跨 Makefile 依赖

对 make 命令行和通过对环境变量进行通信的特殊支持表明，递归 make 已经经过调整，可以很好的工作。那么，前面提到的严重的复杂性有哪些呢？

分离 makefile 通过递归 `$(MAKE)` 命令得以连接，仅记录最表面的顶层连接，不幸的是，在某些目录中常常埋藏着微妙的依赖关系。

例如，假设 `db` 模块包含用于导入和导出音乐数据基于 yacc 的解析器。如果 `ui` 模块中 `ui.c` 文件包含 yacc 生成的头文件，则我们这里两个模块之间有依赖关系。如果对依赖处理更合理，则只要头文件更新之后，我们都需要重新编译 `ui` 模块。使用前面描述的自动化依赖生成技巧处理它并不难。但是如果 yacc 文件本身被修改怎么办？在这种情况下，运行 `ui` 的 makefile 时，正确的 makefile 将识别出必须先运行 yacc 才能生成解析器和头文件，才能编译 `ui.c`。在我们的递归 make 分解中，不会发生这种情况，因为运行 yacc 的规则和依赖项位于 `db` makefile 中，而不是 `ui` makefile 中。

这种情况下，我们能做的最好的事情就是确保在执行 `ui` makefile 之前始终执行 `db` makefile。此更高级别的依赖必须手动编码，在 makefile 的第一个版本中，我们意识到了这一点，但是，总的来说，这是一个非常困难的维护问题。在编写和修改代码时，顶层 makefile 将无法正确记录模块之间的依赖关系。

为了继续该实例，如果更新了 `db` 中的 yacc 语法，并且 `ui` makefile 在 `db` makefile 之前运行（通过直接执行而不是通过顶层 makefile 来执行），则 `ui` makefile 不知道其中存在未得到满足的依赖项。`db` makefile 和该 yacc 必须运行以更新头文件，取而代之的时，`ui` makefile 使用旧的 yacc 头文件编译器程序，如果已经定义了新符号并引用它们，则会报告编译错误。因此，递归 make 方法本质上比单个 makefile 更加脆弱。

当更广泛地使用代码生成器时，该问题会恶化。假设 RPC 存根生成器的头文件添加到 ui，并且在 `db` 引用之，现在有了相互引用互相对抗。为了解决这个问题，可能需要访问 `db` 来生成 yacc 头，然后访问 `ui` 来生成 RPC 存根，然后访问 `db` 编译文件，最后访问 `ui` 来完成编译过程。创建和编译项目源代码所需的通过次数取决于代码的结构以及用于创建项目的工具。这种相互引用在复杂系统中很常见。

现实世界中 makefile 文件中的标准解决方案通常简单粗暴，为确保所有文件都是最新的，当对顶层 makefile 发出命令时，将执行每个 makefile。请注意，这正式我们 mp3 播放器 makefile 所作的。当运行顶层 makefile 时，四个子生成文件中的每一个都将无条件运行。在复杂的情况下，makefile 会重复运行以确保首先生成所有代码然后进行编译。通常，这种迭代执行有点浪费时间，但有时是必需的。

### 避免重复代码

我们的程序目录包括三个库，这些库的 makefile 非常相似。这是有道理的，因为这三个库在最终的应用程序具有不同的用途，但是都用相似的命令构建。这种分解是大型项目的典型现象，会导致许多类似的 makefile 和很多代码重复。

So we would like to avoid code duplication in our makefiles as much as possible. This is most easily accomplished by moving the common pieces of a makefile into a common include file.

代码重复是不好的，即便是 makefile 的代码也是如此。它将增加软件的维护成本并且可能导致更多的 bug。它同样导致理解算法和识别代码中细微的变化变得更加困难。所以我们要尽可能在我们的项目中避免代码重复。通过将 makefile 的公共部分移到公共的 include 文件中，可以很容易的实现这一点。

例如，编码器和解码器的 makefile 包含：

```makefile
lib_codec := libcodec.a
sources := codec.c
objects := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))

include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

all: $(lib_codec)

$(lib_codec): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean

clean:
$(RM) $(lib_codec) $(objects) $(dependencies)

ifneq "$(MAKECMDGOALS)" "clean"
    include $(dependencies)
endif

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    sed 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    mv $@.tmp $@
```

Almost all of this code is duplicated in the db and ui makefiles. The only lines that change for each library are the name of the library itself and the source files the library contains. When duplicate code is moved into common.mk, we can pare this makefile down to:

几乎所有的代码重复都在 `db` 和 `ui` 的 makefile 中。对每个库唯一的代码变化是库本身的名字以及库包含的源文件。当重复的代码移到 common.mk 中时，我们可以将此 makefile 缩减为：

```makefile
library := libcodec.a
sources := codec.c
include ../../common.mk
```

看看我们已移至单个共享的包含文件中的内容：

```makefile
MV := mv -f
RM := rm -f
SED := sed

objects := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))
include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY: library
library: $(library)

$(library): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
    $(RM) $(objects) $(program) $(library) $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
-include $(dependencies)
endif

%.c %.h: %.y
    $(YACC.y) --defines $<
    $(MV) y.tab.c $*.c
    $(MV) y.tab.h $*.h

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    $(SED) 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    $(MV) $@.tmp $@
```

变量 `include_dirs` 之前在每个 makefile 中都不同，现在在每个 makefile 中都相同。因为我们重新设计了用于包含的头文件路径，以使得所有库都使用相同的包含路径。

common.mk 文件甚至包含库包含文件的默认目标。原始 makefile 使用默认目标 all。这将导致非库文件的问题，该库文件需要为其默认目标指定一组不同的依赖。因此，共享代码版本使用库的默认目标。

注意，由于该公共文件包含目标，因此必须将其包含在非库 makefile 的默认目标之后。还要注意 clean 命令脚本应用了变量 program, library 和 extra_clean。对于库 makefile，程序变量为空。对于程序 makefile 库变量为空。extra_clean 变量是专门为 db makefile 添加的。该 makefile 使用该变量表示 yacc 生成的代码。这个 makefile 是：

```makefile
library := libdb.a
sources := scanner.c playlist.c
extra_clean := $(sources) playlist.h

.SECONDARY: playlist.c playlist.h scanner.c

include ../../common.mk
```

使用这些技巧，代码重复可以保持最小化，随着更多的 makefile 代码移到公共 makefile，它将演变成整个项目的通用 makefile。make 变量和用户自定义的函数用作自定义的点，从而允许为每个目录修改通用 makefile.

## 非递归 make

## 大项目组件

### 需求

## 文件系统层次

## 自动构建和测试

## 参考资料

- [Example](https://resources.oreilly.com/examples/9780596006105)
- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)