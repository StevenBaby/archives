# GNU Make 项目管理 第六章 管理大项目

[annotation]: <id> (8bd85294-b86c-4947-a79a-f63038e72783)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 19:18:41)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make项目管理)
[annotation]: <index> (6)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/8bd85294-b86c-4947-a79a-f63038e72783)

什么样的项目才配称为大项目？对我而言，可能需要一个团队的开发者，可能需要在多种体系结构上运行，也可能有多种领域需要维护。当然，不是所有的大项目都满足以上所有要求。单一平台八万行代码级别的 C++ 的预发布版本同样也是大项目。但是软件不会永远停留在预发布版本。如果它是成功的，那么终将有人想让它运行在其他的平台。所以一段时间之后，大多数大型软件系统都十分相似。

大型软件系统通常通过将系统拆分多个主要的组件来简化复杂性。一般包括程序、库，或者二者皆有。这些组件通常保存在它们自己的目录中而且通过它们自己的 makefile 来管理。一种构建整个系统的方式是自顶向下对每个组件采用 makefile，调用 make 会以适当的顺序构建每个组件。这种方式叫做递归 make，因为顶层 makefile 调用对每个组件递归地调用 make。递归 make 是处理组件构建的常用技巧。

彼得·米勒（Peter Miller）在 1998 年给出了一些替代性建议，通过对每个组件的目录中包含的信息使用单独的 makefile，来避免递归 make 的很多问题。

一旦一个项目超出了构建组件的范围，最终会发现在管理构建中存在很大的组织问题。这里包括了项目开发中处理多版本、支持多平台、提供高效的访问源码和二进制文件，还有执行自动化构建。我们将在本章第二部分讨论这些问题。

## 递归 make

递归 make 背后的动机是简单的：make 在单个目录（或一小撮目录）下工作的特别好，但是当目录的数量多起来以后就变得复杂了。所以，我们可以通过在每一个目录写一个简单的，自包含的 makefile，然后用 make 来构建大项目。然后分别执行它们。我们可以使用一个脚本工具来完成这些步骤，但是，使用 make 本身更高效，特别是更高的级别同样会存在依赖。

例如，假设我们有一个 mp3 播放器程序，他可以在逻辑上分为几个组件：用户图形界面、解码器、和数据区管理工具。可分别表示成三个库文件：`libui.a`, `libcodec.a` 和 `libdb.a`。程序自身再将这些组件组合在一起。一种直接的这些组件到文件结构映射可能如下图所示：

![](./images/6-1.jpg)

更传统的层次将 程序主函数和 粘合在顶层目录而非子目录 `app/player`，我更喜欢将应用程序代码放在它自身的目录，来为顶层创建一个更加清洁的布局，这样允许系统的增长时添加额外的模块。例如，如果我们选择添加一个独立的目录程序，将来我们可以整齐的放在 `app/catalog` 目录下面。

如果每个目录 `lib/db`, `lib/codec`, `lib/ui` 和 `app.player` 都有自己的 `makefile`，然后下面是顶层 makefile 的工作是来调用它们。

```makefile
lib_codec := lib/codec
lib_db    := lib/db
lib_ui 	  := lib/ui
libraries := $(lib_ui) $(lib_db) $(lib_codec)
player 	  := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
	$(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

顶层 makefile  通过一条规则在每个子目录中 调用 make，该规则列出了子目录，并将其作为目标，然后执行 make。

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@
```

变量 `MAKE` 应该总是用于在 makefile 中调用 make. `MAKE` 变量由 make 识别，并设置为 make 的实际路径，因此所有递归调用都使用同一可执行文件。同样，使用命令行选项 `--touch(-t)`, `-just-print(-n)` 和 --question(-q) 时，将特别处理表含变量 `MAKE` 的行。我们将在本章后面的 命令行选项 中详细讨论。

目标目录如果在 `.PHONY` 标识，那么即使目标可能是最新的，规则也会触发。 `--directory (-C)` 选项将会在读 makefile 之前改变目标目录。

下面这个规则，尽管有点微妙，克服了与更直接的命令脚本相关的一些问题。

```makefile
all:
    for d in $(player) $(libraries); \
    do \
        $(MAKE) --directory=$$d; \
    done
```

这个命令脚本给父 make 传递错误时将会失败，而且不允许 make 并行执行多个子目录，我们将会在第十章讨论这个问题。 

在 make 计划执行依赖关系图时，目标的依赖彼此相互独立。此外，彼此之间没有依赖关系的目标也是独立的。例如，这些库与 `app/player` 目标或彼此之间没有继承关系。这意味着 make 在构建任何库之前，随时都可以构建 app/player。很明显，因为链接应用程序需要库，所以这将导致构建失败。为了解决这个问题，我们需要提供额外的依赖信息。

```makefile
$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

这里我们声明库子目录中的 makefile 必须在播放器目录的 makefile 执行之前被执行。类似的 `lib/ui` 代码需要 `lib/db` 和 `lib/codec` 库才能编译。这保证了任何生成代码的操作 (例如 yacc/lex 文件) 将在 ui 代码编译之前被生成。

在更新依赖时，还有一个更微妙的排序问题。与所有依赖项一样，更新顺序由对依赖关系图的分析确定。但是当目标的依赖在一行中列出时， GNU make 就会从左向右进行更新。例如：

```makefile
all: a b c
all: d e f
```

如果这里没有依赖关系需要考虑，这六个依赖可以以其他的顺序更新，（例如：d b a c e f），但是 GNU make 使用从左向右的顺序更新单行上的目标，所以更新顺序应为：**a b c d e f** 或者 **d e f a b c**。

尽管这个顺序时实现的偶然事件，但执行的顺序似乎时正确的，这样容易忘掉正确的顺序是一次偶然的意外，并且无法提供完整的依赖关系信息。最终，依赖分析将会依从于一种不同的顺序而导致错误。所以，如果某些目标必须以一种特殊的顺序来更新，需要在适当的条件下执行适当的命令。

当顶层 makefile 执行时，我们将看到：

```text
$ make
make --directory=lib/db
make[1]: Entering directory `/test/book/out/ch06-simple/lib/db'
Update db library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/book/out/ch06-simple/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/book/out/ch06-simple/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/book/out/ch06-simple/app/player'
Update player application...
make[1]: Leaving directory `/test/book/out/ch06-simple/app/player'
```

当 make 检测到调用其他递归 make 时，它将打开 `--print-directory (-w)` 选项，这样 make 会在进入目录和离开目录时打印消息。这个命令同样会在 `--directory (-C)` 选项打开时使用。make 变量 `MAKELEVEL` 的值，在每行打印时会包在中括号里。在这个简单的例子里，每个组件的 makefile 在更新组件时打印一个简单的信息。

### 命令行选项

递归 make 是一个非常简单的想法，很快就会变得复杂。完美的递归 make 实现的形为就像系统中的许多 makefile 是单个 makefile 一样。实现这种协调水平实际上是不可能的，因此必须做出妥协。当我们查看必须如何处理命令行选项时，这些细微的问题就变得更加清晰。

假设我们已经在 mp3 播放器的头文件中添加了注释。我们意识到，我们无需编译依赖于已修改头文件的所有目标。我们可以执行 `make --touch` 让相关文件的时间戳保持最新。通过在执行顶层 makefile 时，执行 `make --touch`，我们希望 make 可以 touch 子 make 中所有合适的文件。让我们看看它是怎么工作的。

通常，当 `--touch` 选项在命令行中时，正常的规则处理将被暂停。取而代之的是，遍历依赖关系图，并通过在目标上执行 `touch` 来使选定的目标以及那些未标记为 .PHONY 的依赖保持最新状态。由于我们的子目录被标为 `.PHONY` 因此通常将忽略它们（像普通文件一样 `touch` 毫无意义）。但是我们不希望这些目标被忽略，我们希望它们的命令脚本的已执行。要执行正确的操作， make 会使用 + 修饰符自动标记任何包含 MAKE 的行，这意味着 make 会运行子 make，而不管 `--touch` 选项。

当 make 运行子 make 时，它还必须安排 `--touch` 标志传递给子进程。通过 `MAKEFLAGS` 变量执行此操作。当启动 make 时，它自动将大多数命令行选项附加到 `MAKEFLAGS`，例外是选项是 `--directory (-C)`, `--file (-f)`, `--old-file (-o)` 和 `--newfile (-W)`。然后 `MAKEFLAGS` 将到处到环境变量中，由子 make 在启动时读取。

有了这个特殊支持，子 make 的行为通常会达到你想要的方式。`$(MAKE)` 的递归执行和应用于 `--touch (-t)` 的 `MAKEFLAGS` 的特殊处理，也应用于选项 `--just-print (-n)` 和 `--question (-q)`。

### 传递参数

You can explicitly override the environment for a specific assignment (even when the --environment-overrides option is used) with the override directive:

如前所述，变量通过环境变量传递给子 make 并使用 `export` 和 `unexport` 指令进行控制。通过环境变量传递的参数被视为默认值。但是任何赋值操作都会将其覆盖。使用选项 `--environment-overrides (-e)` 可以允许环境变量覆盖局部赋值。你可以使用 `override` 指令显式覆盖特定赋值（即使是使用 `--environment-overrides` 选项时，也可以）

```makefile
override TMPDIR = ~/tmp
```

如果命令行中定义的变量使用合法的 shell 语法，则会自动导出到环境中。如果变量仅使用字母，数字和下划线，则视为合法。命令行中的变量分配与命令行选项一起存储在 `MAKEFLAGS` 变量中。

### 错误处理



### 构建其他目标



### 跨 Makefile 依赖

对 make 命令行和通过对环境变量进行通信的特殊支持表明，递归 make 已经经过调整，可以很好的工作。那么，前面提到的严重的复杂性有哪些呢？

### 避免重复代码

我们的程序目录包括三个库，这些库的 makefile 非常相似。这是有道理的，因为这三个库在最终的应用程序具有不同的用途，但是都用相似的命令构建。这种分解是大型项目的典型现象，会导致许多类似的 makefile 和很多代码重复。

So we would like to avoid code duplication in our makefiles as much as possible. This is most easily accomplished by moving the common pieces of a makefile into a common include file.

代码重复是不好的，即便是 makefile 的代码也是如此。它将增加软件的维护成本并且可能导致更多的 bug。它同样导致理解算法和识别代码中细微的变化变得更加困难。所以我们要尽可能在我们的项目中避免代码重复。通过将 makefile 的公共部分移到公共的 include 文件中，可以很容易的实现这一点。

例如，编码器和解码器的 makefile 包含：

```makefile
lib_codec := libcodec.a
sources := codec.c
objects := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))

include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

all: $(lib_codec)

$(lib_codec): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean

clean:
$(RM) $(lib_codec) $(objects) $(dependencies)

ifneq "$(MAKECMDGOALS)" "clean"
    include $(dependencies)
endif

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    sed 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    mv $@.tmp $@
```

Almost all of this code is duplicated in the db and ui makefiles. The only lines that change for each library are the name of the library itself and the source files the library contains. When duplicate code is moved into common.mk, we can pare this makefile down to:

几乎所有的代码重复都在 `db` 和 `ui` 的 makefile 中。对每个库唯一的代码变化是库本身的名字以及库包含的源文件。当重复的代码移到 common.mk 中时，我们可以将此 makefile 缩减为：

```makefile
library := libcodec.a
sources := codec.c
include ../../common.mk
```

看看我们已移至单个共享的包含文件中的内容：

```makefile
MV := mv -f
RM := rm -f
SED := sed

objects := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))
include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY: library
library: $(library)

$(library): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
    $(RM) $(objects) $(program) $(library) $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
-include $(dependencies)
endif

%.c %.h: %.y
    $(YACC.y) --defines $<
    $(MV) y.tab.c $*.c
    $(MV) y.tab.h $*.h

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    $(SED) 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    $(MV) $@.tmp $@
```

变量 `include_dirs` 之前在每个 makefile 中都不同，现在在每个 makefile 中都相同。因为我们重新设计了用于包含的头文件路径，以使得所有库都使用相同的包含路径。

common.mk 文件甚至包含库包含文件的默认目标。原始 makefile 使用默认目标 all。这将导致非库文件的问题，该库文件需要为其默认目标指定一组不同的依赖。因此，共享代码版本使用库的默认目标。

注意，由于该公共文件包含目标，因此必须将其包含在非库 makefile 的默认目标之后。还要注意 clean 命令脚本应用了变量 program, library 和 extra_clean。对于库 makefile，程序变量为空。对于程序 makefile 库变量为空。extra_clean 变量是专门为 db makefile 添加的。该 makefile 使用该变量表示 yacc 生成的代码。这个 makefile 是：

```makefile
library := libdb.a
sources := scanner.c playlist.c
extra_clean := $(sources) playlist.h

.SECONDARY: playlist.c playlist.h scanner.c

include ../../common.mk
```

使用这些技巧，代码重复可以保持最小化，随着更多的 makefile 代码移到公共 makefile，它将演变成整个项目的通用 makefile。make 变量和用户自定义的函数用作自定义的点，从而允许为每个目录修改通用 makefile.

## 非递归 make

## 大项目组件

### 需求

## 文件系统层次

## 自动构建和测试

## 参考资料

- [Example](https://resources.oreilly.com/examples/9780596006105)
- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)