# GNU Make 项目管理 第六章 管理大项目

[annotation]: <id> (8bd85294-b86c-4947-a79a-f63038e72783)
[annotation]: <status> (public)
[annotation]: <create_time> (2021-04-18 19:18:41)
[annotation]: <category> (读书笔记)
[annotation]: <tags> (Make|Makefile|GNU)
[annotation]: <topic> (GNU Make项目管理)
[annotation]: <index> (6)
[annotation]: <comments> (true)
[annotation]: <url> (http://blog.ccyg.studio/article/8bd85294-b86c-4947-a79a-f63038e72783)

什么样的项目才配称为大项目？对我而言，可能需要一个团队的开发者，可能需要在多种体系结构上运行，也可能有多种领域需要维护。当然，不是所有的大项目都满足以上所有要求。单一平台八万行代码级别的 C++ 的预发布版本同样也是大项目。但是软件不会永远停留在预发布版本。如果它是成功的，那么终将有人想让它运行在其他的平台。所以一段时间之后，大多数大型软件系统都十分相似。

大型软件系统通常通过将系统拆分多个主要的组件来简化复杂性。一般包括程序、库，或者二者皆有。这些组件通常保存在它们自己的目录中而且通过它们自己的 makefile 来管理。一种构建整个系统的方式是自顶向下对每个组件采用 makefile，调用 make 会以适当的顺序构建每个组件。这种方式叫做递归 make，因为顶层 makefile 调用对每个组件递归地调用 make。递归 make 是处理组件构建的常用技巧。

彼得·米勒（Peter Miller）在 1998 年给出了一些替代性建议，通过对每个组件的目录中包含的信息使用单独的 makefile，来避免递归 make 的很多问题。

一旦一个项目超出了构建组件的范围，最终会发现在管理构建中存在很大的组织问题。这里包括了项目开发中处理多版本、支持多平台、提供高效的访问源码和二进制文件，还有执行自动化构建。我们将在本章第二部分讨论这些问题。

## 递归 make

递归 make 背后的动机是简单的：make 在单个目录（或一小撮目录）下工作的特别好，但是当目录的数量多起来以后就变得复杂了。所以，我们可以通过在每一个目录写一个简单的，自包含的 makefile，然后用 make 来构建大项目。然后分别执行它们。我们可以使用一个脚本工具来完成这些步骤，但是，使用 make 本身更高效，特别是更高的级别同样会存在依赖。

例如，假设我们有一个 mp3 播放器程序，他可以在逻辑上分为几个组件：用户图形界面、解码器、和数据区管理工具。可分别表示成三个库文件：`libui.a`, `libcodec.a` 和 `libdb.a`。程序自身再将这些组件组合在一起。一种直接的这些组件到文件结构映射可能如下图所示：

![](./images/6-1.jpg)

更传统的层次将 程序主函数和 粘合在顶层目录而非子目录 `app/player`，我更喜欢将应用程序代码放在它自身的目录，来为顶层创建一个更加清洁的布局，这样允许系统的增长时添加额外的模块。例如，如果我们选择添加一个独立的目录程序，将来我们可以整齐的放在 `app/catalog` 目录下面。

如果每个目录 `lib/db`, `lib/codec`, `lib/ui` 和 `app.player` 都有自己的 `makefile`，然后下面是顶层 makefile 的工作是来调用它们。

```makefile
lib_codec := lib/codec
lib_db    := lib/db
lib_ui 	  := lib/ui
libraries := $(lib_ui) $(lib_db) $(lib_codec)
player 	  := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
	$(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

顶层 makefile  通过一条规则在每个子目录中 调用 make，该规则列出了子目录，并将其作为目标，然后执行 make。

```makefile
$(player) $(libraries):
    $(MAKE) --directory=$@
```

变量 `MAKE` 应该总是用于在 makefile 中调用 make. `MAKE` 变量由 make 识别，并设置为 make 的实际路径，因此所有递归调用都使用同一可执行文件。同样，使用命令行选项 `--touch(-t)`, `-just-print(-n)` 和 --question(-q) 时，将特别处理表含变量 `MAKE` 的行。我们将在本章后面的 命令行选项 中详细讨论。

目标目录如果在 `.PHONY` 标识，那么即使目标可能是最新的，规则也会触发。 `--directory (-C)` 选项将会在读 makefile 之前改变目标目录。

下面这个规则，尽管有点微妙，克服了与更直接的命令脚本相关的一些问题。

```makefile
all:
    for d in $(player) $(libraries); \
    do \
        $(MAKE) --directory=$$d; \
    done
```

这个命令脚本给父 make 传递错误时将会失败，而且不允许 make 并行执行多个子目录，我们将会在第十章讨论这个问题。 

在 make 计划执行依赖关系图时，目标的依赖彼此相互独立。此外，彼此之间没有依赖关系的目标也是独立的。例如，这些库与 `app/player` 目标或彼此之间没有继承关系。这意味着 make 在构建任何库之前，随时都可以构建 app/player。很明显，因为链接应用程序需要库，所以这将导致构建失败。为了解决这个问题，我们需要提供额外的依赖信息。

```makefile
$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
```

这里我们声明库子目录中的 makefile 必须在播放器目录的 makefile 执行之前被执行。类似的 `lib/ui` 代码需要 `lib/db` 和 `lib/codec` 库才能编译。这保证了任何生成代码的操作 (例如 yacc/lex 文件) 将在 ui 代码编译之前被生成。

在更新依赖时，还有一个更微妙的排序问题。与所有依赖项一样，更新顺序由对依赖关系图的分析确定。但是当目标的依赖在一行中列出时， GNU make 就会从左向右进行更新。例如：

```makefile
all: a b c
all: d e f
```

如果这里没有依赖关系需要考虑，这六个依赖可以以其他的顺序更新，（例如：d b a c e f），但是 GNU make 使用从左向右的顺序更新单行上的目标，所以更新顺序应为：**a b c d e f** 或者 **d e f a b c**。

尽管这个顺序时实现的偶然事件，但执行的顺序似乎时正确的，这样容易忘掉正确的顺序是一次偶然的意外，并且无法提供完整的依赖关系信息。最终，依赖分析将会依从于一种不同的顺序而导致错误。所以，如果某些目标必须以一种特殊的顺序来更新，需要在适当的条件下执行适当的命令。

当顶层 makefile 执行时，我们将看到：

```text
$ make
make --directory=lib/db
make[1]: Entering directory `/test/book/out/ch06-simple/lib/db'
Update db library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/book/out/ch06-simple/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/book/out/ch06-simple/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/book/out/ch06-simple/app/player'
Update player application...
make[1]: Leaving directory `/test/book/out/ch06-simple/app/player'
```

当 make 检测到调用其他递归 make 时，它将打开 `--print-directory (-w)` 选项，这样 make 会在进入目录和离开目录时打印消息。这个命令同样会在 `--directory (-C)` 选项打开时使用。make 变量 `MAKELEVEL` 的值，在每行打印时会包在中括号里。在这个简单的例子里，每个组件的 makefile 在更新组件时打印一个简单的信息。

### 命令行选项

### 传递参数

### 错误处理

### 构建其他目标

### 跨 Makefile 依赖

### 避免重复代码

## 非递归 make

## 大项目组件

### 需求

## 文件系统层次

## 自动构建和测试

## 参考资料

- [Example](https://resources.oreilly.com/examples/9780596006105)
- [Managing Projects with GNU Make](https://book.douban.com/subject/1850994/)