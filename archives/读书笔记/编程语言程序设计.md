# 编程语言程序设计

[annotation]: [id] (d8df2fd4-57a7-4b7c-9e19-75b2c0d2c8f2)
[annotation]: [status] (public)
[annotation]: [create_time] (2021-04-28 11:37:52)
[annotation]: [category] (计算机技术)
[annotation]: [tags] (汇编语言)
[annotation]: [comments] (false)
[annotation]: [url] (http://blog.ccyg.studio/article/d8df2fd4-57a7-4b7c-9e19-75b2c0d2c8f2)

## 什么是汇编语言

### 处理器指令

IA-32 指令码格式由四部分组成：

- 可选指令前缀
- 指令码
- 可选指令修改器
- 可选数据元素

![assembly-01.jpg](images/assembly-01.jpg)

#### 指令码

指令码是指令格式中必须提供的，指示处理器应该执行什么功能或者任务。

指令码的长度为 1 ~ 3 字节不等，例如 `OF A2` 表示了 `cupid` 指令，执行该指令时，处理器会把当前微处理器的信息存储到不同的寄存器。

#### 指令前缀

指令前缀可以包含 1 ~ 4 个字节的信息，来修改指令码的行为。指令前缀可分为四类：

- 锁前缀和重复前缀
- 段重写前缀和分支提示前缀
- 操作数大小前缀
- 地址大小前缀

每一类在前缀中只能只能用一次来修改指令码，或者说描述指令码。

锁前缀指示任何共享内存区域将被该指令排他性的使用。这对于多处理器和混合多线程系统特别重要。

重复前缀用于指示重复的功能，通常用于操作字符串。

段重写前缀指示指令可以重写预定义的段寄存器。

分支提示前缀尝试给处理器一些线索，用于指示条件转义指令的时候，最可能跳转的分支，常用于分支预测硬件。

操作数大小前缀用于提示处理器，当前操作码是 16 位 还是 32 位的。可以帮助处理器使用大操作数，和加速数据赋值到寄存器。

地址大小签注提示处理器使用的是那种大小的内存地址，每种大小都可以被设置为程序的默认大小，前缀可用于临时修改该大小。

#### 修改器

一些指令码需要额外的修改器来定义什么寄存器或者内存地址参与其中。修改器包含三个不同的值。

- 地址格式指示字节
- SIB 字节
- 1,2 或 4 个地址位移字节

### 汇编语言

汇编语言程序由三部分来定义程序的操作：

- 操作码助记符
- 数据段
- 汇编指令

#### 操作码助记符

例如：指令码的样例：

```
55
89 E5
83 EC 08
C7 45 FC 01 00 00 00
83 EC 0C
6A 00
E8 D1 FE FF FF
```

可以重写成为：

```s
push %ebp
mov %esp, %ebp
sub $0x8, %esp
movl $0x1, -4(%ebp)
sub $0xc, %esp
push $0x0
call 8048348
```

## IA-32 平台

使用汇编语言只是为了在应用中探索处理器的底层特性。来理解程序怎样才能尽可能的高效。

### 控制单元

处理器的核心是控制单元，主要的目的是控制处理器中什么时候该做什么，处理器运行的时候指令必须从内存中加载到处理器中进行处理，那么控制单元有四个基础功能：

- 从内存读取指令
- 解码指令操作
- 如果需要从内存读取数据
- 如果需要将处理结果写入内存

指令指针指示下一个需要处理的指令，指令解码器用于将指令翻译成微指令，微指令用来控制处理器芯片上的信号，一般而言，微指令将输出寄存器的三态门控制端置为高电平，使得寄存器（内部一般为D边沿触发器）中的数据流入片内总线，另一方面微指令还控制另一寄存器的写控制端，使得总线上的数据写入另一个寄存器。

为了加速处理器的速度，现代处理器一般会有更加高级的手段，比如 Intel NetBurst 控制器技术，有如下的特性：

- 预取指和译码
- 分支预测
- 乱序执行
- 指令引退

#### 预取指令和译码流水线

由于取指令需要操作内存，所以执行指令一般来说要比取指令快；这样的话就可能出现积压，所以预取指令就登场了。

为了支持预取指令，CPU中需要一个特殊的存储区域来存放取出的指令。可以让处理器简单而快速的访问数据，然后流水线就登场了。缓存(cache)的存取速度一般要比内存快得多。

流水线在CPU中创建了一撮内存的缓存，，里面存储了预先取出的指令和数据，当执行单元可以执行下一条指令的时候，流水线中已经准备好了指令，于是可以快速的执行。

IA-32 平台通过多级 cache 实现流水线，第一级缓存 (L1) 尝试预先从内存中取出指令和数据。

当然，一个问题是无法保证程序按照顺序执行指令，如果指令指针因逻辑分支转移到了其他的地方，那么整条流水线的数据就没用了，需要清空还需要重新注入流水线。

为了解决这个问题，第二级缓存（L2）登场，第二级缓存同样保存指令和数据，当逻辑跳转到另一个分支时，第二级缓存还保存着相关的指令和数据，如果程序逻辑再次跳转回原来的分支，那么第二级缓存就派上用场了。

尽管汇编语言无法访问缓存中的指令和数据，但直到他们是如何工作的同样有用。尽量减少分支的使用，可以帮助加速程序的执行速度。

#### 分支预测单元

为了解决转移指令后的流水线重置，有了分支预测，也就是说尽可能地让流水线中分支命中，而避免清空流水线。

特殊的统计和分析算法，决定了哪个分支最可能被执行，然后在流水线中载入相关地指令和数据。

奔腾 4 处理器有以下几种方式实现分支预测：

- 深分支预测
- 动态数据流分析
- 推测执行

**深分支预测** 让处理器可以尝试译码多个分支，同样，统计算法预测哪个分支最可能被执行，尽管这个技术很有用，但也不是万无一失的。

**动态数据流分析** 执行实时数据流分析，如果必要的话，指令将被乱序执行，任何指令都可能在等待数据的时候被执行。

**推测执行** 可以让处理器确定分支中较远的代码，然后尝试处理这些指令，同样使用乱序执行引擎。


#### 乱序执行引擎

乱序执行引擎中有以下几部分：

- 分配器
- 寄存器重命名
- 微操作调度器

分配器用来提前分配好缓存空间

寄存器重命名，分配逻辑寄存器代替通用寄存器。可以用于重命名的寄存器有 128 个。

位操作调度器，向退役单元(Retirement Unit) 发送微操作，在保持程序依赖的时候，微操作调度器使用两个对列，一个队列保存请求内存访问的微操作，一个队列保存没有访问内存的微操作。队列与分发端口相关联，不同类型的处理器可能包含不同的分发端口，分发端口向退役单元发送微操作。

####  退役单元（Retirement Unit）

退役单元保证乱序执行的指令处理的数据和正常执行的指令是一致的。

### 执行单元

一个处理器可能包含多个执行单元，来同时执行多个指令。

浮点执行单元包含 MMX 和 SSE 支持

### 寄存器

- 通用寄存器
- 段寄存器
- 指令指针寄存器
- 浮点数数据寄存器
- 控制寄存器
- 调试寄存器

#### 通用寄存器

| 寄存器 | 描述               |
| ------ | ------------------ |
| EAX    | 累加结果数据       |
| EBX    | 数据段数据指针     |
| ECX    | 字符串和循环计数器 |
| EDX    | I/O 指针           |
| EDI    | 目的数据指针       |
| ESI    | 源数据指针         |
| ESP    | 栈指针             |
| EBP    | 栈数据指针         |

EAX / EBX / ECX / EDX 四个寄存器可以拆分成 16位，8位，来访问。

#### 段寄存器

段寄存器与内存地址相关联，IA-32 处理器有几种不同的方法来访问内存：


- 平坦内存模型
- 段内存模型
- 实地址模式

平坦模型将所有系统内存连续表示成一个段，所有数据、栈，代码都存储在相同的内存空间。每个内存地址通过特定的地址来访问，叫做线性地址。

段内存模型，将内存分为独立的几段，依赖于段寄存器中的指针，每个段来保存特定类型的数据，分别包括代码、数据、栈等等。

| 段寄存器 | 描述         |
| -------- | ------------ |
| CS       | 代码段寄存器 |
| DS       | 数据段寄存器 |
| SS       | 栈段寄存器   |
| ES       | 额外的寄存器 |
| FS       | 额外的寄存器 |
| GS       | 额外的寄存器 |

#### 指令指针寄存器

EIP，保存了下一条需要执行的指令

转移指令、函数返回指令等可以修改该寄存器的内容，程序无法直接操作。

#### 控制寄存器

| 控制寄存器 | 描述                         |
| ---------- | ---------------------------- |
| CR0        | 处理器系统标志，控制操作模式 |
| CR1        | 预留，目前没用               |
| CR2        | 内存缺页信息                 |
| CR3        | 内存页目录信息               |
| CR4        | 处理器功能标志               |
为啥 CR1 寄存器被预留了？Intel 并没有任何的官方回应，只说该寄存器留作未来使用。反正控制寄存器确实是有点乱。

#### 标志寄存器

| 状态标志 | 位  | 名称     |
| -------- | --- | -------- |
| CF       | 0   | 进位标志 |
| PF       | 2   | 奇偶标志 |
| AF       | 4   | 调整标志 |
| ZF       | 6   | 零标志   |
| SF       | 7   | 符号标志 |
| OF       | 11  | 溢出标志 |


| 系统标志 | 位    | 名称                |
| -------- | ----- | ------------------- |
| TF       | 8     | 陷阱标志            |
| IF       | 9     | 中断允许标志        |
| IOPL     | 12-13 | I/O 权限级别标志    |
| NT       | 14    | 嵌套任务标志        |
| RF       | 16    | 恢复标志            |
| VM       | 17    | 虚拟 8086 模式 标志 |
| AC       | 18    | 对齐检测标志        |
| VIF      | 19    | 虚拟中断标志        |
| VIP      | 20    | 虚拟中断阻塞标志    |
| ID       | 21    | 识别标志            |


## 开发工具

## 一个例子

程序的模板如下：

```s
.section.data

    < initialized data here>

.section .bss

    < uninitialized data here>

.section .text
.globl _start
_start:

    <instruction code goes here>
```

第一个例子：

```s
# cpuid 
.section .data
output:
    .ascii "The processor Vendor ID is "
_ebx:
    .ascii "xxxx"
_edx:
    .ascii "xxxx"
_ecx:
    .ascii "xxxx\r\n"
output_end:

.section .text
.globl _start
_start:

    movl $0, %eax # show vendor ID String
    cpuid

    movl $_ebx, %edi # move registers data to somewhere
    movl %ebx, (%edi)
    movl $_ecx, %edi
    movl %ecx, (%edi)
    movl $_edx, %edi
    movl %edx, (%edi)

    movl $4, %eax # sys_write(dest, src, length)
    movl $1, %ebx # stdout
    movl $output, %ecx # output 
    movl $(output_end - output), %edx # length
    int $0x80

    movl $1, %eax # exit
    movl $0, %ebx # code = 0
    int $0x80
```

指令 `.ascii` 声明了 ASCII 字符串，所在位置用 `output` 标识。


---

下面是调用 `printf` 的例子

```s
# cpuid2.s View the CPUID Vendor ID string using C library calls
.section .data
output:
    .asciz "The processor Vendor ID is '%s'\n"

.section .bss
    .lcomm buffer, 12

.section .text

.globl main
main:

    movl $0, %eax
    cpuid

    movl $buffer, %edi
    movl %ebx, (%edi)
    movl %edx, 4(%edi)
    movl %ecx, 8(%edi)

    pushl $buffer
    pushl $output

    call printf

    addl $8, %esp
    pushl $0

    call exit
```

## 传送数据

### 数据段

`.data` 用于声明数据段，还有另一种数据段 `.rodata`，表示只读数据段。标签对处理器是无意义的，它只对汇编器有用。

| 命令    | 数据类型                 |
| ------- | ------------------------ |
| .ascii  | 字符串                   |
| .asciz  | 以空字符结尾的文本字符串 |
| .byte   | 字节                     |
| .double | 双精度浮点               |
| .float  | 单精度浮点               |
| .int    | 32位整数                 |
| .long   | 32位整数                 |
| .octa   | 16 字节整数              |
| .quad   | 8位整数                  |
| .short  | 16位整数                 |
| .single | 单精度浮点               |

---

```s
output:
    .ascii "The processor Vendor ID is "
```

这段代码开辟了一段内存，初始化成以上的字符串。

---

```s
sizes:
    .long 0x100, 0x150, 0x200, 0x250,
```

声明多个长整型

---

`.equ` 指令可以声明静态数据，并不占用实际的内存，只在使用时具体产生数据，是完全的汇编指令。

```s
.equ factor, 3
.equ LINUX_SYS_CALL, 0x80
```

----

bss 段中定义数据和数据段中有所不同，bss 是程序运行时产生的数据，有点像是某种意义上的缓存，这部分内容不会存储在程序中，程序中只标记需要多大的空间。

| 命令   | 描述         |
| ------ | ------------ |
| .comm  | 通用内存区域 |
| .lcomm | 局部内存区域 |

```s
.section .bss
.lcomm buffer1, 0x1111
.comm buffer2, 0x2222
```

### 数据传送指令

`mov` 指令的基本格式如下，AT&T 语法

```s
movx source, destination
```

source 和 destination 的值可以是立即数、内存地址、存储在内存中的数据、或者寄存器。它与英特尔的语法是反着的，我更喜欢英特尔的语法，但是奈何 gcc 使用了 AT&T 语法。以下是所有 `mov` 指令。

| movx   | 描述 |
| ------ | ---- |
| `movl` | 32位 |
| `movw` | 16位 |
| `movb` | 8位  |

下面是一些 `mov` 指令

```s
.section .text

movl %eax, %ebx
movw %ax, %bx
movb %al, %bl
```

`mov` 指令有一些约束，也是可以使用 `mov` 的规则，这些规则如下：

- 把 立即数 传送给 通用寄存器
- 把 立即数 传送给 内存位置
- 把 通用寄存器 传送给 另一个通用寄存器
- 把 通用寄存器 传送给 段寄存器
- 把 段寄存器 传送给 通用寄存器
- 把 通用寄存器 传送给 控制寄存器
- 把 控制寄存器 传送给 通用寄存器
- 把 通用寄存器 传送给 调试寄存器
- 把 调试寄存器 传送给 通用寄存器
- 把 内存位置 传送给 通用寄存器
- 把 内存位置 传送给 段寄存器
- 把 通用寄存器 传送给 内存位置
- 把 段寄存器 传送给 内存位置

`movs` 指令是一种特殊的指令，把字符串从一个内存位置，传送到另一个内存位置。

### 条件传送指令

无符号条件传送指令

| 指令对          | 描述                 | EFLAG 状态   |
| --------------- | -------------------- | ------------ |
| `cmova/cmovnbe` | 大于／不小于或者等于 | (CF或ZF) = 0 |
| `cmovae/cmovnb` | 大于或者等于／不小于 | CF = 0       |
| `cmovnc`        | 无进位               | CF = 0       |
| `cmovb/cmovnae` | 小于／不大于或者等于 | CF = 1       |
| `cmovc`         | 进位                 | CF = 1       |
| `cmovbe/cmovna` | 小于或者等于/不大于  | (CF或ZF) = 1 |
| `cmove/cmovz`   | 等于/零              | ZF = 1       |
| `cmovne/cmovnz` | 不等于/不为零        | ZF = 0       |
| `cmovp/cmovpe`  | 奇偶校验/偶校验      | PF = 1       |
| `cmovnp/cmovpo` | 非奇偶校验/奇校验    | PF = 0       |


带符号条件传送指令

| 指令对          | 描述                | EFLAG 状态             |
| --------------- | ------------------- | ---------------------- |
| `cmovge/cmovnl` | 大于或者等于/不小于 | (SF异或OF) = 0         |
| `cmovl/cmovnge` | 小于/不大于或者等于 | (SF异或OF) = 1         |
| `cmovle/cmovng` | 小于或者等千/不大于 | ((SF异或OF) 或 ZF) = 1 |
| `cmovo`         | 溢出                | OF = 1                 |
| `cmovno`        | 未溢出              | OF = 0                 |
| `cmovs`         | 带符号(负)          | SF = 1                 |
| `cmovns`        | 元符号(非负)        | SF = 0                 |

### 交换数据

`xchg %eax, %ebx`

| 指令        | 描述                                             |
| ----------- | ------------------------------------------------ |
| `xchg`      | 交换后面两个位置的值                             |
| `bswap`     | 反转 32 位寄存器中的字节序                       |
| `xadd`      | 交换两个值且把总和存储在目的寄存器中             |
| `cmpxchg`   | 把一个值和个外部值进行比较，并且交换它和另一个值 |
| `cmpxchg8b` | 比较两个 64 位值并且交换他们                     |

### 堆栈

| 指令           | 描述                                   |
| -------------- | -------------------------------------- |
| `PUSHA/POPA`   | 压入或者弹出所有 16 位通用寄存器       |
| `PUSHAD/POPAD` | 压入或者弹出所有 32 位通用寄存器       |
| `PUSHF/POPF`   | 压入或者弹出 EFLAGS 寄存器的低 16 位   |
| `PUSHFD/POPFD` | 压入或者弹出 EFLAGS 寄存器的全部 32 位 |

## 控制执行流程

## 使用数字

## 参考资料

- [Professional Assembly Language](https://book.douban.com/subject/2039913/)
