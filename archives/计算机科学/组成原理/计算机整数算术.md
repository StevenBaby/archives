# 计算机整数算术

[annotation]: <id> (0341afd0-66bf-45b5-86c1-979922de3ee2)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 15:20:12)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (组成原理)

> 原文链接：<http://blog.ccyg.studio/article/0341afd0-66bf-45b5-86c1-979922de3ee2>

在阅读这篇文章之前，强烈建议阅读 [计算机定点数表示法](http://blog.ccyg.studio/article/b694810d-f3da-42f5-8318-985994ecdfc7)，以理解计算机中定点数的表示方式。

## 取负

在原码表示法中，求一个整数的负数是很简单的：只需要将符号位取反，也就是由0变成1，或者由1变成0。

在补码表示法中，求一个整数负数可用一下规则：

1. 将整数的每一位（包括符号位）取反，即把每一个1变成0，0变成1
2. 将此取反结果作为一个无符号二进制整数对待，再加1

以上两步称为**求补运算**，例如：

$+18 = 00010010_补 \xlongequal{按位取反}11101101 \xlongequal{ +1 } 11101110 = -18$

若对次数再进行取负操作，则正如我们希望的那样，负数还是原来的那个数：

$-18 = 11101110_补 \xlongequal{按位取反}00010001 \xlongequal{ +1 } 00010010 = +18$

特别的对于0，来说

$0 = 00000000_补 \xlongequal{按位取反}11111111 \xlongequal{ +1 } 100000000 \xlongequal{舍去进位} = 00000000 = 0$

上面加1时，最高位有一个进位，由于数据位有限，可以忽略该进位。结果0求负数还是0，正如我们期望的那样。

特别地对于一个八位的字：

$-128 = 10000000_补 \xlongequal{按位取反}01111111 \xlongequal{ +1 } 10000000 = -128$

这样的一些意外情况在所难免，因为-128在八位二进制数中本身就是一个特殊的存在。

## 加法和减法

> 加法和减法本质上都是加法，对于减法，只是变成了加上一个**相反数**

补码表示法的加法执行过程和无符号整数加法一样，如果操作的结果为正，那么补码的表示和原码表示时一样的。如果结果为负，则表示负数的补码形式。注意在某些情况下，最高位会有一个进位，它超出了字的长度，将被丢弃，从而忽略不计。

对于任一加法操作，如果出现结果的长度大于正被使用的字的长度，那么这种情况被称为**上溢**。当上溢出现时，运算器必须报告错误，以通知其他部件不要试图使用此结果。判断上溢的规则如下：

**上溢规则**：两个数相加，若他们同为正数或者负数，则当且仅当结果的符号位变相反时才发生上溢。

**减法规则**：由一个数减（被减数）去另一个数（减数），则之需求出减数的补码，并把它加到被减数上。于是减法可以用加法实现。

下图中给出了实现加法和减法的数据通路和所需硬件元件。中心原件是一个二进制加法器，它对输入的两个数进行相加，产生一个和以及一个上溢指示。二进制加法器将两个数看作是无符号数。对于加法，提交给加法器的两个数来自寄存器，图中是A寄存器和B寄存器。结果通常是存于这两个寄存器中的某一个或者是另外的第三个寄存器。上溢指示保存一个1位的上溢标志中（overflow flag 0表示无上溢，1表示有上溢）。对于减法，减数（B寄存器）要通过补码求补器产生减数的补，并提交给加法器。注意途中只是显示了数据通路。还需要一些控制信号，根据当前执行的操作是加法还是减法，来控制是否需要使用求补器。

![](计算机整数算术-1.svg?sanitize=true)

## 乘法

与加法和减法相比，无论是以硬件还是软件来完成，乘法都是一个复杂的操作。各种各样的算法已用于各类计算机中。给读者常用算法的感性认识。首先介绍如何实现两个无符号数整数相乘的简单方法，然后再实现补码表示数乘法的最通用技术。

### 无符号数整数乘法

如图所示 与我们手动演算的一样，乘法可以进行如下操作：

1. 乘法涉及部分积生成，乘数的每一位对应一个部分积。然后，部分积相加得到最后的乘积。
2. 部分积是容易确定的。当乘数的位是0，其部分积也是0；当乘数位是1，其部分积是被乘数。
3. 部分积通过求和而得到最后乘积。因此后面的部分积总要比它前面的部分积再左移一个位置。
4. 两个n位二进制数的乘法可产生的最大长度为 2n 位的积，（如 $11 \times 11 = 1001$）

<img src='计算机整数算术-2.svg?sanitize=true' width=400 />

与纸笔手工演算相比，计算机能做一些改进使得乘法操作更有效。首先可以边产生部分积边做加法，而不是等到最后再相加。这就消除了存储所有部分积的需求，从而减少了所需的寄存器数量。其次，能节省部分积的生成时间，对于乘数的每个1，需要执行的加和移位操作；对于每个0，则只执行移位操作就可以了。

- [ ] 刨坑待填

## 除法

- [ ] 刨坑待填

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings](#)