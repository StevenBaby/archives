# 计算机整数算术

[annotation]: <id> (0341afd0-66bf-45b5-86c1-979922de3ee2)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 15:20:12)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (组成原理)

> 原文链接：<http://blog.ccyg.studio/article/0341afd0-66bf-45b5-86c1-979922de3ee2>

在阅读这篇文章之前，强烈建议阅读 [计算机定点数表示法](http://blog.ccyg.studio/article/b694810d-f3da-42f5-8318-985994ecdfc7)，以理解计算机中定点数的表示方式。

## 取负

在原码表示法中，求一个整数的负数是很简单的：只需要将符号位取反，也就是由0变成1，或者由1变成0。

在补码表示法中，求一个整数负数可用一下规则：

1. 将整数的每一位（包括符号位）取反，即把每一个1变成0，0变成1
2. 将此取反结果作为一个无符号二进制整数对待，再加1

以上两步称为**求补运算**，例如：

$+18 = 00010010_补 \xlongequal{按位取反}11101101 \xlongequal{ +1 } 11101110 = -18$

若对次数再进行取负操作，则正如我们希望的那样，负数还是原来的那个数：

$-18 = 11101110_补 \xlongequal{按位取反}00010001 \xlongequal{ +1 } 00010010 = +18$

特别的对于0，来说

$0 = 00000000_补 \xlongequal{按位取反}11111111 \xlongequal{ +1 } 100000000 \xlongequal{舍去进位} = 00000000 = 0$

上面加1时，最高位有一个进位，由于数据位有限，可以忽略该进位。结果0求负数还是0，正如我们期望的那样。

特别地对于一个八位的字：

$-128 = 10000000_补 \xlongequal{按位取反}01111111 \xlongequal{ +1 } 10000000 = -128$

这样的一些意外情况在所难免，因为-128在八位二进制数中本身就是一个特殊的存在。

## 加法和减法

> 加法和减法本质上都是加法，对于减法，只是变成了加上一个**相反数**

补码表示法的加法执行过程和无符号整数加法一样，如果操作的结果为正，那么补码的表示和原码表示时一样的。如果结果为负，则表示负数的补码形式。注意在某些情况下，最高位会有一个进位，它超出了字的长度，将被丢弃，从而忽略不计。

对于任一加法操作，如果出现结果的长度大于正被使用的字的长度，那么这种情况被称为**上溢**。当上溢出现时，运算器必须报告错误，以通知其他部件不要试图使用此结果。判断上溢的规则如下：

**上溢规则**：两个数相加，若他们同为正数或者负数，则当且仅当结果的符号位变相反时才发生上溢。

**减法规则**：由一个数减（被减数）去另一个数（减数），则之需求出减数的补码，并把它加到被减数上。于是减法可以用加法实现。

下图中给出了实现加法和减法的数据通路和所需硬件元件。中心原件是一个二进制加法器，它对输入的两个数进行相加，产生一个和以及一个上溢指示。二进制加法器将两个数看作是无符号数。对于加法，提交给加法器的两个数来自寄存器，图中是A寄存器和B寄存器。结果通常是存于这两个寄存器中的某一个或者是另外的第三个寄存器。上溢指示保存一个1位的上溢标志中（overflow flag 0表示无上溢，1表示有上溢）。对于减法，减数（B寄存器）要通过补码求补器产生减数的补，并提交给加法器。注意途中只是显示了数据通路。还需要一些控制信号，根据当前执行的操作是加法还是减法，来控制是否需要使用求补器。

![](计算机整数算术-1.svg?sanitize=true)

## 乘法

- [ ] 刨坑待填

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings](#)