# 计算机算术

[annotation]: <id> (bf0f5ed1-e7c6-4565-a190-c6f9368b4b7e)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-16 10:43:42)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (组成原理)
<!-- [annotation]: <comments> (true) -->

## 算数逻辑单元 ALU

算术逻辑单元(Arithmetic and Logic Unit, ALU) 是计算机实际完成数据逻辑运算的部件，计算机系统的其他部件（控制器、寄存器、存储器、输入输出设备），主要是为了ALU传入数据，待ALU处理后取回运算结果，在某种意义上，考察ALU设计的是计算机的核心和本质。

## 整数表示

在二进制数制系统中，仅用数字 0 和 1、符号和小数点来表示任意一个数。例如：

$$-1101.0101_2 = - 13.3125_{10}$$

对于计算机存储和处理，负号和小数点是不方便的，因为只能用二进制数字来表示数。如果只使用非负整数，那么其表示是直截了当的。

一个8位的字能表示从 0 ~ 255 的数。例如：

- 00000000=0
- 00000001=1
- 00101001=41
- 10000000=128
- 11111111=255

通常，如果一个 n 位二进制数字序列 $a_{n-1}, a_{n-2} \dots  a_1 a_0$ 表示一个无符号整数A，那么A的十进制值是：

$$ A = \sum_{i=0}^{n-1} 2^i a_i$$

## 符号幅值（绝对值）表示法

有几种可以选择的方式来表示负数和正数。这些表示方式都涉及将字的最高位作为符号对待：若最高位是0，则为正数；若最高位为1，则为负数。

采用符号位表示正负数的最简单的表示法是 **符号幅值表示法**，以一个 n 位字为例，最高位为符号位。其余 n - 1 位为整数的幅值（绝对值）。例如：

- +18 = 00010010
- -18 = 10010010

一般情况下，符号幅值可表示为：

$$ A =\left\{
\begin{aligned}
&\sum_{i=0}^{n-2}2^ia_i \ \ (a_{n-1} = 0)\\
- &\sum_{i=0}^{n-2}2^ia_i \ \ (a_{n-1} = 1) \\
\end{aligned}
\right.
$$

符号幅值表示法有几个缺点。

- 一个是加减运算需要考虑数的符号，又要考虑幅值，才能进行所要求的运算。
- 另一个是 0 有两种表示
  - $+0_{10}=00000000$
  - $-0_{10}=10000000$

这样的话，对于0的判断就会稍微困难一点。

因为这些缺点，符号幅值表示法很少用于ALU中的整数表示，而最常用的方案是 **2的补码表示法**

## 2的补码表示法

与 **符号幅值表示法** 类似，2的补码表示法也使用最高位最为符号位，从而很容易判断一个整数是正还是负。其不同点在于其他位的解释方式。

| 2的补码表示法和算数的主要特征 | |
| - | - |
| 范围| $-2^{n-1}$ 到 $2^{n-1} - 1$ |
| 表示零的数 | 1个 |
| 取负 | 将此数对应的二进制川各位取反；将此结果作为一个无符号数对待，再加1 |
| 位长度扩展 | 在此数的左边添加附加位的位置，并以原符号位的值填充这些位置 | 
| 上溢规则| 若两个同符号数相加（两个正数或者两个负数），则当且仅当结果的符号位变反时才出现上溢 | 
| 减法规则| 由 A 减 B，则先取B的2的补，然后再与A相加 |

大多数关于 2 的补码表示法的介绍都把重点放在了生成负数的规则上，但并没有给出为什么这些规则能够成立的证明。而通过以位加权取和的方式来定义2的补码，正如上面对无符号和符号幅值表示法所做的那样，这有助于更好地理解2的补码表示法。这种解释的优点在于，它可以消除2的补码算术规则可能不适用某些特殊情况的任何疑虑。

以2进制补码形式来表示一个 n 位整数 A。若A时正的，则符号位 $a_{n-1}$ 是 0；其余表示次数的幅值，如同符号幅值表示法一样，因此有：

$$ A = \sum_{i=0}^{n-2} 2^i a_i \ \ (A \geq 0)$$

零被认为是整数，因此表示为符号位和幅值都是0，可见正整数的表示范围是由 0 到 $2^{n-1} - 1$，再大的数将需要更多的位。

> 现在，对于一个负数 A (A < 0)，其符号位 $a_{n-1} = 1$，其余 n - 1 位能取 $2^{n-1}$ 个值中的某个值，于是负数可表示的范围由 -1 到 $-2^{n-1}$。对于 n -1 位值与负整数值的对应，我们希望以这样一种方式来指派负整数的位置，它能使得算术运算直截了当地处理，类似于无符号整数算术那样。再无符号整数表示中，要从n位值得表示计算得到整数的值，是由各位乘以权值取得的，最高有效位的权是 $+2^{n-1}$, 那么上文所要求的算术运算性质将得到满足。这就是2的补码表示法中的规定，这个规定会产生如下的负数计算表达式：
> $$ A = - 2^{n-1}a_{n-1} + \sum_{i=0}^{n-2} 2^i a_i$$

~~上面这段真心晦涩难懂~~

**定点数表示法** 最后应指出，本节所讨论的表示法有时称为定点数表示法。这是因为小数点的位置是固定的，并且被假定在最低位数字的右边。


## 整数算术

**取负** 在符号幅值表示法中，求一个

- [ ] 刨坑待填

## 浮点数的表示

使用定点数表示法，能表示以0为中心一定范围内的正数和负数。通过重新设定小数点的位置，这种格式也能用来表示小数。不过这种方法有明显的限制，不能表示很大的数，也不能表示很小的小数，而且当两个大数相除时，商的小数部分可能会丢失。

对于十进制数，解除这种限制的方法时使用 **科学计数法**，于是 976 000 000 000 000 可以表示成 $9.76 \times 10 ^ {14}$，而 0.000 000 000 000 097 6 可以表示成 $9.76 \times 10 ^ {-14}$。实际上的操作是，我们动态的移动了小数点到合适的位置，并使用10的指数来确定小数点的位置。这就允许只使用少数几个数字来表示很大范围和很小的数。

这种 **科学计数法** 也可以用于二进制数，可以使用如下形式来表示一个数：

$$ \pm S \times B ^{\pm E}$$

这样的数保存在一个二进制字的三个字段中:

- **符号**：正或者负
- **有效值** S (significand) 或者 **有效数字**
- **阶值** E (exponent) 或者 **指数**

指数的底或者基是隐含的，因为对于所有的数他都是相同的，因此是不需要存储的。通常，小数点的位置约定在最左（最高）有效位的右边，也就是小数点左边有1位。

## 二进制浮点数的IEEE标准

最重要的浮点数表示法是在1985年通过的IEEE 754标准中所定义的浮点数表示法。开发这个标准是为了提高程序从一种处理器移植到另一种处理器上的可移植性。也是为了促进研制更为复杂的数值运算程序。这个标准获得了广泛的认可，并且已经用于当代各种处理器和算数处理器中。

IEEE 754 标准定义了 32位单精度 `float` 和 64位双精度 `double` 的两种格式。他们的阶值字段分别是8位和11位，底是2，另外，标准还定义了单精度、双精度的扩展格式，但他们的具体格式是与实现相关的。扩展格式包括在阶值字段提供了更多的位（扩展范围）和在有效值字段提供更多的位（扩展精度）。扩展格式将被用于中间计算过程。由于他们有更高的精度，扩展格式是的最终结果避免被过量的舍入，从而减少加大误差的机会，由于有更大的表示范围，扩展格式也使得计算过程出现上溢的机会减少，这样如果计算的最终结果能以基本格式表示，那么就不会因为中间计算过程中的上溢而终止了。对于单精度扩展格式而言，他的一个推动力是它能呈现双精度格式的某些优点，又不导致计算耗时过长，因为通常精度越高，计算耗时也越长。


## 浮点算数

对于加减法必须保证两个操作数具有相同的阶。这可能需要移动一个操作数的小数点以达到对齐。乘除法反而更简单些。

浮点运算可能会产生下面几种特殊的情况：

- **阶值上溢**：一个正阶值超出了最大允许的阶值。某些系统将其设置为 $+ \infty$ 或 $- \infty$
- **阶值下溢**：一个负阶值小于允许的阶值。这意味这那个数太小无法表示，一般可报告成为0
- **有效值上溢**：两个数相加时可能导致最高位进位，这可以通过重新对齐来修补
- **有效值下溢**：处理有效值对齐时，可能数字被移除右端最低位而丢失

## 浮点数加法和减法

浮点算数中，加、减法要比乘除法更复杂，因为它需要对齐。加减法有4个基本阶段：

1. 检查 0 
2. 对齐有效值
3. 加或减有效值
4. 规格化结果

如下图所示，下面逐步说明加、减法所需要的主要操作。假定格式类似于 IEEE 754格式。为了加减操作，两个操作数必须传送到算数逻辑单元的寄存器中，若格式包括一个隐藏的有效位，则此位要先变成显式再操作。

**检查0** 因为加法和减法除了符号不同外基本上都是相同的，因此若是一个减法，过程一开始就要改变减数的符号，接着若有一个操作数为0，那么另一个操作数就是结果。

**对其有效位** 下一步是操纵两个数使这两个数阶值相等。

要说明为什么需要这样做，可以参考十进制加法：

$$(123 \times 10 ^ 0) + (456 \times 10 ^ {-2})$$

很明显，不能仅加有效值，数字首先要设置成对等位置。第二个数的4需要与第一个数的3对齐。两个数的阶值在相等的条件下才能相加，这是数学的基本要求。于是有

$$(123 \times 10 ^ 0) + (4.56 \times 10 ^ 0) = 127.56 \times 10 ^ 0 $$

实现有效值对齐，或右移较小的数，或左移较大的数。无论哪种操作都可能导致数字丢失，一般来说右移较小的数而丢失的数字，所造成的影响要相对小些，因此对齐通过重复右移较数有效值的的幅值部分1位，并且将其阶值加1，直到两个阶值相等。

若此过程导致有效值变为0，则另一个数即为结果，于是，若两个数的阶值差别非常大，则较小的数丢失。

**加法** 将两个数的有效值相加，相加时要考虑他们的符号。因为符号可能不同，结果有可能是0.这里也可能出现有效值上溢 1个数字，若是这样，则需要有效值右移，阶值加1，阶值加1又可能发生上溢；如果发生阶值上溢，此时应终止操作并报告错误。

**规格化** 左移有效值直到最高有效数字为非零，每次左移都引起阶值相应减1，这种情况有可能出现阶值下溢。最后必须对结果进行舍入，然后报告结果。

![浮点数加法和减法](浮点数加法和减法.svg?sanitize=true)

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings]()
