# 计算机组成原理拾遗

[annotation]: <id> (7a6aeaea-9bcc-43e7-8463-086a32bcbd24)
[annotation]: <status> (public)
[annotation]: <create_time> (2020-10-13 22:59:10)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (组成原理)
[annotation]: <comments> (false)
[annotation]: <url> (http://blog.ccyg.studio/article/7a6aeaea-9bcc-43e7-8463-086a32bcbd24)

## 概述

- 时钟周期(Clock Cycle)：通常为节拍脉冲或T周期，即主频的倒数，是CPU中最小的时间单位。
- 主频：机器内部的时钟频率。时钟周期的倒数。
- CPI (Clock cycle Per Instruction)：执行一条指令所需的时钟周期数。
- CPU执行时间：运行一个程序所花费的时间
      - $\displaystyle CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{指令条数 \times CPI}{主频}$
- MIPS (Million Instruction Per Second)：每秒执行多少百万条指令
      - $\displaystyle MIPS = \frac{指令条数}{执行时间 \times 10^6} = \frac{主频}{CPI}$
- MFLOPS (Million Float Operation Per Second)：每秒执行多少百万次浮点运算
      - $\displaystyle MFLOPS = \frac{浮点运算次数}{执行时间 \times 10^6}$
- GFLOPS：每秒执行多少十亿次浮点运算
      - $\displaystyle GFLOPS = \frac{浮点运算次数}{执行时间 \times 10^9}$
- TFLOPS：每秒执行多少万亿次浮点运算
      - $\displaystyle TFLOPS = \frac{浮点运算次数}{执行时间 \times 10^{12}}$
- PFLOPS：每秒执行多少千万亿次浮点运算
      - $\displaystyle PFLOPS = \frac{浮点运算次数}{执行时间 \times 10^{15}}$

计算机容量单位

| 单位 | 数量      | 存储容量        |
| ---- | --------- | --------------- |
| K    | $10^3$    | $2^{10} = 1024$ |
| M    | $10^6$    | $2^{20}$        |
| G    | $10^9$    | $2^{30}$        |
| T    | $10^{12}$ | $2^{40}$        |
| P    | $10^{15}$ | $2^{50}$        |
| E    | $10^{18}$ | $2^{60}$        |
| Z    | $10^{21}$ | $2^{70}$        |

----

## 数据的表示和运算

### 数据存储方式

- 小端方式(Little Endian)：先存储低位字节，后存储高位字节
- 大端方式(Big Endian)：先存储高位字节，后存储低位字节

---

存储 `0x12345678` 到一个 `int` 变量中：

| 地址 | 0x00 | 0x01 | 0x02 | 0x03 |
| ---- | ---- | ---- | ---- | ---- |
| 小端 | 78   | 56   | 34   | 12   |
| 大端 | 12   | 34   | 56   | 78   |

---

### 边界对齐

假设存储字长 32bit，可按字节、半字、字寻址，在对准边界32位字长的计算机，半字地址是 2 的整数倍，字地址是 4 的整数倍，当所存数据不能满足此要求时，可填充一个或多个空白字节，这样无论所存的是字节、半字还是字，均可以一次访存取出。

当数据不按边界对齐方式存储时，一个字的数据可能存储在两个存储字中，此是需要两次访存，并对高低字节的位置进行调整后才能取出一个字，影响了系统的效率。

下面为 C 语言中禁止边界对其的代码。

```c
#define _packed __attribute__((packed))
```

### 定点数的表示

- 正数的 **原码**、**补码**、**反码** 都是一样的
- 负数的补码：符号位不变，数值部分按位取反，末位加一
- 补码的负数的补码：连同符号位一起，各位取反，末位加一
- 负数的反码，符号位不变，数值部分按位取反

C 语言中 的数据类型，一般用补码表示：

| 类型    | 所占位数 | 数的范围                      |
| ------- | -------- | ----------------------------- |
| `char`  | 8        | $-128 \sim 127$               |
| `short` | 16       | $-32768 \sim 32767$           |
| `int`   | 32       | $-2147483648 \sim 2147483647$ |
| `long`  | 32       | $-2147483648 \sim 2147483647$ |

符号拓展：

- 正数：原符号位移动到新符号位上，新表示形式的所有附加位都用 0 进行填充
- 负数原码：原符号位移动到新符号位上，新表示形式的所有附加位都用 0 进行填充
- 负数补码、反码：原符号位移动到新符号位上，新表示形式的所有附加位都用 1 进行填充

### 数据转换

| 数据类型的转换                       | 转换原则                     |
| ------------------------------------ | ---------------------------- |
| 同一类型但字长不同的数据间转换       | 由字长短的转为字长长的       |
| 定点方式与浮点方式间的转换           | 由定点数转换为浮点数         |
| 整型数种的有符号数和无符号数间的转换 | 机器数不变，知识解释方式不同 |

隐式类型转换：

```c
char -> int -> long -> float -> double
```

### 补码一位乘法 （Booth算法）

进行 n 轮加法、移位，最后再多来一次加法。

每次加法根据当前 MQ寄存器中的最低位、辅助位来确定，

可能 +0、$+[x]_{补}$、$+[-x]_{补}$

- 辅助位 - 最低位 = 1 时, $(ACC) + [x]_补$
- 辅助位 - 最低位 = 0 时, $(ACC) + 0$
- 辅助位 - 最低位 = -1 时, $(ACC) + [-x]_补$

其他注意点补充：

- 辅助位是实际上寄存器中的最低位
- 最低位是补码乘数的最低位，也就是在最低位之后加一位辅助位
- 补码乘法符号位必须参与运算
- 被乘数使用双符号位补码
- 乘数使用单符号位补码

### 溢出判断

用两位符号位来做溢出判断

- 00 结果为正，无溢出
- 01 正溢出
- 10 负溢出
- 11 结果为负，无溢出

### 原码除法 恢复余数法

### 原码除法 加减交替法

### 补码除法

- 数据都用补码表示，符号位参与运算
- 初始时观察被除数与除数符号，同号做减法，异号做加法
- 若余数与除数同号，则商1后余数左移一位减去除数，若余数与除数异号，则商0后余数左移一位加上除数
- 重复上一步操作，直到得到 n 位商
- 一般在末尾补上一个1

### 浮点数的运算

左规：当尾数出现 

- 00.0xxxx (原码或补码正数)
- 11.1xxxx (补码负数)

需要左规（尾数左移，阶码减一），可能出现多次左规，规格化后结果形为

- x.1xxxxx (原码或补码正数)
- x.0xxxxx (补码负数)

右规：当尾数求和出现 10.0xxxxx 或 01.1xxxxx 时，需要右规（尾数右移，阶码加一），且仅需要一次右规。

### ALU

74181 是四位并行加法器。
74182 是多个 74181 并行进位的辅助芯片，一块 74182 可以并四块 74181。先行进位加法器。

---

## 存储器的层次结构

### 半导体存储器

- SRAM：非破坏性读出，不需要刷新，断电信息丢失，集成度低，功耗大，常用于 cache
- DRAM：破坏性读出，需要定期刷新，断电信息丢失，集成度高，价格低，容量大和功耗低，存取速度比 SRAM 慢，常用于大容量主存系统。
- ROM：通常 ROM 只能读出，不能写入，信息永久保存，属非易失性存储器。ROM和RAM可同时作为主存的一部分，构成主存的地址域。

### 主存与CPU的连接

- 位扩展：对字长进行扩展，使其数据位数与CPU的数据线数相等
- 字扩展：增加存储器种字的数量，位数不变，增加容量
- 字位扩展：同时上述两种方式扩展

---

* 低位交叉多体存储器：地址码的低位字段经过译码（片选，非门）选择不同的模块，而高位字段指向相应模块内的存储字。连续地址分布在相邻的不同模块内，同一模块内的地址是不连续的；对连续字的成块传送可实现多模块并行存取，提高了存储器的带宽。

采用低位交叉后，可以在不改变每个模块存取周期的前提下，采用流水线的方式进行存取，提高存储器的带宽。

设模块字长等于总线宽度，模块存取一个字的存取周期为 $T$，总线传送周期为 $r$，为保证流水线不间断，则存储器交叉模块数应大于等于 $\displaystyle m = \frac{T}{r}$，$m$ 成为交叉存取度。

每经过 $r$ 时间延迟后启动下一个模块，对比连续存取 $m$ 个字所需时间如下：

| 存储器编址方式 | 低位交叉编址 | 顺序方式编址 |
| -------------- | ------------ | ------------ |
| 所需的时间     | $T + (m-1)r$ | $mT$         |

- 双端口存储器：指同一个存储器具有两组相互独立的读写控制线路
- 相联存储器：访问相联存储器只需要给出内容，不需要给出地址，因此，相联存储器又被称为按内容访问存储器。
- 顺序存储器：某个模块进行存取时，其它模块不工作，某一模块出现故障时，其它模块可以照常工作，通过增添模块来扩充存储器容量比较方便，但各模块串行工作，存储器的带宽收到了限制。顺序方式中连续地址基本分布在同一模块内，同一模块内的地址是连续的。

* 全地址译码：用全部的高位地址信号作为译码信号，使得存储器芯片得每个单元都单独占据一个唯一得内存地址。
* 部分译码法：用 **部分** 高位地址信号作为译码信号，使得被选中的存储器芯片占有几组不同的地址范围。
* 交叉编址

**$0x1000 = 2^{12} = 4096$**

- 死区：刷新存储器所用的时间
- 死时间率：刷新存储器所用的时间的占比

常见的刷新方式有集中式、分散式和异步式三种。其中：

- 集中刷新方式的 **死区** 最大，而且随着存储容量的增大（存储矩阵的增大），**死区** 也会增大；
- 异步刷新方式的 **死区** 最小，仅等千一个读写周期；
- 分散刷新方式则没有 **死区**；

### 高速缓冲存储器 cache

cache 保存某些主存 **块** 的副本。

CPU 欲访问的信息已在 cache 种的比率成为 cache 的 **命中率**。

设一个程序执行期间，Cache 的总命中次数为 $N_c$，访问主存的总次数为 $N_m$，则命中率 $H$ 为：

> $$H = \frac{N_c}{N_c + N_m}$$

设 $t_c$ 为命中时的 Cache 访问时间，$t_m$ 为未命中时的访问时间；

若系统先进行 Cache 访问，Cache 命中，则结束；Cache 未命中，再进行主存访问，则 Cache-主存系统的平均访问时间 $T_a$ 为：

> $$T_a = Ht_c + (1-H)(t_m + t_c)$$

若系统同时进行 Cache 访问和主存访问，Cache 命中，则主存访问失效；Cache 未命中，则等待主存访问，则 Cache-主存系统的平均访问时间 $T_a$ 为：

> $$T_a = Ht_c + (1-H)t_m$$

Cache 系统的访问效率为：

> $$e = \frac{t_c}{T_a}$$

---

### cache 映射方式

设：

- $j$ 为 Cache 块号；
- $i$ 为主存块号；
- $2^c$ 为 Cache 的总块数；
- $Q$ 为 Cache 组数；

---

直接映射：主存块只能装入 Cache 种的唯一位置。

- > 映射关系 $j = i \mod c^2$
- > 主存地址 = 主存字块标记 + cache 块号 + 块内地址

---

全相联映射：

- > 主存地址 = 主存字块标记 + 块内地址

---

组相联映射：组间直接映射，组内全相联映射；主存的一个数据快可以装入固定一组内的任意位置。

- > 映射关系 $j = i \mod Q$
- > 主存地址 = 主存字块标记 + 组号 + 块内地址

---

### cache 替换策略

| Cache 替换策略        | 英文全称                 | 替换方法                               | 是否依据局部性原理 |
| --------------------- | ------------------------ | -------------------------------------- | ------------------ |
| 随机法(RAND)          | Random                   | 随机替换                               | 否                 |
| 先进先出法(FIFO)      | First Input First Output | 选择最早调入的进行替换                 | 否                 |
| 近期最少使用算法(LRU) | Least Recently Used      | 选择近期内长久未访问过的存储行替换     | 是                 |
| 最不经常使用法(LFU)   | Least Frequently Used    | 将一段时间内被访问次数最少的存储行替换 | 是                 |

使用换算法，除了存放数据以外，还需要保存一些标记数据：

- 主存字块标记
- 有效位 1bit
- 脏位：1bit 数据与主存中是否一致(写回法)
- 最近是否被访问（LRU标记位）$log_2M$ bit，$M$ 位组相联分组

全写法(write-through)：必须把数据同时写入 cache 和主存，当某一块需要替换时，不必把这块写会内存，将新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性，缺点是增加了访问次数，降低了 Cache 的效率。

写回法(write-back)：指 CPU 在执行写操作时，被写数据只写入Cache, 不写入主存。仅当需要替换时，才把已经修改过的Cache 块写回到主存。这种方法减少了访存次数，但存在不一致的隐患。

- 如果 **脏位** 为 1，则必须先把这一块写回到主存中去之后才能调入新的块； 
- 如果 **脏位** 为 0，则这一块不必写回主存，只要用新调入的块覆盖掉这一块即可。

---

### 虚拟存储器

块表(TLB)：依据程序执行的局部性原理，在一段时间内总是经常访问某些页，把这些页对应的页表项存放在 cache 组成的 **快表** 中，把放在主存中的页表称为慢表。

查找时，块表和慢表同时进行，若块表中有此逻辑页号，则很快能找到对应的物理页号，送入实主存地址寄存器，并使慢表的查找作废，大大提高了虚存的效率。

- 页号：虚拟地址页号，存于外存中
- 页内地址：页中偏移量
- 页框号：物理页号，存于内存中
- 虚拟地址 = 页号 + 页内地址
- 物理地址 = 页框号 + 页内地址

虚拟地址往往比物理地址大得多。

---

## 指令系统

> 指令格式 = 操作码 OP + 寻址特征 + 形式地址 A

- 操作码的位数决定了指令的条数
- 寻址特征和形式地址A共同决定了可寻址的范围

* 若为立即寻址：则形式地址A的位数决定了数的范围
* 若为直接寻址：则形式地址A的位数决定了可寻址的范围
* 若为寄存器寻址：则形式地址A的位数决定了通用寄存器的最大数量
* 若为寄存器简介寻址：则寄存器字长决定了可寻址的范围

### 寻址方式

- 立即寻址：指令中的 **形式地址A** 就是需要的操作数，无需访问主存
- 立即寻址：指令中的 **形式地址A** 就是操作数的 **真实地址** $EA = A$
- 间接寻址：指令中的 **形式地址A** 不是操作数的真实地址，而是操作数有效地址的地址，$EA = (A)$，间接寻址可能有多次，所以寻址中需要有 1 bit 标识寻址结束。
- 寄存器寻址：指令中的 **形式地址A** 表示寄存器编号，操作数在寄存器 $R_i$ 内，又称为 **寄存器直接寻址**，$EA = R_i$。
- 寄存器间接寻址：指令中的 **形式地址A** 表示寄存器编号，寄存器中的内容表示主存单元的地址，$EA = (R_i)$
- 隐含寻址：不是明显地给出操作数地址，而是在指令中隐含着操作数的地址。根据芯片设计，人为强制规定。
- 基址寻址：将 CPU 中的 **基址寄存器(BR)** 的内容加上指令格式中的 **形式地址A**，而形成操作数的有效地址 $EA = (BR) + A$，在操作系统管理进程中特别有用，进程中使用形式地址，基址寄存器表示具体的进程物理地址的起始位置。
- 变址寻址：将指令格式中的 **形式地址A** 加上 CPU 中的 **变址寄存器(IX)** 的内容，而形成操作数的有效地址 $EA = A + (IX)$，变址寄存器是面向用户的，基地址是形式地址A，用户改变变址寄存器中的值，可以方便的实现数组索引，或者循环程序。
- 相对寻址：把程序计数器 (PC) 的内容加上指令中 **形式地址A**，而形成有效地址，$EA = (PC) + A$，其中 A 是相对于 PC 的偏移量，可正可负，补码表示。可以方便的用于转移指令。执行完指令后 PC 自动加指令字长。

`cmp a, b` 实际上做了 a - b 的运算，然后更新 PSW 寄存器。

### CISC 和 RISC

| 对比项目         | CISC                               | RISC                                 |
| ---------------- | ---------------------------------- | ------------------------------------ |
| 指令系统         | 复杂、庞大                         | 简单、精简                           |
| 指令数目         | 一般大于 200 条                    | 一般小于 100 条                      |
| 指令字长         | 不固定                             | 定长                                 |
| 可访存指令       | 不加限制                           | 只有 Load/Store 指令                 |
| 各种指令执行时间 | 相差较大                           | 多数指令在一个时钟周期内完成         |
| 各种指令使用频度 | 相差很大                           | 都比较常用                           |
| 通用寄存器数量   | 较少                               | 多                                   |
| 目标代码         | 难以用优化编译生成更高效的目标代码 | 采用优化的编译程序，生成代码更为高效 |
| 控制方式         | 绝大多数为微程序控制               | 绝大多数为硬布线(组合逻辑)控制       |

RISC 采用指令流水线技术，使得大部分指令在一个时钟周期内完成，适合流水线的指令系统的特征有：

- 指令长度应尽量一致；
- 指令格式应尽量规整；
- 保证除 Load/Store 指令外的其他指令都不访问存储器；
- 数据和指令在存储器中 **对齐** 存放；

---

## 中央处理器

### CPU 的基本结构

- ALU：运算器
    - ACC：累加基础其
    - PSWR：程序状态字
    - DR：暂存寄存器
- 控制器：
    - PC：程序计数器
    - IR：指令寄存器
    - MAR：存储器地址寄存器
    - MDR：存储器数据寄存器

如果汇编程序员可以操作某寄存器，则该寄存器对用户可见，否则不可见:

- 用户可见寄存器：
    - 通用寄存器
    - PSWR
    - PC
    - ACC
- 用户不可见寄存器：
    - IR
    - DR
    - MAR
    - MDR

程序状态字（PSWR）寄存器：

- OF(Overflow Flag)：溢出标志
- SF(Sign Flag)：符号标志，运算结果为负时置 1
- ZF(Zero Flag)：零标志，运算结果为 0 时置 1
- CF(Carry Flag)：进位/借位标志，进位/借位时为1
- AF(Auxiliary carry Flag)：辅助进位标记，记录运算时第三位(半个字节)产生的进位
- PF(Parity Flag)：奇偶标志
- DF(Direction Flag)：方向标志，在串行指令中控制信息的方向
- IF(Interrupt Flag)：中断标志
- TF(Trap Flag)：陷阱标志

### 指令的执行过程

指令周期一般如下，指令周期一般比较灵活：

> 指令周期 = 取址周期 + 间址周期 + 执行周期 + 中断周期

- 取值周期：
    - PC -> MAR -> 地址总线 -> 主存
    - CU -> 读 -> 控制总线 -> 主存
    - 主存 -> 数据总线 -> MDR -> IR
- 间址周期
    - Address(IR/MDR) -> MAR -> 地址总线 -> 主存
    - CU -> 读 -> 控制总线 -> 主存
    - 主存 -> 数据总线 -> MDR
- 执行周期：不同指令不同
- 中断周期：
    - CU -> SP-- -> MAR -> 地址总线 -> 主存
    - CU -> 写 -> 控制总线 -> 主存
    - PC -> MDR -> 数据总线 -> 主存（程序断点存入主存）
    - CU (中断服务程序入口地址) -> PC

* MUX：多路选择器
* CM：控制存储器

### 控制器的功能和工作原理

| 控制方式   | 设计思想                                                                                                                       | 特点                                                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| 硬布线控制 | 位操作控制信号由组合逻辑电路根据当前的指令马、状态和时序，即时产生                                                             | 控制器的速度取决于电路延迟，速度快，逻辑线路固定，难以扩充和修改，结构复杂，不规整，通常应用于 RISC 结构的CPU              |
| 微程序控制 | 采用存储程序的原理，将微操作控制信号以微程序的形式存放在控制存储器中，一条机器指令对应一个微程序，执行指令时读出微程序执行即可 | 每条指令都要从控制存储器中读取，速度较慢，可通过改变控制存储器中的内容进行扩充和修改，结构规整；通常应用于 CISC 结构的 CPU |

* 三级时序系统：一般由**机器周期**、**节拍** 和 **定时脉冲** 三级时序组成；为指令的执行产生时序信号；控制部件根据组合条件形成相应的逻辑关系,再与时序信号组合,便可产生所需的控制信号。

- 水平微指令：一次能定义并执行多个并行操作微命令的微指令
- 垂直微指令：设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能

| 编码方式 | 直接编码                                                                                                                     | 字段直接编码                                                                                                                                                                                |
| -------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 实现方法 | 微指令的控制字段中的每一位都代表一个指令，设计微指令时，选用或不选用某个微指令。只要将表示该微指令的对应位设置成 1 或 0 即可 | 将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一个字段中，把相容性命令组合在不同的字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关      |
| 特点     | 简单、直观；指令字长过长，$n$ 各微命令就要求微指令的操作字段有 $n$ 位                                                        | 1. 互斥性微命令分在同一段内，相容性微命令分在不同段内；2. 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间；3. 一般每个小段还要留出一个状态，表示本字段不发出任何微命令 |


- 一条 **机器指令** 实际上是对一系列 **微指令** 的封装
- 一条 **微指令** 实际上是对一系列 **微命令** 的封装
- 一个 **微命令** 实际上是控制一系列 **三态门** 的 **闭合/断开**
- 当下一个 **时钟节拍** 到来时，就可以控制相关的 **时序逻辑电路**

---

### 指令流水线

将一条指令的执行过程分成多个子过程，每个 **子过程** 与 **其他子过程** 通过各自 **独立的功能部件** **并行** 执行。

流水线的每个子过程由专用的功能段实现，各功能段所需时间应尽量相等，否则，实现长的功能段将成为流水线的瓶颈。

流水线阻塞的因素：

- 结构相关：由于多条指令在同一时刻竞争同一资源而形成的冲突
    - 前一指令访存时，使后一条相关指令（以及后续指令）暂停一个时钟周期
    - 单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，属于 **资源重复配置**。
- 数据相关：在一个程序中，存在必须等前一条指令执行完成才能执行后一条指令的情况，那么这两条指令即为数据相关
    - 把遇到的数据相关指令及其后续指令都暂停一个或多个时钟周期，知道数据相关问题消失后再继续执行。
    - 设置相关专用通路，即不等前一条指令把计算结果写入寄存器组，下一条指令也不再读寄存器组，而是直接把前一条指令的 ALU 的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作可以继续执行，称之为 **数据旁路技术**。
- 控制相关：当流水线遇到转移指令和其他改变 PC 值得指令而造成断流时，会引起控制相关阻塞。
    - 尽早判断转移是否发生，尽早生成转移目标地址
    - 预取转移成功和不成功两个控制流方向上的目标指令
    - 加快和提前形成条件码
    - 提高转移方向猜测的准确率

| 时间单位 | 符号 | 与秒的关系  |
| -------- | ---- | ----------- |
| 秒       | $s$  | $1s$        |
| 毫秒     | $ms$ | $10^3 s$    |
| 微秒     | $us$ | $10^6 s$    |
| 纳秒     | $ns$ | $10^9 s$    |
| 皮秒     | $ps$ | $10^{12} s$ |
| 飞秒     | $fs$ | $10^{15} s$ |

---

## 总线

### 总线的分类

总线是一组能为多个部件分时共享的公共信息传送线路。

按功能分类，可以分为以下三类：

- 片内总线：是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。
- 系统总线：计算机系统内部各功能部件（CPU、主存、I/O接口）之间互相连接的总线。
- 通信总线：用于计算机系统之间或计算机系统与其他系统之间信息传送的总线。

---

**系统总线** 按传输的内容不同，可以分为以下三类：

- 数据总线：双向传输总线，既可以把CPU的数据传送到存储器或输入输出接口等其他部件，也可以将其他部件的数据传送到CPU。位数与机器字长、存储字长有关。数据的含义是广义的，可以是真正的数据，也可以是指令代码或状态信息，甚至可以是控制信息，因此数据总线上传送的并不一定仅仅是真正意义上的数据。
- 地址总线：单向传输总线，用来指出数据总线上的源数据或目的的数据所在的主存单元或I/O端口的地址，位数与存储单元的个数有关。
- 控制总线：传输控制信息，包括CPU送出的控制命令和主存或外设返回 CPU 的反馈信号。

---

按连接部件不同，分为：

- 处理机总线：连接 CPU - 北桥芯片
- 主存总线：连接 主存 - 北桥芯片
- I/O总线：连接各种 I/O 控制器 - 南桥芯片

---

按传送格式总线被划分为 **并行总线** 和 **串行总线**

---

按总线定时方式分类：

- 同步通信总线：在同步通信方式中，系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个时间间隔构成一个总线周期。在一个总线周期中，发送方和接收方进行一次数据传送。因为采用统一的时钟，每个设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。
- 异步通信方式：在异步通信方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的 **握手** 信号来实现定时控制。主设备提出交换信息的 请求 信号，经接口传送到设备；从设备接到主设备的请求后，通过接口向主设备发出 应答 信号。

根据请求和应答信号的撤销是否互锁，有分为：

- 不互锁
- 半互锁
- 全互锁

### 总线的性能指标

| 性能指标     | 定义                                               |
| ------------ | -------------------------------------------------- |
| 总线时钟周期 | 一般是机器的时钟周期                               |
| 总线时钟频率 | 总线时钟周期的倒数                                 |
| 总线传输周期 | 一次总线操作所需要的时间，包含若干个总线时钟周期   |
| 总线工作频率 | 总线传输周期的倒数                                 |
| 总线宽度     | 总线上能同时传输的数据位数，通常是指数据总线的根数 |
| 总线带宽     | 单位时间内总线上可以传输的数据的位数               |

> $总线带宽 = 总线宽度 \times 总线工作频率$

**猝发（突发）总线** 方式只需要一次地址传输，然后传输多个存储地址连续的数据。

---

### 总线标准

系统总线:

- ISA 并行总线 (1984)
- EISA 并行总线 (1988)，在 ISA 的基础上增加位宽
- FBS、QPI 串行总线，Intel提出用于连接 CPU 与北桥芯片

---

局部总线：

- VESA 并行总线 (1991)，用于传输图像
- PCI 并行总线 (1992)，用于连接显卡、声卡、网卡等，支持即插即用
- APG 并行总线 (1996)，在PCI2.1 基础上扩展而来，用于连接显存与主存
- PCI-E 串行总线 (2001)，工作频率很高，支持全双工通信

设备总线（通信总线）：

- RS-232C 串行总线 (1970)，用于极慢速的电传打印机
- SCSI 并行总线 (1986)，用于连接硬盘、打印机、扫描仪等
- PCMCIA 并行总线 (1991)，用于连接外部存储卡，目的是增强个人电脑的信息互换
- USB：串行总线 (1996)，采用差模信号，每次传递 1bit，工作频率可以很高
- IDE：并行总线 (1986)，又称 ATA 总线，Parallel ATA，主要用于连接硬盘、光驱等
- SATA：串行总线 (2001) Serial ATA，主要用于连接硬盘、光驱等

总线发展趋势：串行总线逐渐替代了并行总线

### 总线仲裁

- 链式查询方式需要 3 根信号线
- 计数器查询方式需要 $\lceil\log_2n + 1\rceil$ 根信号线
- 独立请求方式需要 $2n$ 根信号线，$n$ 为设备数

---

## 输入输出系统

* 道密度是磁盘半径方向单位长度的磁道数
* 位密度是磁道单位长度上能记录的二进制代码位数
* 面密度是位密度和道密度的乘积

---

- 存取时间 = 寻道时间 + 延迟时间 + 传输时间
- 磁盘数据传输速率 = 转速 $\times$ 每道信息量
- 平均等待时间 = $\displaystyle\frac{1}{2r}$
- 地址格式：驱动器号 + 柱面（磁道）号 + 盘面（磁头）号 + 扇区号

---

* **平均寻道时间** 是磁头从开始移动到数据所在的磁道所花费时间的平均值。
* **平均等待时间（延迟时间）** 是磁头已处于要访问的磁道，等待所要访问的 **扇区** 旋转至 **磁头** 下方的时间。
* CPI 表示一条只能需要的时钟周期
* **数据传输率** 磁盘存储器在单位时间内向主机传送数据的字节数。 数据传输率 = 磁盘转速 * 磁道容量

---

磁盘阵列 RAID：

0. 无冗余无校验
1. 镜像磁盘
2. 采用海明码
3. 位交叉奇偶校验
4. 块交叉奇偶校验
5. 无独立校验的奇偶校验
