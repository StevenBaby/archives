# 计算机组成原理拾遗

[annotation]: <id> (7a6aeaea-9bcc-43e7-8463-086a32bcbd24)
[annotation]: <status> (public)
[annotation]: <create_time> (2020-10-13 22:59:10)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (组成原理)
[annotation]: <comments> (false)
[annotation]: <url> (http://blog.ccyg.studio/article/7a6aeaea-9bcc-43e7-8463-086a32bcbd24)

## 概述

- 时钟周期(Clock Cycle)：通常为节拍脉冲或T周期，即主频的倒数，是CPU中最小的时间单位。
- 主频：机器内部的时钟频率。时钟周期的倒数。
- CPI (Clock cycle Per Instruction)：执行一条指令所需的时钟周期数。
- CPU执行时间：运行一个程序所花费的时间
  - $\displaystyle CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{指令条数 \times CPI}{主频}$
- MIPS (Million Instruction Per Second)：每秒执行多少百万条指令
  - $\displaystyle MIPS = \frac{指令条数}{执行时间 \times 10^6} = \frac{主频}{CPI}$
- MFLOPS (Million Float Operation Per Second)：每秒执行多少百万次浮点运算
  - $\displaystyle MFLOPS = \frac{浮点运算次数}{执行时间 \times 10^6}$
- GFLOPS：每秒执行多少十亿次浮点运算
  - $\displaystyle GFLOPS = \frac{浮点运算次数}{执行时间 \times 10^9}$
- TFLOPS：每秒执行多少万亿次浮点运算
  - $\displaystyle TFLOPS = \frac{浮点运算次数}{执行时间 \times 10^{12}}$
- PFLOPS：每秒执行多少千万亿次浮点运算
  - $\displaystyle PFLOPS = \frac{浮点运算次数}{执行时间 \times 10^{15}}$

计算机容量单位

| 单位 | 数量      | 存储容量        |
| ---- | --------- | --------------- |
| K    | $10^3$    | $2^{10} = 1024$ |
| M    | $10^6$    | $2^{20}$        |
| G    | $10^9$    | $2^{30}$        |
| T    | $10^{12}$ | $2^{40}$        |
| P    | $10^{15}$ | $2^{50}$        |
| E    | $10^{18}$ | $2^{60}$        |
| Z    | $10^{21}$ | $2^{70}$        |

----

## 数据的表示和运算

### 数据存储方式

- 小端方式(Little Endian)：先存储低位字节，后存储高位字节
- 大端方式(Big Endian)：先存储高位字节，后存储低位字节

---

存储 `0x12345678` 到一个 `int` 变量中：

| 地址 | 0x00 | 0x01 | 0x02 | 0x03 |
| ---- | ---- | ---- | ---- | ---- |
| 小端 | 78   | 56   | 34   | 12   |
| 大端 | 12   | 34   | 56   | 78   |

---

### 边界对齐

假设存储字长 32bit，可按字节、半字、字寻址，在对准边界32位字长的计算机，半字地址是 2 的整数倍，字地址是 4 的整数倍，当所存数据不能满足此要求时，可填充一个或多个空白字节，这样无论所存的是字节、半字还是字，均可以一次访存取出。

当数据不按边界对齐方式存储时，一个字的数据可能存储在两个存储字中，此是需要两次访存，并对高低字节的位置进行调整后才能取出一个字，影响了系统的效率。

下面为 C 语言中禁止边界对其的代码。

```c
#define _packed __attribute__((packed))
```

### 定点数的表示

- 正数的 **原码**、**补码**、**反码** 都是一样的
- 负数的补码：符号位不变，数值部分按位取反，末位加一
- 补码的负数的补码：连同符号位一起，各位取反，末位加一
- 负数的反码，符号位不变，数值部分按位取反

C 语言中 的数据类型，一般用补码表示：

| 类型    | 所占位数 | 数的范围                      |
| ------- | -------- | ----------------------------- |
| `char`  | 8        | $-128 \sim 127$               |
| `short` | 16       | $-32768 \sim 32767$           |
| `int`   | 32       | $-2147483648 \sim 2147483647$ |
| `long`  | 32       | $-2147483648 \sim 2147483647$ |

符号拓展：

- 正数：原符号位移动到新符号位上，新表示形式的所有附加位都用 0 进行填充
- 负数原码：原符号位移动到新符号位上，新表示形式的所有附加位都用 0 进行填充
- 负数补码、反码：原符号位移动到新符号位上，新表示形式的所有附加位都用 1 进行填充

### 数据转换

| 数据类型的转换                       | 转换原则                     |
| ------------------------------------ | ---------------------------- |
| 同一类型但字长不同的数据间转换       | 由字长短的转为字长长的       |
| 定点方式与浮点方式间的转换           | 由定点数转换为浮点数         |
| 整型数种的有符号数和无符号数间的转换 | 机器数不变，知识解释方式不同 |

隐式类型转换：

```c
char -> int -> long -> float -> double
```

### 补码一位乘法 （Booth算法）

进行 n 轮加法、移位，最后再多来一次加法。

每次加法根据当前 MQ寄存器中的最低位、辅助位来确定，

可能 +0、$+[x]_{补}$、$+[-x]_{补}$

- 辅助位 - 最低位 = 1 时, $(ACC) + [x]_补$
- 辅助位 - 最低位 = 0 时, $(ACC) + 0$
- 辅助位 - 最低位 = -1 时, $(ACC) + [-x]_补$

其他注意点补充：

- 辅助位是实际上寄存器中的最低位
- 最低位是补码乘数的最低位，也就是在最低位之后加一位辅助位
- 补码乘法符号位必须参与运算
- 被乘数使用双符号位补码
- 乘数使用单符号位补码

### 溢出判断

用两位符号位来做溢出判断

- 00 结果为正，无溢出
- 01 正溢出
- 10 负溢出
- 11 结果为负，无溢出

### 原码除法 恢复余数法

### 原码除法 加减交替法

### 补码除法

- 数据都用补码表示，符号位参与运算
- 初始时观察被除数与除数符号，同号做减法，异号做加法
- 若余数与除数同号，则商1后余数左移一位减去除数，若余数与除数异号，则商0后余数左移一位加上除数
- 重复上一步操作，直到得到 n 位商
- 一般在末尾补上一个1

### 浮点数的运算

左规：当尾数出现 

- 00.0xxxx (原码或补码正数)
- 11.1xxxx (补码负数)

需要左规（尾数左移，阶码减一），可能出现多次左规，规格化后结果形为

- x.1xxxxx (原码或补码正数)
- x.0xxxxx (补码负数)

右规：当尾数求和出现 10.0xxxxx 或 01.1xxxxx 时，需要右规（尾数右移，阶码加一），且仅需要一次右规。

### ALU

74181 是四位并行加法器。
74182 是多个 74181 并行进位的辅助芯片，一块 74182 可以并四块 74181。先行进位加法器。

---

## 存储器的层次结构

- 双端口存储器：指同一个存储器具有两组相互独立的读写控制线路
- 相联存储器：访问相联存储器只需要给出内容，不需要给出地址，因此，相联存储器又被称为按内容访问存储器。
- 顺序存储器：某个模块进行存取时，其它模块不工作，某一模块出现故障时，其它模块可以照常工作，通过增添模块来扩充存储器容量比较方便，但各模块串行工作，存储器的带宽收到了限制。顺序方式中连续地址基本分布在同一模块内，同一模块内的地址是连续的。
- 交叉存储器：地址码的低位字段经过译码（片选，非门）选择不同的模块，而高位字段指向相应模块内的存储字。连续地址分布在相邻的不同模块内，同一模块内的地址是不连续的；对连续字的成块传送可实现多模块并行存取，提高了存储器的带宽。

* 全地址译码：用全部的高位地址信号作为译码信号，使得存储器芯片得每个单元都单独占据一个唯一得内存地址。
* 部分译码法：用 **部分** 高位地址信号作为译码信号，使得被选中的存储器芯片占有几组不同的地址范围。
* 交叉编址

**$0x1000 = 2^{12} = 4096$**

- 死区：刷新存储器所用的时间
- 死时间率：刷新存储器所用的时间的占比

常见的刷新方式有集中式、分散式和异步式三种。其中：

- 集中刷新方式的 **死区** 最大，而且随着存储容量的增大（存储矩阵的增大），**死区** 也会增大；
- 异步刷新方式的 **死区** 最小，仅等千一个读写周期；
- 分散刷新方式则没有 **死区**；

直接映射

主存地址 = 主存字块标记 + cache 字块标记 + 块内地址

全相联映射

主存地址 = 主存字块标记 + 块内地址

组相联映射

主存地址 = 主存标记 + 组号 + 块内地址

写回法指 CPU 在执行写操作时，被写数据只写入Cache, 不写入主存。仅当需要替换时，才把已经修改过的Cache 块写回到主存。
- 如果 **脏位** 为 1，则必须先把这一块写回到主存中去之后才能调入新的块； 
- 如果 **脏位** 为 0，则这一块不必写回主存，只要用新调入的块覆盖掉这一块即可。

---

## 中央处理器

* 三级时序系统：一般由**机器周期**、**节拍** 和 **定时脉冲** 三级时序组成；为指令的执行产生时序信号；控制部件根据组合条件形成相应的逻辑关系,再与时序信号组合,便可产生所需的控制信号。

- 水平微指令：一次能定义并执行多个并行操作微命令的微指令
- 垂直微指令：设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能

- 直接编码：
- 字段间接编码：
- 字段直接编码：

条件符号寄存器：

- OF(Overflow Flag)：溢出标志
- SF(Sign Flag)：符号标志，运算结果为负时置 1
- ZF(Zero Flag)：零标志，运算结果为 0 时置 1
- CF(Carry Flag)：进位/借位标志，进位/借位时为1
- AF(Auxiliary carry Flag)：辅助进位标记，记录运算时第三位(半个字节)产生的进位
- PF(Parity Flag)：奇偶标志
- DF(Direction Flag)：方向标志，在串行指令中控制信息的方向
- IF(Interrupt Flag)：中断标志
- TF(Trap Flag)：陷阱标志

---
## 总线

按传送格式总线被划分为 **并行总线** 和 **串行总线**

**猝发总线** 方式只需要一次地址传输

**PCI-Express** 采用并行传输方式

- 链式查询方式需要 3 根信号线
- 计数器查询方式需要 $\lceil\log_2n + 1\rceil$ 根信号线
- 独立请求方式需要 $2n$ 根信号线，$n$ 为设备数

---

## 输入输出系统

* 道密度是磁盘半径方向单位长度的磁道数
* 位密度是磁道单位长度上能记录的二进制代码位数
* 面密度是位密度和道密度的乘积

---

- 存取时间 = 寻道时间 + 延迟时间 + 传输时间
- 磁盘数据传输速率 = 转速 $\times$ 每道信息量
- 平均等待时间 = $\displaystyle\frac{1}{2r}$
- 地址格式：驱动器号 + 柱面（磁道）号 + 盘面（磁头）号 + 扇区号

---

* **平均寻道时间** 是磁头从开始移动到数据所在的磁道所花费时间的平均值。
* **平均等待时间（延迟时间）** 是磁头已处于要访问的磁道，等待所要访问的 **扇区** 旋转至 **磁头** 下方的时间。
* CPI 表示一条只能需要的时钟周期
* **数据传输率** 磁盘存储器在单位时间内向主机传送数据的字节数。 数据传输率 = 磁盘转速 * 磁道容量

---

磁盘阵列 RAID：

0. 无冗余无校验
1. 镜像磁盘
2. 采用海明码
3. 位交叉奇偶校验
4. 块交叉奇偶校验
5. 无独立校验的奇偶校验
