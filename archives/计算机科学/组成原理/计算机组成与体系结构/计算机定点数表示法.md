# 计算机定点数表示法

[annotation]: <id> (b694810d-f3da-42f5-8318-985994ecdfc7)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 11:46:23)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (组成原理)


计算机中有众多的数值表示方式，这里重点讨论定点数的表示方法，除此以外还有浮点数的表示方法。

计算机中的数据都是存储在二进制位中的，这一点毋庸置疑。所以要表示数字就需要规定二进制位和实际数字之前的关系。于是就出现了**定点数表示法**。

定点数表示法是因为小数点的位置是固定的，并且假定小数点在最左边，代表是纯小数。在右边，代表纯整数。

在定点数表示法中，参与运算的数以及运算结果都必须保证落在定点数所能表示的数值范围之内，否则称为 **溢出**。这时计算机将终止计算，进行溢出处理。

## 无符号数和带符号数

**无符号数**，就是整个全部二进制位均用于表示数值，相当于数的绝对值。例如

- 01001 表示无符号数 9
- 11001 表示无符号数 25

> 特别提示：<br>
>$0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 0 + 8 + 0 + 0 + 1 = 9$<br>
>$1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 16 + 8 + 0 + 0 + 1 = 25$


然而，生活中用到的数大多数时有符号的，也就是有正也有负。符号常用 + - 号来表示数的正负。用这种形式表示的数值在计算机中称为 **真值**。

计算机中也需要能够表示正负的数，需要用二进制来表示带符号数。通常约定二进制数的最高位为符号位。0表示正，1表示负。这种表示数的形式成为 **机器数**，常见表示机器数有 **原码**、**反码**、**补码** 等不同的形式。

带符号数的最高位用来表示正负，而不再表示数值，于是前面例子中的两个数二进制的含义就发生了一些变化，如：

- 01001 表示 +9
- 11001 表示 原码 -9，补码 -7，反码 -6

> 特别提示 <br>
正数 $+ (1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0) = +9$ <br>
原码 $- (1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0) = -9$

数据由带符号数转换为同一长度的无符号数时，原来的符号位不再是符号位，而成为数值的一部分，所以负数转换为无符号数时，数值将发生变化。反之，数据由无符号数转换为带符号数时，各个二进制位的状态不变，但最高位被当作符号位，此时，数值也可能发生变化。

## 原码表示法

> 特别提示：原码表示法又称 **符号幅值表示法**

原码表示法是一种最简单的表示机器数的方法，其最高位为符号位，0为正，1为负。其余位表示数值。特别地，在原码中，0有两种不同的表示形式：

- +0 = 00000000
- -0 = 10000000

**定点表示整数和小时一般只能表示纯整数或者纯小数 $(0\leq N <1)$**

如果表示的是纯整数，原码的定义为：
$$ [X]_{原} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 2^n)\\
& 2^n - X = 2^n + |X| \ \ (-2^n < X \leq 0) \\
\end{aligned}
\right.
$$

如果表示的是纯小数，原码的定义为：
$$ [X]_{原} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 1)\\
& 1 - X = 1 + |X| \ \ (-1 < X \leq 0) \\
\end{aligned}
\right.
$$

不过我觉得也没比较细究这个公式，看起来费脑，不过就是很简单的数值运算。

二进制小数转换为十进制数时，和二进制整数的方式一样，只不过 2 的指数需要依次递减，从最高位开始就变成了 -1，-2 ...，于是有：

- 0.5 = 0.1000000
- 0.75 = 0.1100000
- 0.875 = 0.1110000

可以看出定点数可以表示的小数精度是有限的

原码表示法的优点是直观易懂，机器数和真值的转换很容易。用原码实现乘除法运算的规则很简单；缺点是实现加减运算的规则较复杂。

## 补码表示法

**模** 是指一个计量器的容量，可用M表示。例如：一个4位二进制数的计数器。计数器从 1111(15)，在加1，就变成了 0000(0)，由于计数器长度只有四位，所以进位被丢弃。所以这个计数器的容量 M = 16。

**同余** 是指两个整数 A 和 B 除以同一正整数M，所得到的余数相同，则称 A B 同余。记作

$$A \mod M = B \mod M$$

补码表示法的符号位与原码表示法相同，0表示正，1表示负。对于正数，数值部分与真值相同；对于负数，将真值的数值**按位取反**，然后再加 1。

也就是说，补码表示法中正数与原码表示法相同，不同的是负数数值的表示：

> **按位取反再加一**

例如：

- 正数 $01101_原 = 01101_反$
- 补码负数 $11101_原 = (10010 + 1) = 10011_补$
- > 特别提示：最高位为符号位，不参与运算

如果表示的是纯整数，补码的定义为：
$$ [X]_{补} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 2^n)\\
& 2^{n+1} + X = 2^{n-1} - |X| \ \ (-2^n \leq X < 0) \\
\end{aligned}
\right.
$$

如果表示的是纯小数，补码的定义为：
$$ [X]_{补} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 1)\\
& 2 + X = 2 - |X| \ \ (-1 \leq X < 0) \\
\end{aligned}
\right.
$$

虽然补码表示法看起来有点别扭，但是对于大多数重要的运算，加法和减法，它是及其方便的。正因为如此，几乎所有的处理器都是采用这种方法来表示整数。

## 反码表示法

反码表示法与补码表示法有许多类似之处，对于正数，表示方式相同。对于负数，其真值的数值部分**按位取反**即可。

> 对于正数：原码、补码、反码 表示方式是一样的
> 
> 对于负数
> - 反码需要对真值在原码的基础上**按位取反**
> - 补码需要在反码的基础上再加一，从原码操作看来就是 **按位取反再加一**

例如：

- 正数 $01101_原 = 01101_反$
- 反码负数 $11101_原 = 10010_反$
- > 特别提示：最高位为符号位，不参与运算

如果表示的是纯整数，反码的定义为：
$$ [X]_{反} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 2^n)\\
& 2^{n+1} + X \ \ (-2^n < X \leq 0) \\
\end{aligned}
\right.
$$

如果表示的是纯小数，反码的定义为：
$$[X]_{反} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 1)\\
& (2 - 2^{-n}) + X \ \ (-1 \leq X < 0) \\
\end{aligned}
\right.
$$

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings](#)
- [计算机组成原理 - 蒋本珊 编著](#)