# 计算机整数算术

[annotation]: <id> (0341afd0-66bf-45b5-86c1-979922de3ee2)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 15:20:12)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (组成原理)

> 原文链接：<http://blog.ccyg.studio/article/0341afd0-66bf-45b5-86c1-979922de3ee2>

在阅读这篇文章之前，强烈建议阅读 [计算机定点数表示法](http://blog.ccyg.studio/article/b694810d-f3da-42f5-8318-985994ecdfc7)，以理解计算机中定点数的表示方式。

## 取负

在原码表示法中，求一个整数的负数是很简单的：只需要将符号位取反，也就是由0变成1，或者由1变成0。

在补码表示法中，求一个整数负数可用一下规则：

1. 将整数的每一位（包括符号位）取反，即把每一个1变成0，0变成1
2. 将此取反结果作为一个无符号二进制整数对待，再加1

以上两步称为**求补运算**，例如：

$+18 = 00010010_补 \xlongequal{按位取反}11101101 \xlongequal{ +1 } 11101110 = -18$

若对次数再进行取负操作，则正如我们希望的那样，负数还是原来的那个数：

$-18 = 11101110_补 \xlongequal{按位取反}00010001 \xlongequal{ +1 } 00010010 = +18$

特别的对于0，来说

$0 = 00000000_补 \xlongequal{按位取反}11111111 \xlongequal{ +1 } 100000000 \xlongequal{舍去进位} = 00000000 = 0$

上面加1时，最高位有一个进位，由于数据位有限，可以忽略该进位。结果0求负数还是0，正如我们期望的那样。

特别地对于一个八位的字：

$-128 = 10000000_补 \xlongequal{按位取反}01111111 \xlongequal{ +1 } 10000000 = -128$

这样的一些意外情况在所难免，因为-128在八位二进制数中本身就是一个特殊的存在。

## 加法和减法

> 加法和减法本质上都是加法，对于减法，只是变成了加上一个**相反数**

补码表示法的加法执行过程和无符号整数加法一样，如果操作的结果为正，那么补码的表示和原码表示时一样的。如果结果为负，则表示负数的补码形式。注意在某些情况下，最高位会有一个进位，它超出了字的长度，将被丢弃，从而忽略不计。

对于任一加法操作，如果出现结果的长度大于正被使用的字的长度，那么这种情况被称为**上溢**。当上溢出现时，运算器必须报告错误，以通知其他部件不要试图使用此结果。判断上溢的规则如下：

**上溢规则**：两个数相加，若他们同为正数或者负数，则当且仅当结果的符号位变相反时才发生上溢。

**减法规则**：由一个数减（被减数）去另一个数（减数），则之需求出减数的补码，并把它加到被减数上。于是减法可以用加法实现。

下图中给出了实现加法和减法的数据通路和所需硬件元件。中心原件是一个二进制加法器，它对输入的两个数进行相加，产生一个和以及一个上溢指示。二进制加法器将两个数看作是无符号数。对于加法，提交给加法器的两个数来自寄存器，图中是A寄存器和B寄存器。结果通常是存于这两个寄存器中的某一个或者是另外的第三个寄存器。上溢指示保存一个1位的上溢标志中（overflow flag 0表示无上溢，1表示有上溢）。对于减法，减数（B寄存器）要通过补码求补器产生减数的补，并提交给加法器。注意途中只是显示了数据通路。还需要一些控制信号，根据当前执行的操作是加法还是减法，来控制是否需要使用求补器。

![](images/加法硬件框架图.svg?sanitize=true)

## 乘法

与加法和减法相比，无论是以硬件还是软件来完成，乘法都是一个复杂的操作。各种各样的算法已用于各类计算机中。给读者常用算法的感性认识。首先介绍如何实现两个无符号数整数相乘的简单方法，然后再实现补码表示数乘法的最通用技术。

### 无符号数整数乘法

如图所示 与我们手动演算的一样，乘法可以进行如下操作：

1. 乘法涉及部分积生成，乘数的每一位对应一个部分积。然后，部分积相加得到最后的乘积。
2. 部分积是容易确定的。当乘数的位是0，其部分积也是0；当乘数位是1，其部分积是被乘数。
3. 部分积通过求和而得到最后乘积。因此后面的部分积总要比它前面的部分积再左移一个位置。
4. 两个n位二进制数的乘法可产生的最大长度为 2n 位的积，（如 $11 \times 11 = 1001$）

<img src='images/无符号二进制整数乘法.svg?sanitize=true' width=400 />

与纸笔手工演算相比，计算机能做一些改进使得乘法操作更有效。首先可以边产生部分积边做加法，而不是等到最后再相加。这就消除了存储所有部分积的需求，从而减少了所需的寄存器数量。其次，能节省部分积的生成时间，对于乘数的每个1，需要执行的加和移位操作；对于每个0，则只执行移位操作就可以了。

如下图所示，这是一种采用上述改进的实现方案：

![无符号二进制乘法图](images/无符号整数乘法硬件框图.svg?sanigize=true)

乘数和被乘数分别装入两个个寄存器（Q和M）。保存部分积需要第三个寄存器，寄存器A，初始设置为0。还需要一个1位寄存器C，初始设置为0，用于保存加法可能产生的进位。

乘法操作器的操作如下图所示：

![无符号二进制乘法操作器图](images/无符号二进制乘法流程图.svg?=sanitize=true)

控制逻辑每次读乘数的一位。若Q0是1，则被乘数与A寄存器相加，并将结果存于A寄存器。然后C、A和Q各寄存器的所有位向右移一位，于是C位进入 $A_{n-1}$，$A_0$ 进入 $Q_{n-1}$ 而 $Q_0$ 丢失 若 
$Q_0$ 是 0 ，则只需要移位。不需要进行加法运算。对原始的乘数每一位重复上述过程。产生的2n位存于A和Q寄存器。注意下面例子中的第二个周期，因为乘数当前位是0，所以该周期没有加法运算。

**无符号数二进制乘法硬件实现表**

| C-进位<br>0 | A-部分积<br>0000 | Q-乘数<br>1101 | M-被乘数<br>1011 | 初始值 | 周期 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0<br>0 | 1101<br>0000 | 1101<br>1101 | 1101<br>1011 | 加<br>移位 | 第一周期 |
| 0 | 0010 | 1111 | 1011 | 移位 | 第二周期 |
| 0<br>0 | 1101<br>0110 | 1111<br>1111 | 1011<br>1011 | 加<br>移位 | 第三周期 |
| 1<br>0 | 0001<br>1000 | 1111<br>1111 | 1011<br>1011 | 加<br>移位 | 第四周期 |


## 补码乘法

如前所知，对补码表示的数将他们看作是无符号数来完成加减法运算。

```text
 1001
+0011
-----
 1100
```

若将这些数看成是无符号整数，则是 9(1001) + 3(0011) = 12(1100) 。若看成是补码整数，则是 -7(1001) + 3(0011) = -4(1100)。

遗憾的是，这种简单的做法不能用于乘法。说明如果被乘数和乘数都是负数，简单直接的乘法将无法使用。实际上，被乘数和乘数只要有一个负数就不行。

如前所知，任何一个无符号二进制数都可以表示成2的幂之和，例如：

$$1101_2 = 1 \times 2 ^ 3 + 1 \times 2 ^ 2 + 0 \times 2 ^ 1 + 1 \times 2 ^ 0 = 2^3 + 2^2 + 2^0 = 8 + 4 + 1 = 13$$

而且，一个数乘以 $2^n$可以通过左移此数 n 位来完成。为了理解这一点，如下所示，这是对前文乘法的改造。唯一不同在于，把由 n 位被乘数产生的部分积当作是一个 2n位的数。

```text
    1001
   x0011
--------
00001011
00000000
00101100
01011000
--------
10001111
```

于是，作为一个无符号数，4位被乘数1011 是以一个 00001111的8位字来保存的。每个部分积由这个数左移（0除外）。并且空出的位以0填充而组成。

## 除法

下图表示一个无符号二进制整数长处的例子：

<img src='images/无符号二进制整数除法举例.svg?sanitize=true' width=600 />

详细描述这个过程是有指导意义的。首先，从左到右检查被除数的位，直到被检查的位能表示的数大于或等于除数；这被称为除数能去 **除** 此数。直到这个事件发生之前，一串0从左到右被放入商中。当上述时间发生时，一个1被放入商中，并且从这个部分被除数中减去除数。结果称为**部分余**。因此开始除法呈现出一种循环样式。在每一次循环中，被除数的其他位续加到部分余上，直到所构成的数大于或等于除数。同前面一样，除数由这个数中减去并产生新的部分余，此过程继续下去，直到被除数的所有位都被用完。

下图表示了对此长出过程的机器算法：

<img src='images/无符号二进制整数除法流程.svg?sanitize=true' />

除数放入M寄存器，被除数放在Q寄存器中。每一步A和Q寄存器一起左移一位。然后A减M以确定A是否能分出部分余来，若够减，则$Q_0$ 位变为1。否则，$Q_0$ 位为0，并且M必须被返加到A以恢复原先的值。计数值然后减1，此过程持续进行n步。结束时，商保存在Q寄存器中，余数保存在A寄存器中。


## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings](#)