# 计算机浮点数表示法

[annotation]: <id> (f3800a51-4236-46d2-85c9-d983e4e95968)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 20:56:48)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (组成原理)


使用定点数表示法，能表示以0为中心一定范围内的正数和负数。通过重新设定小数点的位置，这种格式也能用来表示小数。不过这种方法有明显的限制，不能表示很大的数，也不能表示很小的小数，而且当两个大数相除时，商的小数部分可能会丢失。

对于十进制数，解除这种限制的方法时使用 **科学计数法**，于是 976 000 000 000 000 可以表示成 $9.76 \times 10 ^ {14}$，而 0.000 000 000 000 097 6 可以表示成 $9.76 \times 10 ^ {-14}$。实际上的操作是，我们动态的移动了小数点到合适的位置，并使用10的指数来确定小数点的位置。这就允许只使用少数几个数字来表示很大范围和很小的数。

这种 **科学计数法** 也可以用于二进制数，可以使用如下形式来表示一个数：

$$ \pm S \times B ^{\pm E}$$

这样的数保存在一个二进制字的三个字段中:

- **符号**：正或者负
- **有效值** S (significand) 或者 **有效数字**
- **阶值** E (exponent) 或者 **指数**

指数的底或者基是隐含的，因为对于所有的数他都是相同的，因此是不需要存储的。通常，小数点的位置约定在最左（最高）有效位的右边，也就是小数点左边有1位。

下图表示了一个典型的32位浮点格式，最左位保存符号(0正，1负)。阶值存于1到8位，所用的表示法时称为**移码表示法**。从字段中减去一个**偏移量**，这个偏移量是一个固定值，才能得到真正的指数。通常偏移量等于 $2^{k-1} - 1$，k是二进制指数的位数。在这个例子中。一个8位字段能表示的数是 0 ~ 255，取偏移量为 $127 = 2^{8-1} - 1$，则真实阶值的范围是 -127 ~ +128。此例中的底数被认为是2。

![浮点数格式](images/计算机浮点数表示法-1.svg?sanitize=true)

下面给出了四位整数的移码表示。注意当移码表示法的各位被最为一个无符号整数对待时，其数的大小相对关系并不改变。例如，在无符号数和移码两种表示法中。都是1111最大，而0000最小；然而，在补码表示法中却不是真的了。**使用移码表示法的好处在于，非负的浮点数能作为整数对待，便于进行比较。**字的最后一部分时有效值（上面的例子中时 23 位）。

## 规格化浮点数

任一浮点数都能以多种样式来表示。以下各式是等价的，这里的有效值以二进制格式表示：

$$0.110 \times 2 ^ 5$$
$$110 \times 2 ^ 2$$
$$0.0110 \times 2 ^ 6$$

为了简化浮点数的操作，一般需要对他们进行**规格化**。一个规格化的数是有效值的最高的有效位为非零的数。对于二进制表示法，一个数规格化是它的有效值的最高有效位是1。如前所述，通常约定小数点左边有1位。于是，一个规格化的非零数具有如下格式：

$$ \pm 1.bbb\cdots b\times 2 ^{\pm E}$$

这里的b表示二进制值（0或者1），这意味着有效值的最左位必须是1。因此也没必要总存储这个1，所以它变成了隐含的。于是23位有效字段能用于存储24位有效数字，其值范围在半开区间 [1, 2)。对于一个非规格化的数，通过移动小数点的位置直到第一个1的右面并相应的调整阶，就可以将此数规格化。

举个栗子，下面给出了几个这种规格化形式存储的例子。其中每个栗子左边是二进制数值，中间是对应的二进制位串表示，右边是十进制数值。

$1.1010001 \times 2^{10100} = 0\ 10010011\ 10100010000000000000000 = 1.6328125 \times 2 ^ {20}$
$-1.1010001 \times 2^{10100} = 1\ 10010011\ 10100010000000000000000 = -1.6328125 \times 2 ^ {20}$
$1.1010001 \times 2^{-10100} = 0\ 00010011\ 10100010000000000000000 = 1.6328125 \times 2 ^ {-20}$
$-1.1010001 \times 2^{-10100} = 1\ 00010011\ 10100010000000000000000 = -1.6328125 \times 2 ^ {-20}$

注意以下特征：

- 符号总是位于字的第1位
- 真实的有效值的第1位总是1，并且不需要存于有效值字段中
- 值127加到真实阶值后再存入阶值字段中
- 阶的底数是2

## 浮点数的表示范围

下图显示了这种表示法的32位字能表示的数的范围。使用补码表示法。由 $-2^{31}$ 到 $2^{31} - 1$ 的所有整数都能被表示，总计 $2^32$ 个不同的数。以上图的浮点数格式为例，可以表示如下范围的数：

- 介于 $-(2- 2^{-23})\times 2^{128}$ 和 $-2^{-127}$ 之间的负数
- 介于  $2^{-127}$ 和 $(2- 2^{-23})\times 2^{128}$ 之间的正数

<img alt='2的补码整数' src='images/计算机浮点数表示法-2.svg?sanitize=true' width=40%/>

<img alt='典型的32位格式可表示的数' src='images/计算机浮点数表示法-3.svg?sanitize=true' width=100%/>

数轴上有五个区间不包括在这些范围之内：

- **负上溢**  比 $-(2- 2^{-23})\times 2^{128}$还小的负数
- **负下溢** 比 $-2^{-127}$ 还大的负数
- 零 
- 正下溢 比 $2^{-127}$ 还小的正数
- 正上溢 比 $(2- 2^{-23})\times 2^{128}$ 还大的正数

如前所述，这种表示法不适合值0的表示。然而，下面将会看到，可以把一个专门的位串定义为0，当算术运算的结果其幅值比指数 128 能表达的幅值还大时，则出现上溢（例如 $2^{120} \times 2^{100} = 2 ^{220}$）。当小数的幅值太小时（例如 $2^{-120} \times 2^{-100} = 2 ^{-220}$），则出现下溢。下溢不是一个严重的问题，因为其结果通常足够小而可以近似成0。

注意，使用浮点表示法并不能使我们表示出更多的值。以32位二进制位串能表示不同的值最大数目仍是 $2^{32}$。我们所作的，实际上只是把这些沿着数轴正负两个方向在更大范围内分布。在实际应用中，大多数浮点数只是用户真正想表示数值的一个近似值。不过，对于不是很大的正数而言，浮点表示还是精确的。

还应注意，浮点表示的数不再像定点数那样沿着数轴等距分布，而是越靠近原点，数越密集，越远离原点，数越稀疏。这是浮点算术重要特点之一：**多数计算的结果并不是严格精确的，必须进行舍入，以使得结果达到所能表示的最近似值。**

以上图所示的格式类型为例，一个32位的浮点位串，其中8位用于阶，23位用于有效数字。而范围和精度是要权衡的因素，如果增加阶的位数，也就是扩充了可表示数的范围，但是总的位数时不变的，因此表示的数的总是也是固定不变的，于是实际的效果就是减少了这些数的密度，因而降低了精度。既能增加范围，又能增加精度的唯一途径是使用更多的位。于是大多数计算机都至少能提供单精度和双精度两种浮点数。例如单精度是 32位，双精度是 64位。

> 在 C 语言中:
> - float 的大小是 4个字节，也就是 32位
> - double 的大小是 8个字节，也就是 64位

还有另一种表示浮点数的方法，就是让隐含的底数不是2，而是其他的。这样就使得数可表述的范围更大，不过，相应的精度就会更低。我们并没有增加所能表示数的总数。

## 二进制浮点数的IEEE标准

最重要的浮点数表示法是在1985年通过的IEEE 754标准中所定义的浮点数表示法。开发这个标准是为了提高程序从一种处理器移植到另一种处理器上的可移植性。也是为了促进研制更为复杂的数值运算程序。这个标准获得了广泛的认可，并且已经用于当代各种处理器和算数处理器中。

IEEE 754 标准定义了 32位单精度 `float` 和 64位双精度 `double` 的两种格式。他们的阶值字段分别是8位和11位，底是2，另外，标准还定义了单精度、双精度的扩展格式，但他们的具体格式是与实现相关的。扩展格式包括在阶值字段提供了更多的位（扩展范围）和在有效值字段提供更多的位（扩展精度）。扩展格式将被用于中间计算过程。由于他们有更高的精度，扩展格式是的最终结果避免被过量的舍入，从而减少加大误差的机会，由于有更大的表示范围，扩展格式也使得计算过程出现上溢的机会减少，这样如果计算的最终结果能以基本格式表示，那么就不会因为中间计算过程中的上溢而终止了。对于单精度扩展格式而言，他的一个推动力是它能呈现双精度格式的某些优点，又不导致计算耗时过长，因为通常精度越高，计算耗时也越长。

![](images/计算机浮点数表示法-4.svg?sanitize=true)

### IEEE 754 格式参数

| 参数 | 单精度 | 单精度扩展 | 双精度 | 双精度扩展 |
| - | - | - | - | - |
| 字宽（位数）| $32$ | $\geq 43$| $64$ | $\geq 79$ |
| 阶值位宽（位数）| $8$ | $\geq 11$| $11$ | $\geq 15$ |
| 阶值偏移量 | $127$ | - | $1023$ | - |
| 最大阶值| $127$ | $\geq 1023$| $1023$ | $\geq 16383$ |
| 最小阶值| $-126$ | $\leq -1022$| $-1022$ | $\leq - 16382$ |
| 最小阶值| $-126$ | $\leq -1022$| $-1022$ | $\leq - 16382$ |
| 数的范围 | $10^{-38}, 10^{+38}$ | - | $10^{-308}, 10^{+308}$ | - |
| 有效值位宽（位数） | $23$ | $\geq31$| $52$ | $\geq 63$ |
| 阶值的数目 | $254$ | - | $2046$ | - |
| 小数的数目 | $2^{23}$ | - | $2^{52}$ | - |
| 值得数目 | $1.98 \times 2 ^ {31}$ | - | $1.99 \times 2 ^ {63}$ | - |

> 注：其中 - 表示未指定，不包含隐含位

IEEE 754 格式得所有位模式并不是都已通常的方式解释，某些位模式用来表示特殊值。下表中指出了各种位模式对应的值。全0和全1 这种极端阶值用来定义特殊值。数的分类如下所示。

### IEEE 754 浮点数说明

<table>
    <tbody>
        <tr>
            <td rowspan="2">特殊值</td>
            <td colspan="4">单精度</td>
            <td colspan="4">双精度</td>
        </tr>
        <tr>
            <td>符号</td>
            <td>移码阶值</td>
            <td>小数</td>
            <td>值</td>
            <td>符号</td>
            <td>移码阶值</td>
            <td>小数</td>
            <td>值</td>
        </tr>
        <tr>
            <td>正零</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>负零</td>
            <td>1</td>
            <td>0</td>
            <td>0</td>
            <td>-0</td>
            <td>1</td>
            <td>0</td>
            <td>0</td>
            <td>-0</td>
        </tr>
        <tr>
            <td>正无穷大</td>
            <td>0</td>
            <td>255（全1）</td>
            <td>0</td>
            <td>$\infty$</td>
            <td>0</td>
            <td>2047（全1）</td>
            <td>0</td>
            <td>$\infty$</td>
        </tr>
        <tr>
            <td>负无穷大</td>
            <td>1</td>
            <td>255（全1）</td>
            <td>0</td>
            <td>$-\infty$</td>
            <td>1</td>
            <td>2047（全1）</td>
            <td>0</td>
            <td>$-\infty$</td>
        </tr>
        <tr>
            <td>静默式非数</td>
            <td>0或1</td>
            <td>255（全1）</td>
            <td>$\neq 0$</td>
            <td>NaN</td>
            <td>0或1</td>
            <td>2047（全1）</td>
            <td>$\neq 0$</td>
            <td>NaN</td>
        </tr>
        <tr>
            <td>通知书非数</td>
            <td>0或1</td>
            <td>255（全1）</td>
            <td>$\neq 0$</td>
            <td>NaN</td>
            <td>0或1</td>
            <td>2047（全1）</td>
            <td>$\neq 0$</td>
            <td>NaN</td>
        </tr>
        <tr>
            <td>正的规格化非零数</td>
            <td>0</td>
            <td> 0 < e < 255 </td>
            <td>f</td>
            <td>$2^{e-127}\ (1.f)$</td>
            <td>0</td>
            <td>0 < e < 2047</td>
            <td>f</td>
            <td>$2^{e-1023}\ (1.f)$</td>
        </tr>
        <tr>
            <td>负的规格化非零数</td>
            <td>1</td>
            <td>0 < e < 255</td>
            <td>f</td>
            <td>$-2^{e-127}\ (1.f)$</td>
            <td>1</td>
            <td>0 < e < 2047</td>
            <td>f</td>
            <td>$-2^{e-1023}\ (1.f)$</td>
        </tr>
        <tr>
            <td>正的规格化数</td>
            <td>0</td>
            <td>0</td>
            <td>$f \neq 0$</td>
            <td>$2^{e-126}\ (0.f)$</td>
            <td>0</td>
            <td>0</td>
            <td>$f \neq 0$</td>
            <td>$2^{e-1022}\ (1.f)$</td>
        </tr>
        <tr>
            <td>负的规格化数</td>
            <td>1</td>
            <td>0</td>
            <td>$f \neq 0$</td>
            <td>$-2^{e-126}\ (0.f)$</td>
            <td>1</td>
            <td>0</td>
            <td>$f \neq 0$</td>
            <td>$-2^{e-1022}\ (1.f)$</td>
        </tr>
    </tbody>
</table>

- 如果戒指范围在 1~254（单精度）和 1 ~ 2046 (双精度)，那么位模式表示了一个规格化的非零浮点数。阶值是移码表示的，故正阶值范围是 - 126 ~ + 127 （单精度）和 - 1022 ~ + 1023（双精度）。一个规格化的数要求二进制小数点左边有一个1；这位是隐藏的，使得有效值的总位数实际为 24位或53位。
- 0阶位与0有效值一起表示正零或者负零，取决于它的符号位。正如我们曾提到的，有精确的0值表示是有益的。
- 全1阶值与0有效值一起表示正无穷大或者负无穷大，取决于它的符号位。能表示无穷大也是有用的。把上溢看成一个错误条件而停止程序执行，还是把它看成是一个 $\infty$ 值带入程序并继续处理，这样的决定权留给用户。
- 0阶值与非0有效值一起表示一个非规格化数。这种情况下，二进制小数点左边的隐藏位是0，并且真实阶值是 -126 或 -1022。数的正负取决于它的符号位。
- 全阶值与非零有效值一起给出非数值，它意味着这不是一个数。而非数用来表示出现了异常。

## 扩展阅读

[计算机浮点算术](http://blog.ccyg.studio/article/c9779274-c8e5-47ed-8fee-9cb8f7eebf84)

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings]()

