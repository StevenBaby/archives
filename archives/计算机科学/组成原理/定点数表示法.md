# 定点数表示法

[annotation]: <id> (b694810d-f3da-42f5-8318-985994ecdfc7)
[annotation]: <status> (protect)
[annotation]: <create_time> (2019-04-17 11:46:23)
[annotation]: <category> (计算机技术)
[annotation]: <tags> (组成原理)

计算机中有众多的数值表示方式，这里重点讨论定点数的表示方法，除此以外还有浮点数的表示方法。

计算机中的数据都是存储在二进制位中的，这一点毋庸置疑。所以要表示数字就需要规定二进制位和实际数字之前的关系。于是就出现了**定点数表示法**。

定点数表示法是因为小数点的位置是固定的，并且假定小数点在最左边，代表是纯小数。在右边，代表纯整数。

## 无符号数和有符号数

**无符号数**，就是整个全部二进制位均用于表示数值，相当于数的绝对值。例如

- 01001 表示无符号数 9
- 11001 表示无符号数 25

> 特别提示
<br>
$0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 0 + 8 + 0 + 0 + 1 = 9$ <br>
$1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 16 + 8 + 0 + 0 + 1 = 25$


然而，生活中用到的数大多数时有符号的，也就是有正也有负。符号常用 + - 号来表示数的正负。用这种形式表示的数值在计算机中称为 **真值**。

计算机中也需要能够表示正负的数，需要用二进制来表示有符号数。通常约定二进制数的最高位为符号位。0表示正，1表示负。这种表示数的形式成为 **机器数**，常见表示机器数有 **原码**、**反码**、**补码** 等不同的形式。

有符号数的最高位用来表示正负，而不再表示数值，于是前面例子中的两个数二进制的含义就发生了一些变化，如：

- 01001 表示 +9
- 11001 表示 原码 -9，补码 -7，反码 -6

> 特别提示 <br>
正数 $+ (1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0) = +9$ <br>
原码 $- (1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0) = -9$

## 原码表示法

原码表示法是一种最简单的表示机器数的方法，其最高位为符号位，0为正，1为负。其余位表示数值。特别地，在原码中，0有两种不同的表示形式：

- +0 = 00000000
- -0 = 10000000

**定点表示整数和小时一般只能表示纯整数或者纯小数 $(0\leq N <1)$**

> 如果表示的是纯整数，原码的定义为：
>$$ [X]_{原} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 2^n)\\
& 2^n - X = 2^n + |X| \ \ (-2^n < X \leq 0) \\
\end{aligned}
\right.
$$

> 如果表示的是纯小数，原码的定义为：
>$$ [X]_{原} =\left\{
\begin{aligned}
& X \ \ (0 \leq X < 1)\\
& 1 - X = 1 + |X| \ \ (-1 < X \leq 0) \\
\end{aligned}
\right.
$$

不过我觉得也没比较细究这个公式，看起来费脑，不过就是很简单的数值运算。

> 特别提示：二进制小数转换为十进制数时，和二进制整数的方式一样，只不过 2 的指数需要依次递减，从最高位开始就变成了 -1，-2 ...，于是有：
> 
> 0.5 = 0.1000000
> 
> 0.75 = 0.1100000
> 
> 0.875 = 0.1110000
>
> 可以看出定点数可以表示的小数精度是有限的

原码表示法的优点是直观易懂，机器数和真值的转换很容易。用原码实现乘除法运算的规则很简单；缺点是实现加减运算的规则较复杂。

## 补码表示法

- [ ] 刨坑待填

## 反码表示法

- [ ] 刨坑待填

## 参考资料

- [Computer Organization and Architecture, 9th Edition - William Stallings]()
- [计算机组成原理 - 蒋本珊 编著](#)