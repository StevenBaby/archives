# 数据结构拾遗

[annotation]: <id> (70d6e5f6-287f-4c5d-811f-6a4fffd0bc51)
[annotation]: <status> (public)
[annotation]: <create_time> (2020-11-02 13:16:05)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (数据结构)
[annotation]: <comments> (false)
[annotation]: <url> (http://blog.ccyg.studio/article/70d6e5f6-287f-4c5d-811f-6a4fffd0bc51)


## 绪论

时间复杂度 $T(n)$ 时指算法中所有语句的频度（执行次数）之和。

渐进时间复杂度是当 $n$ 趋于无穷时 $T(n)$ 的数量级，而非 $T(n)$ 的准确大小，因此以 T(n) 的数量级来表征时间复杂度。

加法规则：

$$
T(n) = T_1(n) + T_2(n) = O[f(n)] + O[g(n)] = O[\max\left\{f(n), g(n)\right\}]
$$

乘法规则：

$$
T(n) = T_1(n) \times T_2(n) = O[f(n)] \times O[g(n)] = O[f(n) \times g(n)]
$$

时间复杂度的大小关系：

$$
O(1) < O(\log n) < O(n^k) < O(2^n) < O(n!)
$$

空间复杂度 $S(n)$ 是指算法运行过程中所使用的**辅助空间**的大小。

**算法原地工作**是指算法所需的辅助空间是常量，空间复杂度是 $O(1)$。

影响辅助空间大小的两个方面：

- 算法运行过程中的各个变量所占的空间，如：辅助数组
- 递归工作栈带来的空间复杂度

## 线性表

- 顺序表：顺序存储，逻辑上相邻的物理上也相邻
- 链表：链式存储，逻辑上相邻的物理上可以不相邻，用指针描述逻辑上的前驱后继关系。

## 栈和队列

当 $n$ 个元素以某种顺序进栈，并且可在任意时刻出栈，所获得的元素排列的数目 $N$ 恰好满足卡特兰数 `Catalan()` 的计算：

$$ N = f_n = \frac{1}{n+1}C_{2n}^n = C_{2n}^n - C_{2n}^{n-1} $$

## 树与二叉树

- **单分支结点数** + **双分支结点数** $\times$ 2 = **所有结点的分支数**
- **总结点数** - 1 = **总分支数**
- 非空二叉树上 **叶子节点数** = **双分支节点数** + $1$
- 树上 **叶子结点数** $L =\displaystyle\sum_{i=2}^m (i-1) * n_i + 1$
  - $i$ 分支节点的度，$n_i$ 为对应节点的个数

* 二叉树的第 $i$ 层上最多有 $2^{i-1} (i \geqslant 1)$ 个节点
* 高度为 $k$ 的二叉树最多有 $2^k - 1 (k \geqslant 1)$ 个节点

- 有 $n$ 个节点的 **完全二叉树**，对各节点从上到下、从左到右依次编号，编号范围为 $1 \sim n$，若 $i$ 为某节点 $a$ 的编号，则节点之间有如下关系：
  - 如果 $i \neq 1$，则 $a$ 双亲节点的编号为 $\lfloor i/2 \rfloor$；
  - 如果 $2i \leqslant n$，则 $a$ 左孩子的编号为 $2i$；如果 $2i > n$，则 $a$ 无左孩子；
  - 如果 $2i + 1 \leqslant n$，则 $a$ 右孩子的编号为 $2i+1$；如果 $2i + 1 > n$，则 $a$ 无右孩子；

* 给定 $n$ 个节点，能构成 `Catalan(n)` 种不同的二叉树，卡特兰函数见上；

- 具有 $n(n\geqslant 1)$ 个节点的完全二叉树的高度为 $h= \lfloor \log_2n\rfloor + 1 = \lceil \log_2(n + 1) \rceil$ 

* **树的后序遍历** 等同于该树对应 **二叉树的中序遍历**

## 哈夫曼树

构造度为 $m$ 的哈夫曼树时，每次把 $m$ 个叶子节点合并成为一个父节点，每次合并减少 $m-1$ 个节点。

