# 排序算法

[annotation]: <id> (e518ad71-a442-4e97-b2a1-72a9c422b483)
[annotation]: <status> (public)
[annotation]: <create_time> (2019-04-25 15:49:36)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (数据结构)
[annotation]: <comments> (true)


> 原文链接：<http://blog.ccyg.studio/article/e518ad71-a442-4e97-b2a1-72a9c422b483>

---

<div class="ui segments">
    <div class="ui segment" id="content">
    </div>
    <div class='ui segment'>
        <button class='ui primary reset button'>重置</button>
        <button class='ui green start button'>开始</button>
        <button class='ui yellow pause button'>暂停</button>
        <button class='ui red stop button'>停止</button>
        <button class='ui teal speed down button'>减速</button>
        <button class='ui pink speed up button'>加速</button>
        <select class="ui sort dropdown" id="sort_type">
        </select>
    </div>
</div>

<div>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.8.0/lib/p5.min.js"></script>
    <script src="sort.js"></script>
</div>

## 概述
排序的过程，实际上是减少逆序数的过程。

**排序算法稳定性**：假设待排序的序列中，存在相同的关键字，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

## 冒泡排序


**冒泡排序**是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

冒泡排序的时间复杂度为 $O(n^2)$，冒泡排序是稳定的。


以下为相关 C++ 代码：

```c++
void bubble_sort(int array[], int begin, int end)
{
    auto temp = 0;
    for (int i = begin; i <= end; i++)
    {
        for (int j = begin + 1; j <= end - i; j++)
        {
            if (array[j - 1] > array[j])
            {
                temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```

## 鸡尾酒排序

鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。

以下为相关 C++ 代码：
```c++
void cocktail_sort(int array[], int begin, int end)
{
    auto left = begin;
    auto right = end;

    while (left < right) {
        for (auto i = left; i < right; i++) {
            if (array[i] > array[i + 1]){
                auto temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        right--;
        for (auto i = right; i > left; i--) {
             if (array[i] < array[i - 1]){
                auto temp = array[i];
                array[i] = array[i - 1];
                array[i - 1] = temp;
            }
        }
        left++;
    }
}
```

## 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的交换操作介于 0 和 (n-1) 次之间。选择排序的比较操作为$\frac{n(n-1)}{2}$次。选择排序的赋值操作介于 3(n-1) 次之间。


比较次数 $O(n^{2})$，比较次数与关键字的初始状态无关，总的比较次数 $N=(n-1)+(n-2)+...+1=n\times (n-1)/2$。交换次数 O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换  n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

以下为相关 C++ 代码：

```c++
void select_sort(int array[], int begin, int end)
{
    auto left = begin;
    auto right = end;
    auto max_index = begin;
    for (auto i = end; i >= begin; i--)
    {
        max_index = begin;
        for (auto j = begin + 1; j <= i; j++)
        {
            if (array[j] > array[max_index])
                max_index = j;
        }
        auto temp = array[max_index];
        array[max_index] = array[i];
        array[i] = temp;
    }
}
```

## 希尔排序

**希尔排序是把记录按下标的一定增量分组，对每组使用插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**


## 快速排序

快速排序（Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n个项目要$O(n\log n)$次比较。在最坏状况下则需要$O(n^{2})$次比较，但这种状况并不常见。事实上，快速排序$\Theta (n\log n)$通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。

以下为相关 C++ 代码：

```c++
void quick_sort(int array[], int begin, int end)
{
    if (begin >= end) return;
    auto pivot = array[begin];

    auto left = begin;
    auto right = end;

    while (left < right) {
        while (left < right && array[right] >= pivot) {
            right --;
        }
        array[left] = array[right];

        while (left < right && array[left] < pivot) {
            left ++;
        }
        array[right] = array[left];
    }
    array[left] = pivot;
    quick_sort(array, begin, left - 1);
    quick_sort(array, left + 1, end);
}
```

## 随机快速排序

考虑到快速排序在列表已经有序或者大部分有序的情况下，效率接近于 $O(n^2)$，所以可以使用随机选取主元的方式来解决这个问题，因为以上快速排序选择区间中的第一个元素作为主元，那么只需要从区间中随机选取一个主元，与第一个元素交换即可。

以下为相关 C++ 代码：

```c++
void random_quick_sort(int array[], int begin, int end)
{
    if (begin >= end) return;

    std::default_random_engine engine(time(nullptr));
    std::uniform_int_distribution<> dis(begin, end);

    auto index = dis(engine);
    auto pivot = array[index];

    auto left = begin;
    auto right = end;

    while (left < right) {
        while (left < right && array[right] >= pivot) {
            right --;
        }
        array[left] = array[right];

        while (left < right && array[left] < pivot) {
            left ++;
        }
        array[right] = array[left];
    }
    array[left] = pivot;
    random_quick_sort(array, begin, left - 1);
    random_quick_sort(array, left + 1, end);
}
```

## 参考资料

- <https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F>
- <https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F>
- <https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F>
- 