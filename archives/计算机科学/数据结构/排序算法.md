# 排序算法

[annotation]: <id> (e518ad71-a442-4e97-b2a1-72a9c422b483)
[annotation]: <status> (public)
[annotation]: <create_time> (2019-04-25 15:49:36)
[annotation]: <category> (计算机科学)
[annotation]: <tags> (数据结构)


> 原文链接：<http://blog.ccyg.studio/article/e518ad71-a442-4e97-b2a1-72a9c422b483>

---

<div class="ui segments">
    <div class="ui segment" id="content">
    </div>
    <div class='ui segment'>
        <button class='ui primary reset button'>重置</button>
        <button class='ui green start button'>开始</button>
        <button class='ui yellow pause button'>暂停</button>
        <button class='ui red stop button'>停止</button>
        <button class='ui teal speed down button'>减速</button>
        <button class='ui pink speed up button'>加速</button>
        <select class="ui sort dropdown" id="sort_type">
        </select>
    </div>
</div>

<div>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@0.8.0/lib/p5.min.js"></script>
    <script src="sort.js"></script>
</div>

## 概述
排序的过程，实际上是减少逆序数的过程。

**排序算法稳定性**：假设待排序的序列中，存在相同的关键字，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

## 冒泡排序


**冒泡排序**是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

冒泡排序的时间复杂度为 $O(n^2)$，冒泡排序是稳定的。


以下为相关 C++ 代码：

```c++
void bubble_sort(int array[], int begin, int end)
{
    auto temp = 0;
    for (int i = begin; i <= end; i++)
    {
        for (int j = begin + 1; j <= end - i; j++)
        {
            if (array[j - 1] > array[j])
            {
                temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```

## 鸡尾酒排序

鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。

以下为相关 C++ 代码：
```c++
void cocktail_sort(int array[], int begin, int end)
{
    auto left = begin;
    auto right = end;

    while (left < right) {
        for (auto i = left; i < right; i++) {
            if (array[i] > array[i + 1]){
                auto temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
        right--;
        for (auto i = right; i > left; i--) {
             if (array[i] < array[i - 1]){
                auto temp = array[i];
                array[i] = array[i - 1];
                array[i - 1] = temp;
            }
        }
        left++;
    }
}
```



## 希尔排序

**希尔排序是把记录按下标的一定增量分组，对每组使用插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**